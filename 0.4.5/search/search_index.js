var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Houdini addon","text":"<p>Houdini integration for AYON.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_houdini<ul> <li>addon</li> <li>api<ul> <li>action</li> <li>colorspace</li> <li>creator_node_shelves</li> <li>hda_utils</li> <li>lib</li> <li>pipeline</li> <li>plugin</li> <li>shelves</li> <li>usd</li> <li>workfile_template_builder</li> </ul> </li> <li>hooks<ul> <li>set_default_display_and_view</li> <li>set_paths</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>convert_legacy</li> <li>create_alembic_camera</li> <li>create_arnold_ass</li> <li>create_arnold_rop</li> <li>create_bgeo</li> <li>create_composite</li> <li>create_fbx</li> <li>create_hda</li> <li>create_karma_rop</li> <li>create_mantra_rop</li> <li>create_model</li> <li>create_pointcache</li> <li>create_redshift_proxy</li> <li>create_redshift_rop</li> <li>create_review</li> <li>create_rig</li> <li>create_usd</li> <li>create_usd_componentbuilder</li> <li>create_usdrender</li> <li>create_vbd_cache</li> <li>create_vray_rop</li> <li>create_workfile</li> </ul> </li> <li>inventory<ul> <li>select_containers</li> <li>set_camera_resolution</li> <li>show_parameters</li> </ul> </li> <li>load<ul> <li>actions</li> <li>load_alembic</li> <li>load_alembic_archive</li> <li>load_ass</li> <li>load_asset_lop</li> <li>load_bgeo</li> <li>load_camera</li> <li>load_fbx</li> <li>load_filepath</li> <li>load_hda</li> <li>load_image</li> <li>load_redshift_proxy</li> <li>load_shot_lop</li> <li>load_usd_layer</li> <li>load_usd_reference</li> <li>load_usd_sop</li> <li>load_vdb</li> <li>show_usdview</li> </ul> </li> <li>publish<ul> <li>collect_arnold_rop</li> <li>collect_cache_farm</li> <li>collect_componentbuilder_lop</li> <li>collect_current_file</li> <li>collect_farm_instances</li> <li>collect_files_for_cleaning_up</li> <li>collect_frames</li> <li>collect_frames_fix</li> <li>collect_inputs</li> <li>collect_karma_rop</li> <li>collect_local_render_instances</li> <li>collect_mantra_rop</li> <li>collect_output_node</li> <li>collect_redshift_rop</li> <li>collect_render_colorspace</li> <li>collect_render_products</li> <li>collect_renderlayer</li> <li>collect_review_data</li> <li>collect_reviewable_instances</li> <li>collect_rop_frame_range</li> <li>collect_staticmesh_type</li> <li>collect_task_handles</li> <li>collect_usd_layers</li> <li>collect_usd_look_assets</li> <li>collect_usd_render</li> <li>collect_usd_rop_layer_and_stage</li> <li>collect_vray_rop</li> <li>collect_workfile</li> <li>collect_workscene_fps</li> <li>extract_active_view_thumbnail</li> <li>extract_hda</li> <li>extract_last_published</li> <li>extract_render</li> <li>extract_rop</li> <li>extract_usd</li> <li>increment_current_file</li> <li>save_scene</li> <li>validate_abc_primitive_to_detail</li> <li>validate_alembic_face_sets</li> <li>validate_alembic_input_node</li> <li>validate_animation_settings</li> <li>validate_bypass</li> <li>validate_camera_rop</li> <li>validate_cop_output_node</li> <li>validate_export_is_a_single_frame</li> <li>validate_fbx_output_node</li> <li>validate_file_extension</li> <li>validate_frame_range</li> <li>validate_frame_range_frames_to_fix</li> <li>validate_frame_token</li> <li>validate_houdini_license_category</li> <li>validate_instance_in_context</li> <li>validate_mesh_is_static</li> <li>validate_mkpaths_toggled</li> <li>validate_no_errors</li> <li>validate_primitive_hierarchy_paths</li> <li>validate_render_product_paths_unique</li> <li>validate_render_products</li> <li>validate_resolution</li> <li>validate_review_colorspace</li> <li>validate_scene_review</li> <li>validate_sop_output_node</li> <li>validate_subset_name</li> <li>validate_unreal_staticmesh_naming</li> <li>validate_usd_asset_contribution_default_prim</li> <li>validate_usd_look_assignments</li> <li>validate_usd_look_disallowed_types</li> <li>validate_usd_look_material_defs</li> <li>validate_usd_output_node</li> <li>validate_usd_render_arnold</li> <li>validate_usd_render_product_names</li> <li>validate_usd_render_product_paths</li> <li>validate_usd_rop_default_prim</li> <li>validate_vdb_output_node</li> <li>validate_wait_for_render</li> <li>validate_workfile_paths</li> </ul> </li> <li>workfile_build<ul> <li>create_placeholder</li> <li>load_placeholder</li> </ul> </li> </ul> </li> <li>startup<ul> <li>husdplugins<ul> <li>outputprocessors<ul> <li>ayon_uri_processor</li> <li>remap_to_publish</li> </ul> </li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>create</li> <li>general</li> <li>imageio</li> <li>load</li> <li>main</li> <li>publish</li> <li>shelves</li> <li>templated_workfile_build</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_houdini/index.html","title":"ayon_houdini","text":""},{"location":"autoapi/client/ayon_houdini/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_houdini/version.html","title":"version","text":"<p>Package declaring AYON addon 'houdini' version.</p>"},{"location":"autoapi/client/ayon_houdini/api/index.html","title":"api","text":""},{"location":"autoapi/client/ayon_houdini/api/index.html#client.ayon_houdini.api.HoudiniHost","title":"<code>HoudiniHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_houdini/api/pipeline.py</code> <pre><code>class HoudiniHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"houdini\"\n\n    def __init__(self):\n        super(HoudiniHost, self).__init__()\n        self._op_events = {}\n        self._has_been_setup = False\n\n    def install(self):\n        pyblish.api.register_host(\"houdini\")\n        pyblish.api.register_host(\"hython\")\n        pyblish.api.register_host(\"hpython\")\n\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_inventory_action_path(INVENTORY_PATH)\n        register_workfile_build_plugin_path(WORKFILE_BUILD_PATH)\n\n        log.info(\"Installing callbacks ... \")\n        # register_event_callback(\"init\", on_init)\n        self._register_callbacks()\n        register_event_callback(\"workfile.save.before\", before_workfile_save)\n        register_event_callback(\"before.save\", before_save)\n        register_event_callback(\"save\", on_save)\n        register_event_callback(\"open\", on_open)\n        register_event_callback(\"new\", on_new)\n        register_event_callback(\"taskChanged\", on_task_changed)\n\n        self._has_been_setup = True\n\n        # Manually call on_new callback as it doesn't get called when AYON\n        # launches for the first time on a context, only when going to\n        # File -&gt; New\n        on_new()\n\n        if not IS_HEADLESS:\n            import hdefereval  # noqa, hdefereval is only available in ui mode\n            # Defer generation of shelves due to issue on Windows where shelf\n            # initialization during start up delays Houdini UI by minutes\n            # making it extremely slow to launch.\n            hdefereval.executeDeferred(shelves.generate_shelves)\n            hdefereval.executeDeferred(creator_node_shelves.install)\n            if env_value_to_bool(\"AYON_WORKFILE_TOOL_ON_START\"):\n                hdefereval.executeDeferred(\n                    lambda: host_tools.show_workfiles(\n                        parent=hou.qt.mainWindow()\n                    )\n                )\n\n    def workfile_has_unsaved_changes(self):\n        return hou.hipFile.hasUnsavedChanges()\n\n    def get_workfile_extensions(self):\n        return [\".hip\", \".hiplc\", \".hipnc\"]\n\n    def save_workfile(self, dst_path=None):\n        # Force forwards slashes to avoid segfault\n        if dst_path:\n            dst_path = dst_path.replace(\"\\\\\", \"/\")\n        hou.hipFile.save(file_name=dst_path,\n                         save_to_recent_files=True)\n        return dst_path\n\n    def open_workfile(self, filepath):\n        # Force forwards slashes to avoid segfault\n        filepath = filepath.replace(\"\\\\\", \"/\")\n\n        try:\n            hou.hipFile.load(filepath,\n                             suppress_save_prompt=True,\n                             ignore_load_warnings=False)\n        except hou.LoadWarning as exc:\n            log.warning(exc)\n\n        return filepath\n\n    def get_current_workfile(self):\n        current_filepath = hou.hipFile.path()\n        if (os.path.basename(current_filepath) == \"untitled.hip\" and\n                not os.path.exists(current_filepath)):\n            # By default a new scene in houdini is saved in the current\n            # working directory as \"untitled.hip\" so we need to capture\n            # that and consider it 'not saved' when it's in that state.\n            return None\n\n        return current_filepath\n\n    def get_containers(self):\n        return ls()\n\n    def _register_callbacks(self):\n        for event in self._op_events.copy().values():\n            if event is None:\n                continue\n\n            try:\n                hou.hipFile.removeEventCallback(event)\n            except RuntimeError as e:\n                log.info(e)\n\n        self._op_events[on_file_event_callback] = hou.hipFile.addEventCallback(\n            on_file_event_callback\n        )\n\n    @staticmethod\n    def create_context_node():\n        \"\"\"Helper for creating context holding node.\n\n        Returns:\n            hou.Node: context node\n\n        \"\"\"\n        obj_network = hou.node(\"/obj\")\n        op_ctx = obj_network.createNode(\"subnet\",\n                                        node_name=\"OpenPypeContext\",\n                                        run_init_scripts=False,\n                                        load_contents=False)\n\n        op_ctx.moveToGoodPosition()\n        op_ctx.setBuiltExplicitly(False)\n        op_ctx.setCreatorState(\"OpenPype\")\n        op_ctx.setComment(\"OpenPype node to hold context metadata\")\n        op_ctx.setColor(hou.Color((0.081, 0.798, 0.810)))\n        op_ctx.setDisplayFlag(False)\n        op_ctx.hide(True)\n        return op_ctx\n\n    def update_context_data(self, data, changes):\n        op_ctx = hou.node(CONTEXT_CONTAINER)\n        if not op_ctx:\n            op_ctx = self.create_context_node()\n\n        lib.imprint(op_ctx, data, update=True)\n\n    def get_context_data(self):\n        op_ctx = hou.node(CONTEXT_CONTAINER)\n        if not op_ctx:\n            op_ctx = self.create_context_node()\n        return lib.read(op_ctx)\n\n    def save_file(self, dst_path=None):\n        # Force forwards slashes to avoid segfault\n        dst_path = dst_path.replace(\"\\\\\", \"/\")\n\n        hou.hipFile.save(file_name=dst_path,\n                         save_to_recent_files=True)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/index.html#client.ayon_houdini.api.HoudiniHost.create_context_node","title":"<code>create_context_node()</code>  <code>staticmethod</code>","text":"<p>Helper for creating context holding node.</p> <p>Returns:</p> Type Description <p>hou.Node: context node</p> Source code in <code>client/ayon_houdini/api/pipeline.py</code> <pre><code>@staticmethod\ndef create_context_node():\n    \"\"\"Helper for creating context holding node.\n\n    Returns:\n        hou.Node: context node\n\n    \"\"\"\n    obj_network = hou.node(\"/obj\")\n    op_ctx = obj_network.createNode(\"subnet\",\n                                    node_name=\"OpenPypeContext\",\n                                    run_init_scripts=False,\n                                    load_contents=False)\n\n    op_ctx.moveToGoodPosition()\n    op_ctx.setBuiltExplicitly(False)\n    op_ctx.setCreatorState(\"OpenPype\")\n    op_ctx.setComment(\"OpenPype node to hold context metadata\")\n    op_ctx.setColor(hou.Color((0.081, 0.798, 0.810)))\n    op_ctx.setDisplayFlag(False)\n    op_ctx.hide(True)\n    return op_ctx\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/index.html#client.ayon_houdini.api.containerise","title":"<code>containerise(name, namespace, nodes, context, loader=None, suffix='')</code>","text":"<p>Bundle <code>nodes</code> into a subnet and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>nodes</code> <code>list</code> <p>Long names of nodes to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Name of container assembly</p> Source code in <code>client/ayon_houdini/api/pipeline.py</code> <pre><code>def containerise(name,\n                 namespace,\n                 nodes,\n                 context,\n                 loader=None,\n                 suffix=\"\"):\n    \"\"\"Bundle `nodes` into a subnet and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        nodes (list): Long names of nodes to containerise\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Name of container assembly\n\n    \"\"\"\n\n    # Get AVALON_CONTAINERS subnet\n    subnet = get_or_create_avalon_container()\n\n    # Create proper container name\n    container_name = \"{}_{}\".format(name, suffix or \"CON\")\n    container = hou.node(\"/obj/{}\".format(name))\n    container.setName(container_name, unique_name=True)\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"]\n    }\n\n    lib.imprint(container, data)\n\n    # \"Parent\" the container under the container network\n    hou.moveNodesTo([container], subnet)\n\n    subnet.node(container_name).moveToGoodPosition()\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/index.html#client.ayon_houdini.api.lsattr","title":"<code>lsattr(attr, value=None, root='/')</code>","text":"<p>Return nodes that have <code>attr</code>  When <code>value</code> is not None it will only return nodes matching that value  for the given attribute.  Args:      attr (str): Name of the attribute (hou.Parm)      value (object, Optional): The value to compare the attribute too.         When the default None is provided the value check is skipped.     root (str): The root path in Houdini to search in. Returns:     list: Matching nodes that have attribute with value.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def lsattr(attr, value=None, root=\"/\"):\n    \"\"\"Return nodes that have `attr`\n     When `value` is not None it will only return nodes matching that value\n     for the given attribute.\n     Args:\n         attr (str): Name of the attribute (hou.Parm)\n         value (object, Optional): The value to compare the attribute too.\n            When the default None is provided the value check is skipped.\n        root (str): The root path in Houdini to search in.\n    Returns:\n        list: Matching nodes that have attribute with value.\n    \"\"\"\n    if value is None:\n        # Use allSubChildren() as allNodes() errors on nodes without\n        # permission to enter without a means to continue of querying\n        # the rest\n        nodes = hou.node(root).allSubChildren()\n        return [n for n in nodes if n.parm(attr)]\n    return lsattrs({attr: value})\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/index.html#client.ayon_houdini.api.lsattrs","title":"<code>lsattrs(attrs, root='/')</code>","text":"<p>Return nodes matching <code>key</code> and <code>value</code> Arguments:     attrs (dict): collection of attribute: value     root (str): The root path in Houdini to search in. Example:     &gt;&gt; lsattrs({\"id\": \"myId\"})     [\"myNode\"]     &gt;&gt; lsattr(\"id\")     [\"myNode\", \"myOtherNode\"] Returns:     list: Matching nodes that have attribute with value.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def lsattrs(attrs, root=\"/\"):\n    \"\"\"Return nodes matching `key` and `value`\n    Arguments:\n        attrs (dict): collection of attribute: value\n        root (str): The root path in Houdini to search in.\n    Example:\n        &gt;&gt; lsattrs({\"id\": \"myId\"})\n        [\"myNode\"]\n        &gt;&gt; lsattr(\"id\")\n        [\"myNode\", \"myOtherNode\"]\n    Returns:\n        list: Matching nodes that have attribute with value.\n    \"\"\"\n\n    matches = set()\n    # Use allSubChildren() as allNodes() errors on nodes without\n    # permission to enter without a means to continue of querying\n    # the rest\n    nodes = hou.node(root).allSubChildren()\n    for node in nodes:\n        for attr in attrs:\n            if not node.parm(attr):\n                continue\n            elif node.evalParm(attr) != attrs[attr]:\n                continue\n            else:\n                matches.add(node)\n\n    return list(matches)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/index.html#client.ayon_houdini.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context Example:     &gt;&gt;&gt; with maintained_selection():     ...     # Modify selection     ...     node.setSelected(on=False, clear_all_selected=True)     &gt;&gt;&gt; # Selection restored</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>@contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context\n    Example:\n        &gt;&gt;&gt; with maintained_selection():\n        ...     # Modify selection\n        ...     node.setSelected(on=False, clear_all_selected=True)\n        &gt;&gt;&gt; # Selection restored\n    \"\"\"\n\n    previous_selection = hou.selectedNodes()\n    try:\n        yield\n    finally:\n        # Clear the selection\n        # todo: does hou.clearAllSelected() do the same?\n        for node in hou.selectedNodes():\n            node.setSelected(on=False)\n\n        if previous_selection:\n            for node in previous_selection:\n                node.setSelected(on=True)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/index.html#client.ayon_houdini.api.read","title":"<code>read(node)</code>","text":"<p>Read the container data in to a dict</p> <p>Parameters:</p> Name Type Description Default <code>node(hou.Node)</code> <p>Houdini node</p> required <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def read(node):\n    \"\"\"Read the container data in to a dict\n\n    Args:\n        node(hou.Node): Houdini node\n\n    Returns:\n        dict\n\n    \"\"\"\n    # `spareParms` returns a tuple of hou.Parm objects\n    data = {}\n    if not node:\n        return data\n    for parameter in node.spareParms():\n        value = parameter.eval()\n        # test if value is json encoded dict\n        if isinstance(value, str) and \\\n                value.startswith(JSON_PREFIX):\n            try:\n                value = json.loads(value[len(JSON_PREFIX):])\n            except json.JSONDecodeError:\n                # not a json\n                pass\n        data[parameter.name()] = value\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/action.html","title":"action","text":""},{"location":"autoapi/client/ayon_houdini/api/action.html#client.ayon_houdini.api.action.SelectInvalidAction","title":"<code>SelectInvalidAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select invalid nodes in Maya when plug-in failed.</p> <p>To retrieve the invalid nodes this assumes a static <code>get_invalid()</code> method is available on the plugin.</p> Source code in <code>client/ayon_houdini/api/action.py</code> <pre><code>class SelectInvalidAction(pyblish.api.Action):\n    \"\"\"Select invalid nodes in Maya when plug-in failed.\n\n    To retrieve the invalid nodes this assumes a static `get_invalid()`\n    method is available on the plugin.\n\n    \"\"\"\n    label = \"Select invalid\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"search\"  # Icon from Awesome Icon\n\n    def process(self, context, plugin):\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid nodes..\")\n        invalid = list()\n        if issubclass(plugin, pyblish.api.ContextPlugin):\n            invalid = plugin.get_invalid(context)\n        else:\n            errored_instances = get_errored_instances_from_context(\n                context, plugin=plugin\n            )\n            for instance in errored_instances:\n                invalid_nodes = plugin.get_invalid(instance)\n                if invalid_nodes:\n                    if isinstance(invalid_nodes, (list, tuple)):\n                        invalid.extend(invalid_nodes)\n                    else:\n                        self.log.warning(\"Plug-in returned to be invalid, \"\n                                         \"but has no selectable nodes.\")\n\n        hou.clearAllSelected()\n        if invalid:\n            self.log.info(\"Selecting invalid nodes: {}\".format(\n                \", \".join(node.path() for node in invalid)\n            ))\n            for node in invalid:\n                node.setSelected(True)\n                node.setCurrent(True)\n        else:\n            self.log.info(\"No invalid nodes found.\")\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/action.html#client.ayon_houdini.api.action.SelectROPAction","title":"<code>SelectROPAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select ROP.</p> <p>It's used to select the associated ROPs with the errored instances.</p> Source code in <code>client/ayon_houdini/api/action.py</code> <pre><code>class SelectROPAction(pyblish.api.Action):\n    \"\"\"Select ROP.\n\n    It's used to select the associated ROPs with the errored instances.\n    \"\"\"\n\n    label = \"Select ROP\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"mdi.cursor-default-click\"\n\n    def process(self, context, plugin):\n        errored_instances = get_errored_instances_from_context(context, plugin)\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding ROP nodes..\")\n        rop_nodes = list()\n        for instance in errored_instances:\n            node_path = instance.data.get(\"instance_node\")\n            if not node_path:\n                continue\n\n            node = hou.node(node_path)\n            if not node:\n                continue\n\n            rop_nodes.append(node)\n\n        hou.clearAllSelected()\n        if rop_nodes:\n            self.log.info(\"Selecting ROP nodes: {}\".format(\n                \", \".join(node.path() for node in rop_nodes)\n            ))\n            for node in rop_nodes:\n                node.setSelected(True)\n                node.setCurrent(True)\n        else:\n            self.log.info(\"No ROP nodes found.\")\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/colorspace.html","title":"colorspace","text":""},{"location":"autoapi/client/ayon_houdini/api/colorspace.html#client.ayon_houdini.api.colorspace.ARenderProduct","title":"<code>ARenderProduct</code>","text":"<p>               Bases: <code>object</code></p> <p>This is the minimal data structure required to get <code>ayon_core.pipeline.farm.pyblish_functions.create_instances_for_aov</code> to work with deadline addon's job submissions.</p> Source code in <code>client/ayon_houdini/api/colorspace.py</code> <pre><code>class ARenderProduct(object):\n    \"\"\"This is the minimal data structure required to get\n    `ayon_core.pipeline.farm.pyblish_functions.create_instances_for_aov` to\n    work with deadline addon's job submissions.\"\"\"\n    # TODO: The exact data structure should actually be defined in core for all\n    #  addons to align.\n    def __init__(self, aov_names: List[str]):\n        colorspace = get_scene_linear_colorspace()\n        products = [\n            RenderProduct(colorspace=colorspace, productName=aov_name)\n            for aov_name in aov_names\n        ]\n        self.layer_data = LayerMetadata(products=products)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/colorspace.html#client.ayon_houdini.api.colorspace.LayerMetadata","title":"<code>LayerMetadata</code>","text":"<p>               Bases: <code>object</code></p> <p>Data class for Render Layer metadata.</p> Source code in <code>client/ayon_houdini/api/colorspace.py</code> <pre><code>@attr.s\nclass LayerMetadata(object):\n    \"\"\"Data class for Render Layer metadata.\"\"\"\n    products: \"List[RenderProduct]\" = attr.ib()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/colorspace.html#client.ayon_houdini.api.colorspace.RenderProduct","title":"<code>RenderProduct</code>","text":"<p>               Bases: <code>object</code></p> <p>Specific Render Product Parameter for submitting.</p> Source code in <code>client/ayon_houdini/api/colorspace.py</code> <pre><code>@attr.s\nclass RenderProduct(object):\n    \"\"\"Specific Render Product Parameter for submitting.\"\"\"\n    colorspace = attr.ib()                      # colorspace\n    productName = attr.ib(default=None)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/colorspace.html#client.ayon_houdini.api.colorspace.get_default_display_view_colorspace","title":"<code>get_default_display_view_colorspace()</code>","text":"<p>Returns the colorspace attribute of the default (display, view) pair.</p> <p>It's used for 'ociocolorspace' parm in OpenGL Node.</p> Source code in <code>client/ayon_houdini/api/colorspace.py</code> <pre><code>def get_default_display_view_colorspace():\n    \"\"\"Returns the colorspace attribute of the default (display, view) pair.\n\n    It's used for 'ociocolorspace' parm in OpenGL Node.\"\"\"\n\n    prefs = get_color_management_preferences()\n    return get_display_view_colorspace_name(\n        config_path=prefs[\"config\"],\n        display=prefs[\"display\"],\n        view=prefs[\"view\"]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/colorspace.html#client.ayon_houdini.api.colorspace.get_scene_linear_colorspace","title":"<code>get_scene_linear_colorspace()</code>","text":"<p>Return colorspace name for Houdini's OCIO config scene linear role.</p> <p>By default, renderers in Houdini render output images in the scene linear role colorspace.</p> <p>Returns:</p> Type Description <p>Optional[str]: The colorspace name for the 'scene_linear' role in the OCIO config Houdini is currently set to.</p> Source code in <code>client/ayon_houdini/api/colorspace.py</code> <pre><code>def get_scene_linear_colorspace():\n    \"\"\"Return colorspace name for Houdini's OCIO config scene linear role.\n\n    By default, renderers in Houdini render output images in the scene linear\n    role colorspace.\n\n    Returns:\n        Optional[str]: The colorspace name for the 'scene_linear' role in\n            the OCIO config Houdini is currently set to.\n    \"\"\"\n    ocio_config_path = hou.Color.ocio_configPath()\n    colorspaces = get_ocio_config_colorspaces(ocio_config_path)\n    return colorspaces[\"roles\"].get(\"scene_linear\", {}).get(\"colorspace\")\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/creator_node_shelves.html","title":"creator_node_shelves","text":"<p>Library to register OpenPype Creators for Houdini TAB node search menu.</p> <p>This can be used to install custom houdini tools for the TAB search menu which will trigger a publish instance to be created interactively.</p> <p>The Creators are automatically registered on launch of Houdini through the Houdini integration's <code>host.install()</code> method.</p>"},{"location":"autoapi/client/ayon_houdini/api/creator_node_shelves.html#client.ayon_houdini.api.creator_node_shelves.create_interactive","title":"<code>create_interactive(creator_identifier, **kwargs)</code>","text":"<p>Create a Creator using its identifier interactively.</p> <p>This is used by the generated shelf tools as callback when a user selects the creator from the node tab search menu.</p> <p>The <code>kwargs</code> should be what Houdini passes to the tool create scripts context. For more information see: https://www.sidefx.com/docs/houdini/hom/tool_script.html#arguments</p> <p>Parameters:</p> Name Type Description Default <code>creator_identifier</code> <code>str</code> <p>The creator identifier of the Creator plugin to create.</p> required Return <p>list: The created instances.</p> Source code in <code>client/ayon_houdini/api/creator_node_shelves.py</code> <pre><code>def create_interactive(creator_identifier, **kwargs):\n    \"\"\"Create a Creator using its identifier interactively.\n\n    This is used by the generated shelf tools as callback when a user selects\n    the creator from the node tab search menu.\n\n    The `kwargs` should be what Houdini passes to the tool create scripts\n    context. For more information see:\n    https://www.sidefx.com/docs/houdini/hom/tool_script.html#arguments\n\n    Args:\n        creator_identifier (str): The creator identifier of the Creator plugin\n            to create.\n\n    Return:\n        list: The created instances.\n\n    \"\"\"\n    host = registered_host()\n    context = CreateContext(host)\n    creator = context.manual_creators.get(creator_identifier)\n    if not creator:\n        raise RuntimeError(\"Invalid creator identifier: {}\".format(\n            creator_identifier)\n        )\n\n    # TODO Use Qt instead\n    result, variant = hou.ui.readInput(\n        \"Define variant name\",\n        buttons=(\"Ok\", \"Cancel\"),\n        initial_contents=creator.get_default_variant(),\n        title=\"Define variant\",\n        help=\"Set the variant for the publish instance\",\n        close_choice=1\n    )\n\n    if result == 1:\n        # User interrupted\n        return\n\n    variant = variant.strip()\n    if not variant:\n        raise RuntimeError(\"Empty variant value entered.\")\n\n    # TODO: Once more elaborate unique create behavior should exist per Creator\n    #   instead of per network editor area then we should move this from here\n    #   to a method on the Creators for which this could be the default\n    #   implementation.\n    pane = stateutils.activePane(kwargs)\n    is_null_created = False\n    if isinstance(pane, hou.NetworkEditor):\n        pwd = pane.pwd()\n        project_name = context.get_current_project_name()\n        folder_path = context.get_current_folder_path()\n        task_name = context.get_current_task_name()\n        folder_entity = ayon_api.get_folder_by_path(\n            project_name, folder_path\n        )\n        task_entity = ayon_api.get_task_by_name(\n            project_name, folder_entity[\"id\"], task_name\n        )\n        product_name = creator.get_product_name(\n            project_name=context.get_current_project_name(),\n            folder_entity=folder_entity,\n            task_entity=task_entity,\n            variant=variant,\n            host_name=context.host_name,\n        )\n\n        tool_fn = CATEGORY_GENERIC_TOOL.get(pwd.childTypeCategory())\n        if tool_fn is not None:\n            out_null = tool_fn(kwargs, \"null\")\n            # TODO: For whatever reason the code does not continue if the\n            #  user cancels the operation with escape; yet also no error seems\n            #  to be raised.\n            if out_null:\n                out_null.setName(\"OUT_{}\".format(product_name),\n                                 unique_name=True)\n                is_null_created = True\n\n    before = context.instances_by_id.copy()\n\n    # Create the instance\n    context.create(\n        creator_identifier=creator_identifier,\n        variant=variant,\n        pre_create_data={\"use_selection\": True}\n    )\n\n    # For convenience we set the new node as current since that's much more\n    # familiar to the artist when creating a node interactively. However\n    # we do not select it if the user used the \"null\" place down functionality\n    # TODO Allow to disable auto-select in studio settings or user preferences\n    #  allow to choose:\n    #  - always select instance node\n    #  - never select instance node\n    #  - select null if created else select instance node (current default)\n    after = context.instances_by_id\n    new = set(after) - set(before)\n    if new and not is_null_created:\n        # Select the new instance\n        for instance_id in new:\n            instance = after[instance_id]\n            node = hou.node(instance.get(\"instance_node\"))\n            node.setCurrent(True)\n\n    return list(new)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/creator_node_shelves.html#client.ayon_houdini.api.creator_node_shelves.install","title":"<code>install()</code>","text":"<p>Install the Creator plug-ins to show in Houdini's TAB node search menu.</p> <p>This function is re-entrant and can be called again to reinstall and update the node definitions. For example during development it can be useful to call it manually:     &gt;&gt;&gt; from ayon_houdini.api.creator_node_shelves import install     &gt;&gt;&gt; install()</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of <code>hou.Tool</code> instances</p> Source code in <code>client/ayon_houdini/api/creator_node_shelves.py</code> <pre><code>def install():\n    \"\"\"Install the Creator plug-ins to show in Houdini's TAB node search menu.\n\n    This function is re-entrant and can be called again to reinstall and\n    update the node definitions. For example during development it can be\n    useful to call it manually:\n        &gt;&gt;&gt; from ayon_houdini.api.creator_node_shelves import install\n        &gt;&gt;&gt; install()\n\n    Returns:\n        list: List of `hou.Tool` instances\n\n    \"\"\"\n\n    host = registered_host()\n\n    # Store the filepath on the host\n    # TODO: Define a less hacky static shelf path for current houdini session\n    filepath_attr = \"_creator_node_shelf_filepath\"\n    filepath = getattr(host, filepath_attr, None)\n    if filepath is None:\n        f = tempfile.NamedTemporaryFile(prefix=\"houdini_creator_nodes_\",\n                                        suffix=\".shelf\",\n                                        delete=False)\n        f.close()\n        filepath = f.name\n        setattr(host, filepath_attr, filepath)\n    elif os.path.exists(filepath):\n        # Remove any existing shelf file so that we can completey regenerate\n        # and update the tools file if creator identifiers change\n        os.remove(filepath)\n\n    icon = get_ayon_icon_filepath()\n    tab_menu_label = os.environ.get(\"AYON_MENU_LABEL\") or \"AYON\"\n\n    # Create context only to get creator plugins, so we don't reset and only\n    # populate what we need to retrieve the list of creator plugins\n    create_context = CreateContext(host, reset=False)\n    create_context.reset_current_context()\n    create_context._reset_creator_plugins()\n\n    log.debug(\"Writing OpenPype Creator nodes to shelf: {}\".format(filepath))\n    tools = []\n\n    with shelves_change_block():\n        for identifier, creator in create_context.manual_creators.items():\n\n            # Allow the creator plug-in itself to override the categories\n            # for where they are shown with `Creator.get_network_categories()`\n            if not hasattr(creator, \"get_network_categories\"):\n                log.debug(\"Creator {} has no `get_network_categories` method \"\n                          \"and will not be added to TAB search.\")\n                continue\n\n            network_categories = creator.get_network_categories()\n            if not network_categories:\n                continue\n\n            key = \"ayon_create.{}\".format(identifier)\n            log.debug(f\"Registering {key}\")\n            script = CREATE_SCRIPT.format(identifier=identifier)\n            data = {\n                \"script\": script,\n                \"language\": hou.scriptLanguage.Python,\n                \"icon\": icon,\n                \"help\": \"Create Ayon publish instance for {}\".format(\n                    creator.label\n                ),\n                \"help_url\": None,\n                \"network_categories\": network_categories,\n                \"viewer_categories\": [],\n                \"cop_viewer_categories\": [],\n                \"network_op_type\": None,\n                \"viewer_op_type\": None,\n                \"locations\": [tab_menu_label]\n            }\n            label = \"Create {}\".format(creator.label)\n            tool = hou.shelves.tool(key)\n            if tool:\n                tool.setData(**data)\n                tool.setLabel(label)\n            else:\n                tool = hou.shelves.newTool(\n                    file_path=filepath,\n                    name=key,\n                    label=label,\n                    **data\n                )\n\n            tools.append(tool)\n\n    # Ensure the shelf is reloaded\n    hou.shelves.loadFile(filepath)\n\n    return tools\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/creator_node_shelves.html#client.ayon_houdini.api.creator_node_shelves.shelves_change_block","title":"<code>shelves_change_block()</code>","text":"<p>Write shelf changes at the end of the context.</p> Source code in <code>client/ayon_houdini/api/creator_node_shelves.py</code> <pre><code>@contextlib.contextmanager\ndef shelves_change_block():\n    \"\"\"Write shelf changes at the end of the context.\"\"\"\n    hou.shelves.beginChangeBlock()\n    try:\n        yield\n    finally:\n        hou.shelves.endChangeBlock()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html","title":"hda_utils","text":"<p>Heper functions for load HDA</p>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.SelectFolderPathDialog","title":"<code>SelectFolderPathDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Simple dialog to allow a user to select project and asset.</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>class SelectFolderPathDialog(QtWidgets.QDialog):\n    \"\"\"Simple dialog to allow a user to select project and asset.\"\"\"\n\n    def __init__(self, parent=None):\n        super(SelectFolderPathDialog, self).__init__(parent)\n        self.setWindowTitle(\"Set project and folder path\")\n        self.setStyleSheet(load_stylesheet())\n\n        project_widget = QtWidgets.QComboBox()\n        project_widget.addItems(self.get_projects())\n\n        filter_widget = QtWidgets.QLineEdit()\n        filter_widget.setPlaceholderText(\"Folder name filter...\")\n\n        folder_widget = SimpleFoldersWidget(parent=self)\n\n        accept_button = QtWidgets.QPushButton(\"Set folder path\")\n\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.addWidget(project_widget, 0)\n        main_layout.addWidget(filter_widget, 0)\n        main_layout.addWidget(folder_widget, 1)\n        main_layout.addWidget(accept_button, 0)\n\n        self.project_widget = project_widget\n        self.folder_widget = folder_widget\n\n        project_widget.currentTextChanged.connect(self.on_project_changed)\n        filter_widget.textChanged.connect(folder_widget.set_name_filter)\n        folder_widget.double_clicked.connect(self.accept)\n        accept_button.clicked.connect(self.accept)\n\n    def get_selected_folder_path(self) -&gt; str:\n        return self.folder_widget.get_selected_folder_path()\n\n    def get_selected_project_name(self) -&gt; str:\n        return self.project_widget.currentText()\n\n    def get_projects(self) -&gt; List[str]:\n        projects = ayon_api.get_projects(fields=[\"name\"])\n        return [p[\"name\"] for p in projects]\n\n    def on_project_changed(self, project_name: str):\n        self.folder_widget.set_project_name(project_name)\n\n    def set_project_name(self, project_name: str):\n        self.project_widget.setCurrentText(project_name)\n\n        if self.project_widget.currentText() != project_name:\n            # Project does not exist\n            return\n\n        # Force the set of widget because even though a callback exist on the\n        # project widget it may have been initialized to that value and hence\n        # detect no change.\n        self.folder_widget.set_project_name(project_name)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.SelectProductDialog","title":"<code>SelectProductDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Simple dialog to allow a user to select a product.</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>class SelectProductDialog(QtWidgets.QDialog):\n    \"\"\"Simple dialog to allow a user to select a product.\"\"\"\n\n    def __init__(self, project_name, folder_id, parent=None):\n        super(SelectProductDialog, self).__init__(parent)\n        self.setWindowTitle(\"Select a Product\")\n        self.setStyleSheet(load_stylesheet())\n\n        self.project_name = project_name\n        self.folder_id = folder_id\n\n        # Create widgets and layout\n        product_types_widget = QtWidgets.QComboBox()\n        products_widget = QtWidgets.QListWidget()\n        accept_button = QtWidgets.QPushButton(\"Set product name\")\n\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.setContentsMargins(0, 0, 0, 0)\n        main_layout.addWidget(product_types_widget, 0)\n        main_layout.addWidget(products_widget, 1)\n        main_layout.addWidget(accept_button, 0)\n\n        self.product_types_widget = product_types_widget\n        self.products_widget = products_widget\n\n        # Connect Signals\n        product_types_widget.currentTextChanged.connect(self.on_product_type_changed)\n        products_widget.itemDoubleClicked.connect(self.accept)\n        accept_button.clicked.connect(self.accept)\n\n        # Initialize widgets contents\n        product_types_widget.addItems(self.get_product_types())\n        product_type = self.get_selected_product_type()\n        self.set_product_type(product_type)\n\n    def get_selected_product(self) -&gt; str:\n        if self.products_widget.currentItem():\n            return self.products_widget.currentItem().text()\n        return \"\"\n\n    def get_selected_product_type(self) -&gt; str:\n        return self.product_types_widget.currentText()\n\n    def get_product_types(self) -&gt; List[str]:\n        \"\"\"return default product types.\n        \"\"\"\n\n        return [\n            \"*\",\n            \"animation\",\n            \"camera\",\n            \"model\",\n            \"pointcache\",\n            \"usd\",\n        ]\n\n    def on_product_type_changed(self, product_type: str):\n        self.set_product_type(product_type)\n\n    def set_product_type(self, product_type: str):\n        self.product_types_widget.setCurrentText(product_type)\n\n        if self.product_types_widget.currentText() != product_type:\n            # Product type does not exist\n            return\n\n        # Populate products list\n        products = self.get_available_products(product_type)\n        self.products_widget.clear()\n        if products:\n            self.products_widget.addItems(products)\n\n    def set_selected_product_name(self, product_name: str):\n        matching_items = self.products_widget.findItems(\n            product_name, QtCore.Qt.MatchFixedString)\n        if matching_items:\n            self.products_widget.setCurrentItem(matching_items[0])\n\n    def get_available_products(self, product_type):\n        if product_type == \"*\":\n            product_type = \"\"\n\n        product_types = [product_type] if product_type else None\n\n        products = ayon_api.get_products(\n            self.project_name,\n            folder_ids=[self.folder_id],\n            product_types=product_types\n        )\n\n        return list(sorted(product[\"name\"] for product in products))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.SelectProductDialog.get_product_types","title":"<code>get_product_types()</code>","text":"<p>return default product types.</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def get_product_types(self) -&gt; List[str]:\n    \"\"\"return default product types.\n    \"\"\"\n\n    return [\n        \"*\",\n        \"animation\",\n        \"camera\",\n        \"model\",\n        \"pointcache\",\n        \"usd\",\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.compute_thumbnail_rect","title":"<code>compute_thumbnail_rect(node)</code>","text":"<p>Compute thumbnail bounding rect based on thumbnail parms</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def compute_thumbnail_rect(node):\n    \"\"\"Compute thumbnail bounding rect based on thumbnail parms\"\"\"\n    offset_x = node.evalParm(\"thumbnail_offsetx\")\n    offset_y = node.evalParm(\"thumbnail_offsety\")\n    width = node.evalParm(\"thumbnail_size\")\n    # todo: compute height from aspect of actual image file.\n    aspect = 0.5625  # for now assume 16:9\n    height = width * aspect\n\n    center = 0.5\n    half_width = (width * .5)\n\n    return hou.BoundingRect(\n        offset_x + center - half_width,\n        offset_y,\n        offset_x + center + half_width,\n        offset_y + height\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.ensure_loader_expression_parm_defaults","title":"<code>ensure_loader_expression_parm_defaults(node)</code>","text":"<p>Reset <code>representation</code> and <code>file</code> parm to defaults.</p> <p>The filepath and representation id parms are updated through expressions, however in older versions they were explicitly set so we ensure that the current value is set to the default value with the expression - otherwise the value will be set to the previously explicitly set overridden value.</p> <p>Silently ignores if the parm does not exist or is already at default.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>OpNode</code> <p>The node to reset.</p> required Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def ensure_loader_expression_parm_defaults(node):\n    \"\"\"Reset `representation` and `file` parm to defaults.\n\n    The filepath and representation id parms are updated through expressions,\n    however in older versions they were explicitly set so we ensure that the\n    current value is set to the default value with the expression - otherwise\n    the value will be set to the previously explicitly set overridden value.\n\n    Silently ignores if the parm does not exist or is already at default.\n\n    Args:\n        node (hou.OpNode): The node to reset.\n\n    \"\"\"\n    for parm_name in [\"representation\", \"file\"]:\n        parm = node.parm(parm_name)\n        if parm is None:\n            continue\n\n        # TODO: For whatever reason this still returns True even if the\n        #  expression does not match the default, so for now we always revert\n        # if parm.isAtDefault(compare_expressions=True):\n        #     continue\n\n        default_expression = parm.parmTemplate().defaultExpression()\n        if not default_expression:\n            continue\n\n        default_expression = default_expression[0]\n\n        try:\n            current_expression = parm.expression()\n            if current_expression == default_expression:\n                continue\n        except hou.OperationFailed:\n            pass\n\n        print(f\"Enforcing {parm.path()} to default value\")\n        locked = parm.isLocked()\n        parm.lock(False)\n        parm.deleteAllKeyframes()\n        parm.revertToDefaults()\n        parm.lock(locked)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.get_available_representations","title":"<code>get_available_representations(node)</code>","text":"<p>Return the representation list for node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to query selected version's representations for.</p> required <p>Returns:</p> Type Description <p>list[str]: representation names for the product version.</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def get_available_representations(node):\n    \"\"\"Return the representation list for node.\n\n    Args:\n        node (hou.Node): Node to query selected version's representations for.\n\n    Returns:\n        list[str]: representation names for the product version.\n    \"\"\"\n\n    project_name = node.evalParm(\"project_name\") or get_current_project_name()\n    folder_path = node.evalParm(\"folder_path\")\n    product_name = node.evalParm(\"product_name\")\n    version = node.evalParm(\"version\")\n\n    if not all([\n        project_name, folder_path, product_name, version\n    ]):\n        return []\n\n    try:\n        version = int(version.strip())\n    except ValueError:\n        load_message_parm = node.parm(\"load_message\")\n        load_message_parm.set(f\"Invalid version format: '{version}'\\n\"\n                              \"Make sure to set a valid version number.\")\n        return\n\n    representation_filter = None\n    filter_parm = node.parm(\"representation_filter\")\n    if filter_parm and not filter_parm.isDisabled() and filter_parm.eval():\n        representation_filter = filter_parm.eval().split(\" \")\n\n    folder_entity = get_folder_by_path(\n        project_name,\n        folder_path=folder_path,\n        fields={\"id\"}\n    )\n    product_entity = get_product_by_name(\n            project_name,\n            product_name=product_name,\n            folder_id=folder_entity[\"id\"],\n            fields={\"id\"})\n    version_entity = get_version_by_name(\n            project_name,\n            version,\n            product_id=product_entity[\"id\"],\n            fields={\"id\"})\n    representations = get_representations(\n            project_name,\n            version_ids={version_entity[\"id\"]},\n            fields={\"name\"},\n            representation_names=representation_filter\n    )\n    representations_names = [n[\"name\"] for n in representations]\n    return representations_names\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.get_available_versions","title":"<code>get_available_versions(node)</code>","text":"<p>Return the versions list for node.</p> <p>The versions are sorted with the latest version first and oldest lower version last.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to query selected products' versions for.</p> required <p>Returns:</p> Type Description <p>list[int]: Version numbers for the product</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def get_available_versions(node):\n    \"\"\"Return the versions list for node.\n\n    The versions are sorted with the latest version first and oldest lower\n    version last.\n\n    Args:\n        node (hou.Node): Node to query selected products' versions for.\n\n    Returns:\n        list[int]: Version numbers for the product\n    \"\"\"\n\n    project_name = node.evalParm(\"project_name\") or get_current_project_name()\n    folder_path = node.evalParm(\"folder_path\")\n    product_name = node.evalParm(\"product_name\")\n\n    if not all([\n        project_name, folder_path, product_name\n    ]):\n        return []\n\n    folder_entity = get_folder_by_path(\n        project_name,\n        folder_path,\n        fields={\"id\"})\n    if not folder_entity:\n        return []\n    product_entity = get_product_by_name(\n        project_name,\n        product_name=product_name,\n        folder_id=folder_entity[\"id\"],\n        fields={\"id\"})\n    if not product_entity:\n        return []\n\n    # TODO: Support hero versions\n    versions = get_versions(\n        project_name,\n        product_ids={product_entity[\"id\"]},\n        fields={\"version\"},\n        hero=False)\n    version_names = [version[\"version\"] for version in versions]\n    version_names.reverse()\n    return version_names\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.get_filepath_from_context","title":"<code>get_filepath_from_context(context)</code>","text":"<p>Format file path for sequence with $F or . Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def get_filepath_from_context(context: dict):\n    \"\"\"Format file path for sequence with $F or &lt;UDIM&gt;.\"\"\"\n    # The path is either a single file or sequence in a folder.\n    # Format frame as $F and udim as &lt;UDIM&gt;\n    representation = context[\"representation\"]\n    frame = representation[\"context\"].get(\"frame\")\n    udim = representation[\"context\"].get(\"udim\")\n    if frame is not None or udim is not None:\n        template: str = representation[\"attrib\"][\"template\"]\n        repre_context: dict = representation[\"context\"]\n        if udim is not None:\n            repre_context[\"udim\"] = \"&lt;UDIM&gt;\"\n            template = _remove_format_spec(template, \"udim\")\n        if frame is not None:\n            # Substitute frame number in sequence with $F with padding\n            repre_context[\"frame\"] = \"$F{}\".format(len(frame))  # e.g. $F4\n            template = _remove_format_spec(template, \"frame\")\n\n        project_name: str = repre_context[\"project\"][\"name\"]\n        anatomy = Anatomy(project_name, project_entity=context[\"project\"])\n        repre_context[\"root\"] = anatomy.roots\n        path = StringTemplate(template).format(repre_context)\n    else:\n        path = get_representation_path_from_context(context)\n\n    # Load fails on UNC paths with backslashes and also\n    # fails to resolve @sourcename var with backslashed\n    # paths correctly. So we force forward slashes\n    return os.path.normpath(path).replace(\"\\\\\", \"/\")\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.get_representation_id","title":"<code>get_representation_id(project_name, folder_path, product_name, version, representation_name)</code>","text":"<p>Get representation id.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name</p> required <code>folder_path</code> <code>str</code> <p>Folder name</p> required <code>product_name</code> <code>str</code> <p>Product name</p> required <code>version</code> <code>str</code> <p>Version name as string</p> required <code>representation_name</code> <code>str</code> <p>Representation name</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Representation id or None if not found.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the entity could not be resolved with input values.</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def get_representation_id(\n        project_name,\n        folder_path,\n        product_name,\n        version,\n        representation_name,\n):\n    \"\"\"Get representation id.\n\n    Args:\n        project_name (str): Project name\n        folder_path (str): Folder name\n        product_name (str): Product name\n        version (str): Version name as string\n        representation_name (str): Representation name\n\n    Returns:\n        str: Representation id or None if not found.\n\n    Raises:\n        ValueError: If the entity could not be resolved with input values.\n\n    \"\"\"\n    if not all([\n        project_name, folder_path, product_name, version, representation_name\n    ]):\n        labels = {\n            \"project\": project_name,\n            \"folder\": folder_path,\n            \"product\": product_name,\n            \"version\": version,\n            \"representation\": representation_name\n        }\n        missing = \", \".join(key for key, value in labels.items() if not value)\n        raise ValueError(f\"Load info incomplete. Found empty: {missing}\")\n\n    try:\n        version = int(version.strip())\n    except ValueError:\n        raise ValueError(\n            f\"Invalid version format: '{version}'\\n\"\n            \"Make sure to set a valid version number.\")\n\n    folder_entity = get_folder_by_path(project_name,\n                                       folder_path=folder_path,\n                                       fields={\"id\"})\n    if not folder_entity:\n        # This may be due to the project not existing - so let's validate\n        # that first\n        if not get_project(project_name):\n            raise ValueError(f\"Project not found: '{project_name}'\")\n        raise ValueError(f\"Folder not found: '{folder_path}'\")\n\n    product_entity = get_product_by_name(\n        project_name,\n        product_name=product_name,\n        folder_id=folder_entity[\"id\"],\n        fields={\"id\"})\n    if not product_entity:\n        raise ValueError(f\"Product not found: '{product_name}'\")\n\n    version_entity = get_version_by_name(\n        project_name,\n        version,\n        product_id=product_entity[\"id\"],\n        fields={\"id\"})\n    if not version_entity:\n        raise ValueError(f\"Version not found: '{version}'\")\n\n    representation_entity = get_representation_by_name(\n        project_name,\n        representation_name,\n        version_id=version_entity[\"id\"],\n        fields={\"id\"})\n    if not representation_entity:\n        raise ValueError(f\"Representation not found: '{representation_name}'.\")\n    return representation_entity[\"id\"]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.get_session_cache","title":"<code>get_session_cache()</code>","text":"<p>Get a persistent <code>hou.session.ayon_cache</code> dict</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def get_session_cache() -&gt; dict:\n    \"\"\"Get a persistent `hou.session.ayon_cache` dict\"\"\"\n    cache = getattr(hou.session, \"ayon_cache\", None)\n    if cache is None:\n        hou.session.ayon_cache = cache = {}\n    return cache\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.is_valid_uuid","title":"<code>is_valid_uuid(value)</code>","text":"<p>Return whether value is a valid UUID</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def is_valid_uuid(value) -&gt; bool:\n    \"\"\"Return whether value is a valid UUID\"\"\"\n    try:\n        uuid.UUID(value)\n    except ValueError:\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.keep_background_images_linked","title":"<code>keep_background_images_linked(node, old_name)</code>","text":"<p>Reconnect background images to node from old name.</p> <p>Used as callback on node name changes to keep thumbnails linked.</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def keep_background_images_linked(node, old_name):\n    \"\"\"Reconnect background images to node from old name.\n\n     Used as callback on node name changes to keep thumbnails linked.\"\"\"\n    from ayon_houdini.api.lib import (\n        get_background_images,\n        set_background_images\n    )\n\n    parent = node.parent()\n    images = get_background_images(parent)\n    if not images:\n        return\n\n    changes = False\n    old_path = f\"{node.parent().path()}/{old_name}\"\n    for image in images:\n        if image.relativeToPath() == old_path:\n            image.setRelativeToPath(node.path())\n            changes = True\n\n    if changes:\n        set_background_images(parent, images)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.on_flag_changed","title":"<code>on_flag_changed(node, **kwargs)</code>","text":"<p>On node flag changed callback.</p> <p>Updates the brightness of attached thumbnails</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def on_flag_changed(node, **kwargs):\n    \"\"\"On node flag changed callback.\n\n    Updates the brightness of attached thumbnails\n    \"\"\"\n    # Showing thumbnail is disabled so can return early since\n    # there should be no thumbnail to update.\n    if not node.evalParm('show_thumbnail'):\n        return\n\n    # Update node thumbnails brightness with the\n    # bypass state of the node.\n    parent = node.parent()\n    images = lib.get_background_images(parent)\n    if not images:\n        return\n\n    # This may trigger on a node that can't be bypassed, like `ObjNode` so\n    # consider those never bypassed\n    is_bypassed = hasattr(node, \"isBypassed\") and node.isBypassed()\n    brightness = 0.3 if is_bypassed else 1.0\n    has_changes = False\n    node_path = node.path()\n    for image in images:\n        if image.relativeToPath() == node_path:\n            image.setBrightness(brightness)\n            has_changes = True\n\n    if has_changes:\n        lib.set_background_images(parent, images)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.on_thumbnail_show_changed","title":"<code>on_thumbnail_show_changed(node)</code>","text":"<p>Callback on thumbnail show parm changed</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def on_thumbnail_show_changed(node):\n    \"\"\"Callback on thumbnail show parm changed\"\"\"\n    update_thumbnail(node)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.on_thumbnail_size_changed","title":"<code>on_thumbnail_size_changed(node)</code>","text":"<p>Callback on thumbnail offset or size parms changed</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def on_thumbnail_size_changed(node):\n    \"\"\"Callback on thumbnail offset or size parms changed\"\"\"\n    thumbnail = lib.get_node_thumbnail(node)\n    if thumbnail:\n        rect = compute_thumbnail_rect(node)\n        thumbnail.setRect(rect)\n        lib.set_node_thumbnail(node, thumbnail)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.select_folder_path","title":"<code>select_folder_path(node)</code>","text":"<p>Show dialog to select folder path.</p> <p>When triggered it opens a dialog that shows the available folder paths within a given project.</p> Note <p>This function should be refactored. It currently shows the available   folder paths within the current project only.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>OpNode</code> <p>The HDA node.</p> required Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def select_folder_path(node):\n    \"\"\"Show dialog to select folder path.\n\n    When triggered it opens a dialog that shows the available\n    folder paths within a given project.\n\n    Note:\n        This function should be refactored.\n        It currently shows the available\n          folder paths within the current project only.\n\n    Args:\n        node (hou.OpNode): The HDA node.\n    \"\"\"\n    cursor_pos = QtGui.QCursor.pos()\n\n    main_window = lib.get_main_window()\n\n    project_name = node.evalParm(\"project_name\")\n    folder_path = node.evalParm(\"folder_path\")\n\n    dialog = SelectFolderPathDialog(parent=main_window)\n    dialog.set_project_name(project_name)\n    if folder_path:\n        # We add a small delay to the setting of the selected folder\n        # because the folder widget's set project logic itself also runs\n        # with a bit of a delay, and unfortunately otherwise the project\n        # has not been selected yet and thus selection does not work.\n        def _select_folder_path():\n            dialog.folder_widget.set_selected_folder_path(folder_path)\n        QtCore.QTimer.singleShot(100, _select_folder_path)\n\n    dialog.setStyleSheet(load_stylesheet())\n\n    # Make it appear like a pop-up near cursor\n    dialog.resize(300, 600)\n    dialog.setWindowFlags(QtCore.Qt.Popup)\n    pos = dialog.mapToGlobal(cursor_pos - QtCore.QPoint(300, 0))\n    dialog.move(pos)\n\n    result = dialog.exec_()\n    if result != QtWidgets.QDialog.Accepted:\n        return\n\n    # Set project\n    selected_project_name = dialog.get_selected_project_name()\n    if selected_project_name == get_current_project_name():\n        selected_project_name = '$AYON_PROJECT_NAME'\n\n    project_parm = node.parm(\"project_name\")\n    project_parm.set(selected_project_name)\n    project_parm.pressButton()  # allow any callbacks to trigger\n\n    # Set folder path\n    selected_folder_path = dialog.get_selected_folder_path()\n    if not selected_folder_path:\n        # Do nothing if user accepted with nothing selected\n        return\n\n    if selected_folder_path == get_current_folder_path():\n        selected_folder_path = '$AYON_FOLDER_PATH'\n\n    folder_parm = node.parm(\"folder_path\")\n    folder_parm.set(selected_folder_path)\n    folder_parm.pressButton()  # allow any callbacks to trigger\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.select_product_name","title":"<code>select_product_name(node)</code>","text":"<p>Show a modal pop-up dialog to allow user to select a product name under the current folder entity as defined on the node's parameters.</p> <p>Applies the chosen value to the <code>product_name</code> parm on the node.</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def select_product_name(node):\n    \"\"\"Show a modal pop-up dialog to allow user to select a product name\n    under the current folder entity as defined on the node's parameters.\n\n    Applies the chosen value to the `product_name` parm on the node.\"\"\"\n\n    cursor_pos = QtGui.QCursor.pos()\n\n    project_name = node.evalParm(\"project_name\")\n    folder_path = node.evalParm(\"folder_path\")\n    product_parm = node.parm(\"product_name\")\n\n    folder_entity = ayon_api.get_folder_by_path(project_name,\n                                                folder_path,\n                                                fields={\"id\"})\n    if not folder_entity:\n        return\n\n    dialog = SelectProductDialog(\n        project_name,\n        folder_entity[\"id\"],\n        parent=lib.get_main_window()\n    )\n    dialog.set_selected_product_name(product_parm.eval())\n\n    dialog.resize(300, 600)\n    dialog.setWindowFlags(QtCore.Qt.Popup)\n    pos = dialog.mapToGlobal(cursor_pos - QtCore.QPoint(300, 0))\n    dialog.move(pos)\n    result = dialog.exec_()\n\n    if result != QtWidgets.QDialog.Accepted:\n        return\n    selected_product = dialog.get_selected_product()\n\n    if selected_product:\n        product_parm.set(selected_product)\n        product_parm.pressButton()  # allow any callbacks to trigger\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.set_node_representation_from_context","title":"<code>set_node_representation_from_context(node, context, ensure_expression_defaults=True)</code>","text":"<p>Update project, folder, product, version, representation name parms.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to update</p> required <code>context</code> <code>dict</code> <p>Context of representation</p> required <code>ensure_expression_defaults</code> <code>bool</code> <p>Ensure expression defaults.</p> <code>True</code> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def set_node_representation_from_context(\n        node,\n        context,\n        ensure_expression_defaults=True\n):\n    \"\"\"Update project, folder, product, version, representation name parms.\n\n     Arguments:\n         node (hou.Node): Node to update\n         context (dict): Context of representation\n         ensure_expression_defaults (bool): Ensure expression defaults.\n\n     \"\"\"\n    # TODO: Avoid 'duplicate' taking over the expression if originally\n    #       it was $OS and by duplicating, e.g. the `folder` does not exist\n    #       anymore since it is now `hero1` instead of `hero`\n    # TODO: Support hero versions\n    version = str(context[\"version\"][\"version\"])\n\n    # We only set the values if the value does not match the currently\n    # evaluated result of the other parms, so that if the project name\n    # value was dynamically set by the user with an expression or alike\n    # then if it still matches the value of the current representation id\n    # we preserve it. In essence, only update the value if the current\n    # *evaluated* value of the parm differs.\n    parms = {\n        \"project_name\": context[\"project\"][\"name\"],\n        \"folder_path\": context[\"folder\"][\"path\"],\n        \"product_name\": context[\"product\"][\"name\"],\n        \"version\": version,\n        \"representation_name\": context[\"representation\"][\"name\"],\n    }\n    parms = {key: value for key, value in parms.items()\n             if node.evalParm(key) != value}\n    node.setParms(parms)\n\n    if ensure_expression_defaults:\n        ensure_loader_expression_parm_defaults(node)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.set_node_thumbnail","title":"<code>set_node_thumbnail(node, thumbnail)</code>","text":"<p>Update node thumbnail to thumbnail</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def set_node_thumbnail(node, thumbnail: str):\n    \"\"\"Update node thumbnail to thumbnail\"\"\"\n    if thumbnail is None:\n        lib.set_node_thumbnail(node, None)\n\n    rect = compute_thumbnail_rect(node)\n    lib.set_node_thumbnail(node, thumbnail, rect)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.set_to_latest_version","title":"<code>set_to_latest_version(node)</code>","text":"<p>Callback on product name change</p> <p>Refresh version and representation parameters value by setting their value to the latest version and representation of the selected product.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>OpNode</code> <p>The HDA node.</p> required Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def set_to_latest_version(node):\n    \"\"\"Callback on product name change\n\n    Refresh version and representation parameters value by setting\n    their value to the latest version and representation of\n    the selected product.\n\n    Args:\n        node (hou.OpNode): The HDA node.\n    \"\"\"\n\n    versions = get_available_versions(node)\n    if versions:\n        node.parm(\"version\").set(str(versions[0]))\n\n    representations = get_available_representations(node)\n    if representations:\n        node.parm(\"representation_name\").set(representations[0])\n    else:\n        node.parm(\"representation_name\").set(\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/hda_utils.html#client.ayon_houdini.api.hda_utils.setup_flag_changed_callback","title":"<code>setup_flag_changed_callback(node)</code>","text":"<p>Register flag changed callback (for thumbnail brightness)</p> Source code in <code>client/ayon_houdini/api/hda_utils.py</code> <pre><code>def setup_flag_changed_callback(node):\n    \"\"\"Register flag changed callback (for thumbnail brightness)\"\"\"\n    node.addEventCallback(\n        (hou.nodeEventType.FlagChanged,),\n        on_flag_changed\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.add_self_publish_button","title":"<code>add_self_publish_button(node)</code>","text":"<p>Adds a self publish button to the rop node.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def add_self_publish_button(node):\n    \"\"\"Adds a self publish button to the rop node.\"\"\"\n\n    label = os.environ.get(\"AYON_MENU_LABEL\") or \"AYON\"\n\n    button_parm = hou.ButtonParmTemplate(\n        \"ayon_self_publish\",\n        \"{} Publish\".format(label),\n        script_callback=\"from ayon_houdini.api.lib import \"\n                        \"self_publish; self_publish()\",\n        script_callback_language=hou.scriptLanguage.Python,\n        join_with_next=True\n    )\n\n    template = node.parmTemplateGroup()\n    template.insertBefore((0,), button_parm)\n    node.setParmTemplateGroup(template)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.connect_file_parm_to_loader","title":"<code>connect_file_parm_to_loader(file_parm)</code>","text":"<p>Connect the given file parm to a generic loader. If the parm is already connected to a generic loader node, go to that node.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def connect_file_parm_to_loader(file_parm: hou.Parm):\n    \"\"\"Connect the given file parm to a generic loader.\n    If the parm is already connected to a generic loader node, go to that node.\n    \"\"\"\n\n    from .pipeline import get_or_create_avalon_container\n\n    referenced_parm = file_parm.getReferencedParm()\n\n    # If the parm has reference\n    if file_parm != referenced_parm:\n        referenced_node = referenced_parm.getReferencedParm().node()\n        if referenced_node.type().name() == \"ayon::generic_loader::1.0\":\n            show_node_parmeditor(referenced_node)\n            return\n\n    # Create a generic loader node and reference its file parm\n    main_container = get_or_create_avalon_container()\n\n    node_name = f\"{file_parm.node().name()}_{file_parm.name()}_loader\"\n    load_node = main_container.createNode(\"ayon::generic_loader\",\n                                          node_name=node_name)\n    load_node.moveToGoodPosition()\n\n    # Set relative reference via hscript. This avoids the issues of\n    # `setExpression` e.g. having a keyframe.\n    relative_path = file_parm.node().relativePathTo(load_node)\n    expression = rf'chs\\(\\\"{relative_path}/file\\\"\\)'  # noqa\n    hou.hscript(\n        'opparm -r'\n        f' {file_parm.node().path()} {file_parm.name()} \\\\`{expression}\\\\`'\n    )\n    show_node_parmeditor(load_node)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.context_options","title":"<code>context_options(context_options)</code>","text":"<p>Context manager to set Solaris Context Options.</p> <p>The original context options are restored after the context exits.</p> <p>Parameters:</p> Name Type Description Default <code>context_options</code> <code>dict[str, str | float]</code> <p>The Solaris Context Options to set.</p> required <p>Yields:</p> Type Description <p>dict[str, str | float]: The original context options that were changed.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>@contextmanager\ndef context_options(context_options: \"dict[str, str | float]\"):\n    \"\"\"Context manager to set Solaris Context Options.\n\n    The original context options are restored after the context exits.\n\n    Arguments:\n        context_options (dict[str, str | float]):\n            The Solaris Context Options to set.\n\n    Yields:\n        dict[str, str | float]: The original context options that were changed.\n\n    \"\"\"\n    # Get the original context options and their values\n    original_context_options: \"dict[str, str | float]\" = {}\n    for name in hou.contextOptionNames():\n        original_context_options[name] = hou.contextOption(name)\n\n    try:\n        # Override the context options\n        for name, value in context_options.items():\n            hou.setContextOption(name, value)\n        yield original_context_options\n    finally:\n        # Restore original context options that we changed\n        for name in context_options:\n            if name in original_context_options:\n                hou.setContextOption(name, original_context_options[name])\n            else:\n                # Clear context option\n                hou.setContextOption(name, None)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.find_active_network","title":"<code>find_active_network(category, default)</code>","text":"<p>Find the first active network editor in the UI.</p> <p>If no active network editor pane is found at the given category then the <code>default</code> path will be used as fallback.</p> <p>For example, to find an active LOPs network:</p> <p>network = find_active_network( ...     category=hou.lopNodeTypeCategory(), ...     fallback=\"/stage\" ... ) hou.Node(\"/stage/lopnet1\")</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>NodeTypeCategory</code> <p>The node network category type.</p> required <code>default</code> <code>str</code> <p>The default path to fallback to if no active pane is found with the given category, e.g. \"/obj\"</p> required <p>Returns:</p> Type Description <p>hou.Node: The node network to return.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def find_active_network(category, default):\n    \"\"\"Find the first active network editor in the UI.\n\n    If no active network editor pane is found at the given category then the\n    `default` path will be used as fallback.\n\n    For example, to find an active LOPs network:\n    &gt;&gt;&gt; network = find_active_network(\n    ...     category=hou.lopNodeTypeCategory(),\n    ...     fallback=\"/stage\"\n    ... )\n    hou.Node(\"/stage/lopnet1\")\n\n    Arguments:\n        category (hou.NodeTypeCategory): The node network category type.\n        default (str): The default path to fallback to if no active pane\n            is found with the given category, e.g. \"/obj\"\n\n    Returns:\n        hou.Node: The node network to return.\n\n    \"\"\"\n    # Find network editors that are current tab of given category\n    index = 0\n    while True:\n        pane = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor, index)\n        if pane is None:\n            break\n\n        index += 1\n        if not pane.isCurrentTab():\n            continue\n\n        pwd = pane.pwd()\n        if pwd.type().category() != category:\n            continue\n\n        if not pwd.isEditable():\n            continue\n\n        return pwd\n\n    # Default to the fallback if no valid candidate was found\n    return hou.node(default)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.find_rop_input_dependencies","title":"<code>find_rop_input_dependencies(input_tuple)</code>","text":"<p>Self publish from ROP nodes.</p> <p>Returns:</p> Type Description <p>list of the RopNode.path() that can be found inside</p> <p>the input tuple.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def find_rop_input_dependencies(input_tuple):\n    \"\"\"Self publish from ROP nodes.\n\n    Arguments:\n        tuple (hou.RopNode.inputDependencies) which can be a nested tuples\n        represents the input dependencies of the ROP node, consisting of ROPs,\n        and the frames that need to be be rendered prior to rendering the ROP.\n\n    Returns:\n        list of the RopNode.path() that can be found inside\n        the input tuple.\n    \"\"\"\n\n    out_list = []\n    if isinstance(input_tuple[0], hou.RopNode):\n        return input_tuple[0].path()\n\n    if isinstance(input_tuple[0], tuple):\n        for item in input_tuple:\n            out_list.append(find_rop_input_dependencies(item))\n\n    return out_list\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.format_as_collections","title":"<code>format_as_collections(files, pattern='{head}{padding}{tail} [{ranges}]')</code>","text":"<p>Return list of files as formatted sequence collections.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def format_as_collections(\n    files: list[str],\n    pattern: str = \"{head}{padding}{tail} [{ranges}]\"\n) -&gt; list[str]:\n    \"\"\"Return list of files as formatted sequence collections.\"\"\"\n\n    collections, remainder = clique.assemble(files)\n    result = [collection.format(pattern) for collection in collections]\n    result.extend(remainder)\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_background_images","title":"<code>get_background_images(node, raw=False)</code>","text":"<p>\"Return background images defined inside node.</p> <p>Similar to <code>nodegraphutils.saveBackgroundImages</code> but this method also allows to retrieve the data as JSON encodable data instead of <code>hou.NetworkImage</code> instances when using <code>raw=True</code></p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_background_images(node, raw=False):\n    \"\"\"\"Return background images defined inside node.\n\n    Similar to `nodegraphutils.saveBackgroundImages` but this method also\n    allows to retrieve the data as JSON encodable data instead of\n    `hou.NetworkImage` instances when using `raw=True`\n    \"\"\"\n\n    def _parse(image_data):\n        image = hou.NetworkImage(image_data[\"path\"],\n                                 hou.BoundingRect(*image_data[\"rect\"]))\n        if \"relativetopath\" in image_data:\n            image.setRelativeToPath(image_data[\"relativetopath\"])\n        if \"brightness\" in image_data:\n            image.setBrightness(image_data[\"brightness\"])\n        return image\n\n    data = node.userData(\"backgroundimages\")\n    if not data:\n        return []\n\n    try:\n        images = json.loads(data)\n    except json.decoder.JSONDecodeError:\n        images = []\n\n    if not raw:\n        images = [_parse(_data) for _data in images]\n    return images\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_camera_from_container","title":"<code>get_camera_from_container(container)</code>","text":"<p>Get camera from container node.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_camera_from_container(container):\n    \"\"\"Get camera from container node. \"\"\"\n\n    cameras = container.recursiveGlob(\n        \"*\",\n        filter=hou.nodeTypeFilter.ObjCamera,\n        include_subnets=False\n    )\n\n    assert len(cameras) == 1, \"Camera instance must have only one camera\"\n    return cameras[0]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_color_management_preferences","title":"<code>get_color_management_preferences()</code>","text":"<p>Get default OCIO preferences</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_color_management_preferences():\n    \"\"\"Get default OCIO preferences\"\"\"\n\n    preferences = {\n        \"config\": hou.Color.ocio_configPath(),\n        \"display\": hou.Color.ocio_defaultDisplay(),\n        \"view\": hou.Color.ocio_defaultView()\n    }\n\n    # Note: For whatever reason they are cases where `view` may be an empty\n    #  string even though a valid default display is set where `PyOpenColorIO`\n    #  does correctly return the values.\n    # Workaround to get the correct default view\n    if preferences[\"config\"] and not preferences[\"view\"]:\n        log.debug(\n            \"Houdini `hou.Color.ocio_defaultView()` returned empty value.\"\n            \" Falling back to `PyOpenColorIO` to get the default view.\")\n        try:\n            import PyOpenColorIO\n        except ImportError:\n            log.warning(\n                \"Unable to workaround empty return value of \"\n                \"`hou.Color.ocio_defaultView()` because `PyOpenColorIO` is \"\n                \"not available.\")\n            return preferences\n\n        config_path = preferences[\"config\"]\n        config = PyOpenColorIO.Config.CreateFromFile(config_path)\n        display = config.getDefaultDisplay()\n        assert display == preferences[\"display\"], \\\n            \"Houdini default OCIO display must match config default display\"\n        view = config.getDefaultView(display)\n        preferences[\"display\"] = display\n        preferences[\"view\"] = view\n\n    return preferences\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_context_var_changes","title":"<code>get_context_var_changes()</code>","text":"<p>get context var changes.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_context_var_changes():\n    \"\"\"get context var changes.\"\"\"\n\n    houdini_vars_to_update = {}\n\n    project_settings = get_current_project_settings()\n    houdini_vars_settings = \\\n        project_settings[\"houdini\"][\"general\"][\"update_houdini_var_context\"]\n\n    if not houdini_vars_settings[\"enabled\"]:\n        return houdini_vars_to_update\n\n    houdini_vars = houdini_vars_settings[\"houdini_vars\"]\n\n    # No vars specified - nothing to do\n    if not houdini_vars:\n        return houdini_vars_to_update\n\n    # Get Template data\n    template_data = get_current_context_template_data_with_entity_attrs()\n\n    # Set Houdini Vars\n    for item in houdini_vars:\n        # For consistency reasons we always force all vars to be uppercase\n        # Also remove any leading, and trailing whitespaces.\n        var = item[\"var\"].strip().upper()\n\n        # get and resolve template in value\n        item_value = StringTemplate.format_template(\n            item[\"value\"],\n            template_data\n        )\n\n        if var == \"JOB\" and item_value == \"\":\n            # sync $JOB to $HIP if $JOB is empty\n            item_value = os.environ[\"HIP\"]\n\n        if item[\"is_directory\"]:\n            item_value = item_value.replace(\"\\\\\", \"/\")\n\n        current_value = hou.hscript(\"echo -n `${}`\".format(var))[0]\n\n        if current_value != item_value:\n            houdini_vars_to_update[var] = (\n                current_value, item_value, item[\"is_directory\"]\n            )\n\n    return houdini_vars_to_update\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_current_context_template_data_with_entity_attrs","title":"<code>get_current_context_template_data_with_entity_attrs()</code>","text":"<p>Return template data including current context folder and task attribs.</p> Output contains <ul> <li>Regular template data from <code>get_template_data</code></li> <li>'folderAttributes' key with folder attribute values.</li> <li>'taskAttributes' key with task attribute values.</li> </ul> <p>Returns:</p> Type Description <p>dict[str, Any]: Template data to fill templates.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_current_context_template_data_with_entity_attrs():\n    \"\"\"Return template data including current context folder and task attribs.\n\n    Output contains:\n      - Regular template data from `get_template_data`\n      - 'folderAttributes' key with folder attribute values.\n      - 'taskAttributes' key with task attribute values.\n\n    Returns:\n         dict[str, Any]: Template data to fill templates.\n\n    \"\"\"\n    context = get_current_context()\n    project_name = context[\"project_name\"]\n    folder_path = context[\"folder_path\"]\n    task_name = context[\"task_name\"]\n    host_name = get_current_host_name()\n\n    project_entity = ayon_api.get_project(project_name)\n    anatomy = Anatomy(project_name, project_entity=project_entity)\n    folder_entity = ayon_api.get_folder_by_path(project_name, folder_path)\n    task_entity = ayon_api.get_task_by_name(\n        project_name, folder_entity[\"id\"], task_name\n    )\n\n    # get context specific vars\n    folder_attributes = folder_entity[\"attrib\"]\n    task_attributes = task_entity[\"attrib\"]\n\n    # compute `frameStartHandle` and `frameEndHandle`\n    for attributes in [folder_attributes, task_attributes]:\n        frame_start = attributes.get(\"frameStart\")\n        frame_end = attributes.get(\"frameEnd\")\n        handle_start = attributes.get(\"handleStart\")\n        handle_end = attributes.get(\"handleEnd\")\n        if frame_start is not None and handle_start is not None:\n            attributes[\"frameStartHandle\"] = frame_start - handle_start\n        if frame_end is not None and handle_end is not None:\n            attributes[\"frameEndHandle\"] = frame_end + handle_end\n\n    template_data = get_template_data(\n        project_entity, folder_entity, task_entity, host_name\n    )\n    template_data[\"root\"] = anatomy.roots\n    template_data[\"folderAttributes\"] = folder_attributes\n    template_data[\"taskAttributes\"] = task_attributes\n\n    return template_data\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_entity_fps","title":"<code>get_entity_fps(entity=None)</code>","text":"<p>Return current task fps or fps from an entity.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_entity_fps(entity=None):\n    \"\"\"Return current task fps or fps from an entity.\"\"\"\n\n    if entity is None:\n        entity = get_current_task_entity(fields=[\"attrib.fps\"])\n    return entity[\"attrib\"][\"fps\"]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_frame_data","title":"<code>get_frame_data(node, log=None)</code>","text":"<p>Get the frame data: <code>frameStartHandle</code>, <code>frameEndHandle</code> and <code>byFrameStep</code>.</p> <p>This function uses Houdini node's <code>trange</code>, <code>t1,</code>t2<code>and</code>t3` parameters as the source of truth for the full inclusive frame range to render, as such these are considered as the frame range including the handles.</p> <p>The non-inclusive frame start and frame end without handles can be computed by subtracting the handles from the inclusive frame range.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>ROP node to retrieve frame range from, the frame range is assumed to be the frame range including the start and end handles.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>frame data for <code>frameStartHandle</code>, <code>frameEndHandle</code> and <code>byFrameStep</code>.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_frame_data(node, log=None):\n    \"\"\"Get the frame data: `frameStartHandle`, `frameEndHandle`\n    and `byFrameStep`.\n\n    This function uses Houdini node's `trange`, `t1, `t2` and `t3`\n    parameters as the source of truth for the full inclusive frame\n    range to render, as such these are considered as the frame\n    range including the handles.\n\n    The non-inclusive frame start and frame end without handles\n    can be computed by subtracting the handles from the inclusive\n    frame range.\n\n    Args:\n        node (hou.Node): ROP node to retrieve frame range from,\n            the frame range is assumed to be the frame range\n            *including* the start and end handles.\n\n    Returns:\n        dict: frame data for `frameStartHandle`, `frameEndHandle`\n            and `byFrameStep`.\n\n    \"\"\"\n\n    if log is None:\n        log = self.log\n\n    data = {}\n\n    if node.parm(\"trange\") is None:\n        log.debug(\n            \"Node has no 'trange' parameter: {}\".format(node.path())\n        )\n        return data\n\n    if node.evalParm(\"trange\") == 0:\n        data[\"frameStartHandle\"] = hou.intFrame()\n        data[\"frameEndHandle\"] = hou.intFrame()\n        data[\"byFrameStep\"] = 1.0\n\n        log.info(\n            \"Node '{}' has 'Render current frame' set.\\n\"\n            \"Task handles are ignored.\\n\"\n            \"frameStart and frameEnd are set to the \"\n            \"current frame.\".format(node.path())\n        )\n    else:\n        data[\"frameStartHandle\"] = int(node.evalParm(\"f1\"))\n        data[\"frameEndHandle\"] = int(node.evalParm(\"f2\"))\n        data[\"byFrameStep\"] = node.evalParm(\"f3\")\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_lops_rop_context_options","title":"<code>get_lops_rop_context_options(ropnode)</code>","text":"<p>Return the Context Options that a LOP ROP node uses.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_lops_rop_context_options(\n        ropnode: hou.RopNode) -&gt; \"dict[str, str | float]\":\n    \"\"\"Return the Context Options that a LOP ROP node uses.\"\"\"\n    rop_context_options: \"dict[str, str | float]\" = {}\n\n    # Always set @ropname and @roppath\n    # See: https://www.sidefx.com/docs/houdini/hom/hou/isAutoContextOption.html\n    rop_context_options[\"ropname\"] = ropnode.name()\n    rop_context_options[\"roppath\"] = ropnode.path()\n\n    # Set @ropcook, @ropstart, @ropend and @ropinc if setropcook is enabled\n    setropcook_parm = ropnode.parm(\"setropcook\")\n    if setropcook_parm:\n        setropcook = setropcook_parm.eval()\n        if setropcook:\n            # TODO: Support \"Render Frame Range from Stage\" correctly\n            # TODO: Support passing in the start, end, and increment values\n            #  for the cases where this may need to consider overridden\n            #  frame ranges for `RopNode.render()` calls.\n            trange = ropnode.evalParm(\"trange\")\n            if trange == 0:\n                # Current frame\n                start: float = hou.frame()\n                end: float = start\n                inc: float = 1.0\n            elif trange in {1, 2}:\n                # Frame range\n                start: float = ropnode.evalParm(\"f1\")\n                end: float = ropnode.evalParm(\"f2\")\n                inc: float = ropnode.evalParm(\"f3\")\n            else:\n                raise ValueError(\"Unsupported trange value: %s\" % trange)\n            rop_context_options[\"ropcook\"] = 1.0\n            rop_context_options[\"ropstart\"] = start\n            rop_context_options[\"ropend\"] = end\n            rop_context_options[\"ropinc\"] = inc\n\n    # Get explicit context options set on the ROP node.\n    num = ropnode.evalParm(\"optioncount\")\n    for i in range(1, num + 1):\n        # Ignore disabled options\n        if not ropnode.evalParm(f\"optionenable{i}\"):\n            continue\n\n        name: str = ropnode.evalParm(f\"optionname{i}\")\n        option_type: str = ropnode.evalParm(f\"optiontype{i}\")\n        if option_type == \"string\":\n            value: str = ropnode.evalParm(f\"optionstrvalue{i}\")\n        elif option_type == \"float\":\n            value: float = ropnode.evalParm(f\"optionfloatvalue{i}\")\n        else:\n            raise ValueError(f\"Unsupported option type: {option_type}\")\n        rop_context_options[name] = value\n\n    return rop_context_options\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_main_window","title":"<code>get_main_window()</code>","text":"<p>Acquire Houdini's main window</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_main_window():\n    \"\"\"Acquire Houdini's main window\"\"\"\n    if self._parent is None:\n        self._parent = hou.ui.mainQtWindow()\n    return self._parent\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_node_thumbnail","title":"<code>get_node_thumbnail(node, first_only=True)</code>","text":"<p>Return node thumbnails.</p> <p>Return network background images that are linked to the given node. By default, only returns the first one found, unless <code>first_only</code> is False.</p> <p>Returns:</p> Type Description <p>Union[hou.NetworkImage, List[hou.NetworkImage]]: Connected network images</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_node_thumbnail(node, first_only=True):\n    \"\"\"Return node thumbnails.\n\n    Return network background images that are linked to the given node.\n    By default, only returns the first one found, unless `first_only` is False.\n\n    Returns:\n        Union[hou.NetworkImage, List[hou.NetworkImage]]:\n            Connected network images\n\n    \"\"\"\n    parent = node.parent()\n    images = get_background_images(parent)\n    node_path = node.path()\n\n    def is_attached_to_node(image):\n        return image.relativeToPath() == node_path\n\n    attached_images = filter(is_attached_to_node, images)\n\n    # Find first existing image attached to node\n    if first_only:\n        return next(attached_images, None)\n    else:\n        return attached_images\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_obj_node_output","title":"<code>get_obj_node_output(obj_node)</code>","text":"<p>Find output node.</p> <p>If the node has any output node return the output node with the minimum <code>outputidx</code>. When no output is present return the node with the display flag set. If no output node is detected then None is returned.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node to retrieve a single the output node for.</p> required <p>Returns:</p> Type Description <p>Optional[hou.Node]: The child output node.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_obj_node_output(obj_node):\n    \"\"\"Find output node.\n\n    If the node has any output node return the\n    output node with the minimum `outputidx`.\n    When no output is present return the node\n    with the display flag set. If no output node is\n    detected then None is returned.\n\n    Arguments:\n        node (hou.Node): The node to retrieve a single\n            the output node for.\n\n    Returns:\n        Optional[hou.Node]: The child output node.\n\n    \"\"\"\n\n    outputs = obj_node.subnetOutputs()\n    if not outputs:\n        return\n\n    elif len(outputs) == 1:\n        return outputs[0]\n\n    else:\n        return min(outputs,\n                   key=lambda node: node.evalParm('outputidx'))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_output_children","title":"<code>get_output_children(output_node, include_sops=True)</code>","text":"<p>Recursively return a list of all output nodes contained in this node including this node.</p> <p>It works in a similar manner to output_node.allNodes().</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_output_children(output_node, include_sops=True):\n    \"\"\"Recursively return a list of all output nodes\n    contained in this node including this node.\n\n    It works in a similar manner to output_node.allNodes().\n    \"\"\"\n    out_list = [output_node]\n\n    if output_node.childTypeCategory() == hou.objNodeTypeCategory():\n        for child in output_node.children():\n            out_list += get_output_children(child, include_sops=include_sops)\n\n    elif include_sops and \\\n            output_node.childTypeCategory() == hou.sopNodeTypeCategory():\n        out = get_obj_node_output(output_node)\n        if out:\n            out_list += [out]\n\n    return out_list\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_output_parameter","title":"<code>get_output_parameter(node)</code>","text":"<p>Return the render output parameter of the given node</p> Example <p>root = hou.node(\"/obj\") my_alembic_node = root.createNode(\"alembic\") get_output_parameter(my_alembic_node)</p> <p>\"filename\"</p> Notes <p>I'm using node.type().name() to get on par with the creators,     Because the return value of <code>node.type().name()</code> is the     same string value used in creators     e.g. instance_data.update({\"node_type\": \"alembic\"})</p> <p>Rop nodes in different network categories have     the same output parameter.     So, I took that into consideration as a hint for     future development.</p> <p>Parameters:</p> Name Type Description Default <code>node(hou.Node)</code> <p>node instance</p> required <p>Returns:</p> Type Description <p>hou.Parm</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_output_parameter(node):\n    \"\"\"Return the render output parameter of the given node\n\n    Example:\n        root = hou.node(\"/obj\")\n        my_alembic_node = root.createNode(\"alembic\")\n        get_output_parameter(my_alembic_node)\n        &gt;&gt;&gt; \"filename\"\n\n    Notes:\n        I'm using node.type().name() to get on par with the creators,\n            Because the return value of `node.type().name()` is the\n            same string value used in creators\n            e.g. instance_data.update({\"node_type\": \"alembic\"})\n\n        Rop nodes in different network categories have\n            the same output parameter.\n            So, I took that into consideration as a hint for\n            future development.\n\n    Args:\n        node(hou.Node): node instance\n\n    Returns:\n        hou.Parm\n    \"\"\"\n\n    node_type = node.type().name()\n\n    # Figure out which type of node is being rendered\n    if node_type in {\"alembic\", \"rop_alembic\"}:\n        return node.parm(\"filename\")\n    elif node_type == \"arnold\":\n        if node_type.evalParm(\"ar_ass_export_enable\"):\n            return node.parm(\"ar_ass_file\")\n        return node.parm(\"ar_picture\")\n    elif node_type in {\n        \"geometry\",\n        \"rop_geometry\",\n        \"filmboxfbx\",\n        \"rop_fbx\"\n    }:\n        return node.parm(\"sopoutput\")\n    elif node_type == \"comp\":\n        return node.parm(\"copoutput\")\n    elif node_type in {\"karma\", \"opengl\", \"flipbook\"}:\n        return node.parm(\"picture\")\n    elif node_type == \"ifd\":  # Mantra\n        if node.evalParm(\"soho_outputmode\"):\n            return node.parm(\"soho_diskfile\")\n        return node.parm(\"vm_picture\")\n    elif node_type == \"Redshift_Proxy_Output\":\n        return node.parm(\"RS_archive_file\")\n    elif node_type == \"Redshift_ROP\":\n        return node.parm(\"RS_outputFileNamePrefix\")\n    elif node_type in {\"usd\", \"usd_rop\", \"usdexport\"}:\n        return node.parm(\"lopoutput\")\n    elif node_type in {\"usdrender\", \"usdrender_rop\"}:\n        return node.parm(\"outputimage\")\n    elif node_type == \"vray_renderer\":\n        return node.parm(\"SettingsOutput_img_file_path\")\n\n    raise TypeError(\"Node type '%s' not supported\" % node_type)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_resolution_from_entity","title":"<code>get_resolution_from_entity(entity)</code>","text":"<p>Get resolution from the given entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>dict[str, Any]</code> <p>Project, Folder or Task entity.</p> required <p>Returns:</p> Type Description <p>Union[Tuple[int, int], None]: Resolution width and height.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_resolution_from_entity(entity):\n    \"\"\"Get resolution from the given entity.\n\n    Args:\n        entity (dict[str, Any]): Project, Folder or Task entity.\n\n    Returns:\n        Union[Tuple[int, int], None]: Resolution width and height.\n\n    \"\"\"\n    if not entity or \"attrib\" not in entity:\n        raise ValueError(f\"Entity is not valid: \\\"{entity}\\\"\")\n\n    attributes = entity[\"attrib\"]\n    resolution_width = attributes.get(\"resolutionWidth\")\n    resolution_height = attributes.get(\"resolutionHeight\")\n\n    # Make sure both width and height are set\n    if resolution_width is None or resolution_height is None:\n        print(f\"No resolution information found in entity: '{entity}'\")\n        return None\n\n    return int(resolution_width), int(resolution_height)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.get_scene_viewer","title":"<code>get_scene_viewer(visible_only=True)</code>","text":"<p>Return an instance of a visible viewport.</p> <p>There may be many, some could be closed, any visible are current</p> <p>Parameters:</p> Name Type Description Default <code>visible_only</code> <code>Optional[bool]</code> <p>Only return viewers that currently are the active tab (and hence are visible).</p> <code>True</code> <p>Returns:</p> Type Description <p>Optional[hou.SceneViewer]: A scene viewer, if any.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def get_scene_viewer(visible_only=True):\n    \"\"\"\n    Return an instance of a visible viewport.\n\n    There may be many, some could be closed, any visible are current\n\n    Arguments:\n        visible_only (Optional[bool]): Only return viewers that currently\n            are the active tab (and hence are visible).\n\n    Returns:\n        Optional[hou.SceneViewer]: A scene viewer, if any.\n    \"\"\"\n    panes = hou.ui.paneTabs()\n    panes = [x for x in panes if x.type() == hou.paneTabType.SceneViewer]\n\n    if visible_only:\n        return next((pane for pane in panes if pane.isCurrentTab()), None)\n\n    panes = sorted(panes, key=lambda x: x.isCurrentTab())\n    if panes:\n        return panes[-1]\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.imprint","title":"<code>imprint(node, data, update=False)</code>","text":"<p>Store attributes with value on a node</p> <p>Depending on the type of attribute it creates the correct parameter template. Houdini uses a template per type, see the docs for more information.</p> <p>http://www.sidefx.com/docs/houdini/hom/hou/ParmTemplate.html</p> <p>Because of some update glitch where you cannot overwrite existing ParmTemplates on node using:     <code>setParmTemplates()</code> and <code>parmTuplesInFolder()</code> update is done in another pass.</p> <p>Parameters:</p> Name Type Description Default <code>node(hou.Node)</code> <p>node object from Houdini</p> required <code>data(dict)</code> <p>collection of attributes and their value</p> required <code>update</code> <code>bool</code> <p>flag if imprint should update already existing data or leave them untouched and only add new.</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def imprint(node, data, update=False):\n    \"\"\"Store attributes with value on a node\n\n    Depending on the type of attribute it creates the correct parameter\n    template. Houdini uses a template per type, see the docs for more\n    information.\n\n    http://www.sidefx.com/docs/houdini/hom/hou/ParmTemplate.html\n\n    Because of some update glitch where you cannot overwrite existing\n    ParmTemplates on node using:\n        `setParmTemplates()` and `parmTuplesInFolder()`\n    update is done in another pass.\n\n    Args:\n        node(hou.Node): node object from Houdini\n        data(dict): collection of attributes and their value\n        update (bool, optional): flag if imprint should update\n            already existing data or leave them untouched and only\n            add new.\n\n    Returns:\n        None\n\n    \"\"\"\n    if not data:\n        return\n    if not node:\n        self.log.error(\"Node is not set, calling imprint on invalid data.\")\n        return\n\n    current_parms = {p.name(): p for p in node.spareParms()}\n    update_parm_templates = []\n    new_parm_templates = []\n\n    for key, value in data.items():\n        if value is None:\n            continue\n\n        parm_template = get_template_from_value(key, value)\n\n        if key in current_parms:\n            if node.evalParm(key) == value:\n                continue\n            if not update:\n                log.debug(f\"{key} already exists on {node}\")\n            else:\n                log.debug(f\"replacing {key}\")\n                update_parm_templates.append(parm_template)\n            continue\n\n        new_parm_templates.append(parm_template)\n\n    if not new_parm_templates and not update_parm_templates:\n        return\n\n    parm_group = node.parmTemplateGroup()\n\n    # Add new parm templates\n    if new_parm_templates:\n        parm_folder = parm_group.findFolder(\"Extra\")\n\n        # if folder doesn't exist yet, create one and append to it,\n        # else append to existing one\n        if not parm_folder:\n            parm_folder = hou.FolderParmTemplate(\"folder\", \"Extra\")\n            parm_folder.setParmTemplates(new_parm_templates)\n            parm_group.append(parm_folder)\n        else:\n            # Add to parm template folder instance then replace with updated\n            # one in parm template group\n            for template in new_parm_templates:\n                parm_folder.addParmTemplate(template)\n            parm_group.replace(parm_folder.name(), parm_folder)\n\n    # Update existing parm templates\n    for parm_template in update_parm_templates:\n        parm_group.replace(parm_template.name(), parm_template)\n\n        # When replacing a parm with a parm of the same name it preserves its\n        # value if before the replacement the parm was not at the default,\n        # because it has a value override set. Since we're trying to update the\n        # parm by using the new value as `default` we enforce the parm is at\n        # default state\n        node.parm(parm_template.name()).revertToDefaults()\n\n    node.setParmTemplateGroup(parm_group)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.is_version_up_workfile_menu_enabled","title":"<code>is_version_up_workfile_menu_enabled()</code>  <code>cached</code>","text":"<p>Check if the 'Version Up Workfile' menu should be enabled.</p> <p>It's cached because we don't care about updating the menu during the current Houdini session and this allows us to avoid re-querying the project settings each time.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>@lru_cache(1)\ndef is_version_up_workfile_menu_enabled() -&gt; bool:\n    \"\"\"Check if the 'Version Up Workfile' menu should be enabled.\n\n    It's cached because we don't care about updating the menu during the\n    current Houdini session and this allows us to avoid re-querying the\n    project settings each time.\n\n    \"\"\"\n    project_settings = get_current_project_settings()\n    if project_settings[\"core\"][\"tools\"][\"ayon_menu\"].get(\n        \"version_up_current_workfile\"\n    ):\n        return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.lsattr","title":"<code>lsattr(attr, value=None, root='/')</code>","text":"<p>Return nodes that have <code>attr</code>  When <code>value</code> is not None it will only return nodes matching that value  for the given attribute.  Args:      attr (str): Name of the attribute (hou.Parm)      value (object, Optional): The value to compare the attribute too.         When the default None is provided the value check is skipped.     root (str): The root path in Houdini to search in. Returns:     list: Matching nodes that have attribute with value.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def lsattr(attr, value=None, root=\"/\"):\n    \"\"\"Return nodes that have `attr`\n     When `value` is not None it will only return nodes matching that value\n     for the given attribute.\n     Args:\n         attr (str): Name of the attribute (hou.Parm)\n         value (object, Optional): The value to compare the attribute too.\n            When the default None is provided the value check is skipped.\n        root (str): The root path in Houdini to search in.\n    Returns:\n        list: Matching nodes that have attribute with value.\n    \"\"\"\n    if value is None:\n        # Use allSubChildren() as allNodes() errors on nodes without\n        # permission to enter without a means to continue of querying\n        # the rest\n        nodes = hou.node(root).allSubChildren()\n        return [n for n in nodes if n.parm(attr)]\n    return lsattrs({attr: value})\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.lsattrs","title":"<code>lsattrs(attrs, root='/')</code>","text":"<p>Return nodes matching <code>key</code> and <code>value</code> Arguments:     attrs (dict): collection of attribute: value     root (str): The root path in Houdini to search in. Example:     &gt;&gt; lsattrs({\"id\": \"myId\"})     [\"myNode\"]     &gt;&gt; lsattr(\"id\")     [\"myNode\", \"myOtherNode\"] Returns:     list: Matching nodes that have attribute with value.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def lsattrs(attrs, root=\"/\"):\n    \"\"\"Return nodes matching `key` and `value`\n    Arguments:\n        attrs (dict): collection of attribute: value\n        root (str): The root path in Houdini to search in.\n    Example:\n        &gt;&gt; lsattrs({\"id\": \"myId\"})\n        [\"myNode\"]\n        &gt;&gt; lsattr(\"id\")\n        [\"myNode\", \"myOtherNode\"]\n    Returns:\n        list: Matching nodes that have attribute with value.\n    \"\"\"\n\n    matches = set()\n    # Use allSubChildren() as allNodes() errors on nodes without\n    # permission to enter without a means to continue of querying\n    # the rest\n    nodes = hou.node(root).allSubChildren()\n    for node in nodes:\n        for attr in attrs:\n            if not node.parm(attr):\n                continue\n            elif node.evalParm(attr) != attrs[attr]:\n                continue\n            else:\n                matches.add(node)\n\n    return list(matches)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context Example:     &gt;&gt;&gt; with maintained_selection():     ...     # Modify selection     ...     node.setSelected(on=False, clear_all_selected=True)     &gt;&gt;&gt; # Selection restored</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>@contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context\n    Example:\n        &gt;&gt;&gt; with maintained_selection():\n        ...     # Modify selection\n        ...     node.setSelected(on=False, clear_all_selected=True)\n        &gt;&gt;&gt; # Selection restored\n    \"\"\"\n\n    previous_selection = hou.selectedNodes()\n    try:\n        yield\n    finally:\n        # Clear the selection\n        # todo: does hou.clearAllSelected() do the same?\n        for node in hou.selectedNodes():\n            node.setSelected(on=False)\n\n        if previous_selection:\n            for node in previous_selection:\n                node.setSelected(on=True)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.parm_values","title":"<code>parm_values(overrides)</code>","text":"<p>Override Parameter values during the context. Arguments:     overrides (List[Tuple[hou.Parm, Any]]): The overrides per parm         that should be applied during context.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>@contextmanager\ndef parm_values(overrides):\n    \"\"\"Override Parameter values during the context.\n    Arguments:\n        overrides (List[Tuple[hou.Parm, Any]]): The overrides per parm\n            that should be applied during context.\n    \"\"\"\n\n    originals = []\n    try:\n        for parm, value in overrides:\n            originals.append((parm, parm.eval()))\n            parm.set(value)\n        yield\n    finally:\n        for parm, value in originals:\n            # Parameter might not exist anymore so first\n            # check whether it's still valid\n            if hou.parm(parm.path()):\n                parm.set(value)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.prompt_reset_context","title":"<code>prompt_reset_context()</code>","text":"<p>Prompt the user what context settings to reset. This prompt is used on saving to a different task to allow the scene to get matched to the new context.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def prompt_reset_context():\n    \"\"\"Prompt the user what context settings to reset.\n    This prompt is used on saving to a different task to allow the scene to\n    get matched to the new context.\n    \"\"\"\n    # TODO: Cleanup this prototyped mess of imports and odd dialog\n    from ayon_core.tools.attribute_defs.dialog import (\n        AttributeDefinitionsDialog\n    )\n    from ayon_core.style import load_stylesheet\n    from ayon_core.lib import BoolDef, UILabelDef\n\n    definitions = [\n        UILabelDef(\n            label=(\n                \"You are saving your workfile into a different folder or task.\"\n                \"\\n\\n\"\n                \"Would you like to update some settings to the new context?\\n\"\n            )\n        ),\n        BoolDef(\n            \"fps\",\n            label=\"FPS\",\n            tooltip=\"Reset workfile FPS\",\n            default=True\n        ),\n        BoolDef(\n            \"frame_range\",\n            label=\"Frame Range\",\n            tooltip=\"Reset workfile start and end frame ranges\",\n            default=True\n        ),\n        BoolDef(\n            \"instances\",\n            label=\"Publish instances\",\n            tooltip=\"Update all publish instance's folder and task to match \"\n                    \"the new folder and task\",\n            default=True\n        ),\n    ]\n\n    dialog = AttributeDefinitionsDialog(definitions)\n    dialog.setWindowTitle(\"Saving to different context.\")\n    dialog.setStyleSheet(load_stylesheet())\n    if not dialog.exec_():\n        return None\n\n    options = dialog.get_values()\n    if options[\"fps\"] or options[\"frame_range\"]:\n        reset_framerange(\n            fps=options[\"fps\"],\n            frame_range=options[\"frame_range\"]\n        )\n\n    if options[\"instances\"]:\n        update_content_on_context_change()\n\n    dialog.deleteLater()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.publisher_show_and_publish","title":"<code>publisher_show_and_publish(comment=None)</code>","text":"<p>Open publisher window and trigger publishing action.</p> <p>Parameters:</p> Name Type Description Default <code>comment</code> <code>Optional[str]</code> <p>Comment to set in publisher window.</p> <code>None</code> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def publisher_show_and_publish(comment=None):\n    \"\"\"Open publisher window and trigger publishing action.\n\n    Args:\n        comment (Optional[str]): Comment to set in publisher window.\n    \"\"\"\n\n    main_window = get_main_window()\n    publisher_window = get_tool_by_name(\n        tool_name=\"publisher\",\n        parent=main_window,\n    )\n    publisher_window.show_and_publish(comment)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.read","title":"<code>read(node)</code>","text":"<p>Read the container data in to a dict</p> <p>Parameters:</p> Name Type Description Default <code>node(hou.Node)</code> <p>Houdini node</p> required <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def read(node):\n    \"\"\"Read the container data in to a dict\n\n    Args:\n        node(hou.Node): Houdini node\n\n    Returns:\n        dict\n\n    \"\"\"\n    # `spareParms` returns a tuple of hou.Parm objects\n    data = {}\n    if not node:\n        return data\n    for parameter in node.spareParms():\n        value = parameter.eval()\n        # test if value is json encoded dict\n        if isinstance(value, str) and \\\n                value.startswith(JSON_PREFIX):\n            try:\n                value = json.loads(value[len(JSON_PREFIX):])\n            except json.JSONDecodeError:\n                # not a json\n                pass\n        data[parameter.name()] = value\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.remove_all_thumbnails","title":"<code>remove_all_thumbnails(node)</code>","text":"<p>Remove all node thumbnails.</p> <p>Removes all network background images that are linked to the given node.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def remove_all_thumbnails(node):\n    \"\"\"Remove all node thumbnails.\n\n    Removes all network background images that are linked to the given node.\n    \"\"\"\n    parent = node.parent()\n    images = get_background_images(parent)\n    node_path = node.path()\n    images = [\n        image for image in images if image.relativeToPath() != node_path\n    ]\n    set_background_images(parent, images)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.render_rop","title":"<code>render_rop(ropnode, frame_range=None)</code>","text":"<p>Render ROP node utility for Publishing.</p> <p>This renders a ROP node with the settings we want during Publishing.</p> <p>Parameters:</p> Name Type Description Default <code>ropnode</code> <code>RopNode</code> <p>Node to render</p> required <code>frame_range</code> <code>tuple</code> <p>Copied from Houdini's help.. Sequence of 2 or 3 values, overrides the frame range and frame increment to render. The first two values specify the start and end frames, and the third value (if given) specifies the frame increment. If no frame increment is given and the ROP node doesn't specify a frame increment, then a value of 1 will be used. If no frame range is given, and the ROP node doesn't specify a frame range, then the current frame will be rendered.</p> <code>None</code> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def render_rop(ropnode, frame_range=None):\n    \"\"\"Render ROP node utility for Publishing.\n\n    This renders a ROP node with the settings we want during Publishing.\n\n    Args:\n        ropnode (hou.RopNode): Node to render\n        frame_range (tuple): Copied from Houdini's help..\n            Sequence of 2 or 3 values, overrides the frame range and frame\n            increment to render. The first two values specify the start and\n            end frames, and the third value (if given) specifies the frame\n            increment. If no frame increment is given and the ROP node\n            doesn't specify a frame increment, then a value of 1 will be\n            used. If no frame range is given, and the ROP node doesn't\n            specify a frame range, then the current frame will be rendered.\n    \"\"\"\n\n    if frame_range is None:\n        frame_range = ()\n\n    # Print verbose when in batch mode without UI\n    verbose = not hou.isUIAvailable()\n\n    # Render\n    try:\n        ropnode.render(verbose=verbose,\n                       # Allow Deadline to capture completion percentage\n                       output_progress=verbose,\n                       # Render only this node\n                       # (do not render any of its dependencies)\n                       ignore_inputs=True,\n                       frame_range=frame_range)\n    except hou.Error as exc:\n        # The hou.Error is not inherited from a Python Exception class,\n        # so we explicitly capture the houdini error, otherwise pyblish\n        # will remain hanging.\n        import traceback\n        traceback.print_exc()\n        raise RuntimeError(\"Render failed: {0}\".format(exc))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.reset_framerange","title":"<code>reset_framerange(fps=True, frame_range=True)</code>","text":"<p>Set frame range and FPS to current folder.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def reset_framerange(fps=True, frame_range=True):\n    \"\"\"Set frame range and FPS to current folder.\"\"\"\n\n    task_entity = get_current_task_entity(fields={\"attrib\"})\n\n    # Set FPS\n    if fps:\n        fps = get_entity_fps(task_entity)\n        print(\"Setting scene FPS to {}\".format(int(fps)))\n        set_scene_fps(fps)\n\n    if frame_range:\n\n        # Set Start and End Frames\n        task_attrib = task_entity[\"attrib\"]\n        frame_start = task_attrib.get(\"frameStart\", 0)\n        frame_end = task_attrib.get(\"frameEnd\", 0)\n\n        handle_start = task_attrib.get(\"handleStart\", 0)\n        handle_end = task_attrib.get(\"handleEnd\", 0)\n\n        frame_start -= int(handle_start)\n        frame_end += int(handle_end)\n\n        # Set frame range and FPS\n        hou.playbar.setFrameRange(frame_start, frame_end)\n        hou.playbar.setPlaybackRange(frame_start, frame_end)\n        hou.setFrame(frame_start)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.sceneview_snapshot","title":"<code>sceneview_snapshot(sceneview, filepath='$HIP/thumbnails/$HIPNAME.$F4.jpg', frame_start=None, frame_end=None)</code>","text":"<p>Take a snapshot of your scene view.</p> <p>It takes snapshot of your scene view for the given frame range. So, it's capable of generating snapshots image sequence. It works in different Houdini context e.g. Objects, Solaris</p> <p>Example::     &gt;&gt;&gt; from ayon_houdini.api import lib     &gt;&gt;&gt; sceneview = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)     &gt;&gt;&gt; lib.sceneview_snapshot(sceneview)</p> Notes <p>.png output will render poorly, so use .jpg.</p> <p>How it works:     Get the current sceneviewer (may be more than one or hidden)     and screengrab the perspective viewport to a file in the     publish location to be picked up with the publish.</p> <p>Credits:     https://www.sidefx.com/forum/topic/42808/?page=1#post-354796</p> <p>Parameters:</p> Name Type Description Default <code>sceneview</code> <code>SceneViewer</code> <p>The scene view pane from which you want                          to take a snapshot.</p> required <code>filepath</code> <code>str</code> <p>thumbnail filepath. it expects <code>$F4</code> token             when frame_end is bigger than frame_star other wise             each frame will override its predecessor.</p> <code>'$HIP/thumbnails/$HIPNAME.$F4.jpg'</code> <code>frame_start</code> <code>int</code> <p>the frame at which snapshot starts</p> <code>None</code> <code>frame_end</code> <code>int</code> <p>the frame at which snapshot ends</p> <code>None</code> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def sceneview_snapshot(\n        sceneview,\n        filepath=\"$HIP/thumbnails/$HIPNAME.$F4.jpg\",\n        frame_start=None,\n        frame_end=None):\n    \"\"\"Take a snapshot of your scene view.\n\n    It takes snapshot of your scene view for the given frame range.\n    So, it's capable of generating snapshots image sequence.\n    It works in different Houdini context e.g. Objects, Solaris\n\n    Example::\n        &gt;&gt;&gt; from ayon_houdini.api import lib\n        &gt;&gt;&gt; sceneview = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)\n        &gt;&gt;&gt; lib.sceneview_snapshot(sceneview)\n\n    Notes:\n        .png output will render poorly, so use .jpg.\n\n        How it works:\n            Get the current sceneviewer (may be more than one or hidden)\n            and screengrab the perspective viewport to a file in the\n            publish location to be picked up with the publish.\n\n        Credits:\n            https://www.sidefx.com/forum/topic/42808/?page=1#post-354796\n\n    Args:\n        sceneview (hou.SceneViewer): The scene view pane from which you want\n                                     to take a snapshot.\n        filepath (str): thumbnail filepath. it expects `$F4` token\n                        when frame_end is bigger than frame_star other wise\n                        each frame will override its predecessor.\n        frame_start (int): the frame at which snapshot starts\n        frame_end (int): the frame at which snapshot ends\n    \"\"\"\n\n    if frame_start is None:\n        frame_start = hou.frame()\n    if frame_end is None:\n        frame_end = frame_start\n\n    if not isinstance(sceneview, hou.SceneViewer):\n        log.debug(\"Wrong Input. {} is not of type hou.SceneViewer.\"\n                  .format(sceneview))\n        return\n    viewport = sceneview.curViewport()\n\n    flip_settings = sceneview.flipbookSettings().stash()\n    flip_settings.frameRange((frame_start, frame_end))\n    flip_settings.output(filepath)\n    flip_settings.outputToMPlay(False)\n    sceneview.flipbook(viewport, flip_settings)\n    log.debug(\"A snapshot of sceneview has been saved to: {}\".format(filepath))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.self_publish","title":"<code>self_publish()</code>","text":"<p>Self publish from ROP nodes.</p> <p>Firstly, it gets the node and its dependencies. Then, it deactivates all other ROPs And finally, it triggers the publishing action.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def self_publish():\n    \"\"\"Self publish from ROP nodes.\n\n    Firstly, it gets the node and its dependencies.\n    Then, it deactivates all other ROPs\n    And finally, it triggers the publishing action.\n    \"\"\"\n\n    result, comment = hou.ui.readInput(\n        \"Add Publish Comment\",\n        buttons=(\"Publish\", \"Cancel\"),\n        title=\"Publish comment\",\n        close_choice=1\n    )\n\n    if result:\n        return\n\n    current_node = hou.node(\".\")\n    inputs_paths = find_rop_input_dependencies(\n        current_node.inputDependencies()\n    )\n    inputs_paths.append(current_node.path())\n\n    host = registered_host()\n    context = CreateContext(host, reset=True)\n\n    for instance in context.instances:\n        node_path = instance.data.get(\"instance_node\")\n        instance[\"active\"] = node_path and node_path in inputs_paths\n\n    context.save_changes()\n\n    publisher_show_and_publish(comment)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.set_background_images","title":"<code>set_background_images(node, images)</code>","text":"<p>Set hou.NetworkImage background images under given hou.Node</p> <p>Similar to: <code>nodegraphutils.loadBackgroundImages</code></p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def set_background_images(node, images):\n    \"\"\"Set hou.NetworkImage background images under given hou.Node\n\n    Similar to: `nodegraphutils.loadBackgroundImages`\n\n    \"\"\"\n\n    def _serialize(image):\n        \"\"\"Return hou.NetworkImage as serialized dict\"\"\"\n        if isinstance(image, dict):\n            # Assume already serialized, only do some minor validations\n            if \"path\" not in image:\n                raise ValueError(\"Missing `path` key in image dictionary.\")\n            if \"rect\" not in image:\n                raise ValueError(\"Missing `rect` key in image dictionary.\")\n            if len(image[\"rect\"]) != 4:\n                raise ValueError(\"`rect` value must be list of four floats.\")\n            return image\n\n        rect = image.rect()\n        rect_min = rect.min()\n        rect_max = rect.max()\n        data = {\n            \"path\": image.path(),\n            \"rect\": [rect_min.x(), rect_min.y(), rect_max.x(), rect_max.y()],\n        }\n        if image.brightness() != 1.0:\n            data[\"brightness\"] = image.brightness()\n        if image.relativeToPath():\n            data[\"relativetopath\"] = image.relativeToPath()\n        return data\n\n    with hou.undos.group('Edit Background Images'):\n        if images:\n            assert all(isinstance(image, (dict, hou.NetworkImage))\n                       for image in images)\n            data = json.dumps([_serialize(image) for image in images])\n            node.setUserData(\"backgroundimages\", data)\n        else:\n            node.destroyUserData(\"backgroundimages\", must_exist=False)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.set_camera_resolution","title":"<code>set_camera_resolution(camera, entity=None)</code>","text":"<p>Apply resolution to camera from task or folder entity.</p> <p>Parameters:</p> Name Type Description Default <code>camera</code> <code>OpNode</code> <p>Camera node.</p> required <code>entity</code> <code>Optional[Dict[str, Any]]</code> <p>Folder or task entity. If not provided falls back to current task entity.</p> <code>None</code> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def set_camera_resolution(camera, entity=None):\n    \"\"\"Apply resolution to camera from task or folder entity.\n\n    Arguments:\n        camera (hou.OpNode): Camera node.\n        entity (Optional[Dict[str, Any]]): Folder or task entity.\n            If not provided falls back to current task entity.\n    \"\"\"\n\n    if not entity:\n        entity = get_current_task_entity()\n\n    resolution = get_resolution_from_entity(entity)\n\n    if resolution:\n        print(\"Setting camera resolution: {} -&gt; {}x{}\".format(\n            camera.name(), resolution[0], resolution[1]\n        ))\n        camera.parm(\"resx\").set(resolution[0])\n        camera.parm(\"resy\").set(resolution[1])\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.set_node_thumbnail","title":"<code>set_node_thumbnail(node, image_path, rect=None)</code>","text":"<p>Set hou.NetworkImage attached to node.</p> <p>If an existing connected image is found it assumes that is the existing thumbnail and will update that particular instance instead.</p> <p>When <code>image_path</code> is None an existing attached <code>hou.NetworkImage</code> will be removed.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to set thumbnail for.</p> required <code>image_path</code> <code>Union[str, None]</code> <p>Path to image to set. If None is set then the thumbnail will be removed if it exists.</p> required <code>rect</code> <code>BoundingRect</code> <p>Bounding rect for the relative placement to the node.</p> <code>None</code> <p>Returns:</p> Type Description <p>hou.NetworkImage or None: The network image that was set or None if instead it not set or removed.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def set_node_thumbnail(node, image_path, rect=None):\n    \"\"\"Set hou.NetworkImage attached to node.\n\n    If an existing connected image is found it assumes that is the existing\n    thumbnail and will update that particular instance instead.\n\n    When `image_path` is None an existing attached `hou.NetworkImage` will be\n    removed.\n\n    Arguments:\n        node (hou.Node): Node to set thumbnail for.\n        image_path (Union[str, None]): Path to image to set.\n            If None is set then the thumbnail will be removed if it exists.\n        rect (hou.BoundingRect): Bounding rect for the relative placement\n            to the node.\n\n    Returns:\n        hou.NetworkImage or None: The network image that was set or None if\n            instead it not set or removed.\n\n    \"\"\"\n\n    parent = node.parent()\n    images = get_background_images(parent)\n\n    node_path = node.path()\n    # Find first existing image attached to node\n    index, image = next(\n        (\n            (index, image) for index, image in enumerate(images) if\n            image.relativeToPath() == node_path\n        ),\n        (None, None)\n    )\n    if image_path is None:\n        # Remove image if it exists\n        if image:\n            images.remove(image)\n            set_background_images(parent, images)\n        return\n\n    if rect is None:\n        rect = hou.BoundingRect(-1, -1, 1, 1)\n\n    if isinstance(image_path, hou.NetworkImage):\n        image = image_path\n        if index is not None:\n            images[index] = image\n        else:\n            images.append(image)\n    elif image is None:\n        # Create the image\n        image = hou.NetworkImage(image_path, rect)\n        image.setRelativeToPath(node.path())\n        images.append(image)\n    else:\n        # Update first existing image\n        image.setRect(rect)\n        image.setPath(image_path)\n\n    set_background_images(parent, images)\n\n    return image\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.set_review_color_space","title":"<code>set_review_color_space(node, review_color_space='', log=None)</code>","text":"<p>Set ociocolorspace parameter for the given OpenGL node.</p> <p>Set <code>ociocolorspace</code> parameter of the given node to to the given review_color_space value. If review_color_space is empty, a default colorspace corresponding to the display &amp; view of the current Houdini session will be used.</p> Note <p>This function expects nodes of type <code>opengl</code> or <code>flipbook</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>ROP node to set its ociocolorspace parm.</p> required <code>review_color_space</code> <code>str</code> <p>Colorspace value for ociocolorspace parm.</p> <code>''</code> <code>log</code> <code>Logger</code> <p>Logger to log to.</p> <code>None</code> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def set_review_color_space(node, review_color_space=\"\", log=None):\n    \"\"\"Set ociocolorspace parameter for the given OpenGL node.\n\n    Set `ociocolorspace` parameter of the given node\n    to to the given review_color_space value.\n    If review_color_space is empty, a default colorspace corresponding to\n    the display &amp; view of the current Houdini session will be used.\n\n    Note:\n        This function expects nodes of type `opengl` or `flipbook`.\n\n    Args:\n        node (hou.Node): ROP node to set its ociocolorspace parm.\n        review_color_space (str): Colorspace value for ociocolorspace parm.\n        log (logging.Logger): Logger to log to.\n    \"\"\"\n\n    if log is None:\n        log = self.log\n\n    if node.type().name() not in {\"opengl\", \"flipbook\"}:\n        log.warning(\n            \"Type of given node {} not allowed.\"\n            \" only types `opengl` and `flipbook` are allowed.\"\n            .format(node.type().name())\n        )\n\n    # Set Color Correction parameter to OpenColorIO\n    colorcorrect_parm = node.parm(\"colorcorrect\")\n    if colorcorrect_parm.evalAsString() != \"ocio\":\n        idx = colorcorrect_parm.menuItems().index(\"ocio\")\n        colorcorrect_parm.set(idx)\n        log.debug(\n            \"'Color Correction' parm on '{}' has been set to '{}'\"\n            .format(node.path(), colorcorrect_parm.menuLabels()[idx])\n        )\n\n    node.setParms(\n        {\"ociocolorspace\": review_color_space}\n    )\n\n    log.debug(\n        \"'OCIO Colorspace' parm on '{}' has been set to \"\n        \"the view color space '{}'\"\n        .format(node.path(), review_color_space)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.show_node_parmeditor","title":"<code>show_node_parmeditor(node)</code>","text":"<p>Show Parameter Editor for the Node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>node instance</p> required Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def show_node_parmeditor(node):\n    \"\"\"Show Parameter Editor for the Node.\n\n    Args:\n        node (hou.Node): node instance\n    \"\"\"\n\n    # Check if there's a floating parameter editor pane with its node\n    #   set to the specified node.\n    for tab in hou.ui.paneTabs():\n        if (\n            tab.type() == hou.paneTabType.Parm\n            and tab.isFloating()\n            and tab.currentNode() == node\n        ):\n            tab.setIsCurrentTab()\n            return\n\n    # We are using the hscript to create and set the network path of the pane\n    # because hscript can set the node path without selecting the node.\n    # Create a floating pane and set its name to the node path.\n    hou.hscript(\n        f\"pane -F -m parmeditor -n {node.path()}\"\n    )\n    # Hide network controls, turn linking off and set operator node path.\n    hou.hscript(\n        f\"pane -a 1 -l 0 -H {node.path()} {node.path()}\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.splitext","title":"<code>splitext(name, allowed_multidot_extensions)</code>","text":"<p>Split file name to name and extension.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>File name to split.</p> required <code>allowed_multidot_extensions</code> <code>list of str</code> <p>List of allowed multidot extensions.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>Name and extension.</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def splitext(name, allowed_multidot_extensions):\n    # type: (str, list) -&gt; tuple\n    \"\"\"Split file name to name and extension.\n\n    Args:\n        name (str): File name to split.\n        allowed_multidot_extensions (list of str): List of allowed multidot\n            extensions.\n\n    Returns:\n        tuple: Name and extension.\n    \"\"\"\n\n    for ext in allowed_multidot_extensions:\n        if name.endswith(ext):\n            return name[:-len(ext)], ext\n\n    return os.path.splitext(name)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.update_content_on_context_change","title":"<code>update_content_on_context_change()</code>","text":"<p>Update all Creator instances to current asset</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def update_content_on_context_change():\n    \"\"\"Update all Creator instances to current asset\"\"\"\n    host = registered_host()\n    context = host.get_current_context()\n\n    folder_path = context[\"folder_path\"]\n    task = context[\"task_name\"]\n\n    create_context = CreateContext(host, reset=True)\n\n    for instance in create_context.instances:\n        instance_folder_path = instance.get(\"folderPath\")\n        if instance_folder_path and instance_folder_path != folder_path:\n            instance[\"folderPath\"] = folder_path\n        instance_task = instance.get(\"task\")\n        if instance_task and instance_task != task:\n            instance[\"task\"] = task\n\n    create_context.save_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.update_houdini_vars_context","title":"<code>update_houdini_vars_context()</code>","text":"<p>Update task context variables</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def update_houdini_vars_context():\n    \"\"\"Update task context variables\"\"\"\n\n    for var, (_old, new, is_directory) in get_context_var_changes().items():\n        if is_directory:\n            try:\n                os.makedirs(new)\n            except OSError as e:\n                if e.errno != errno.EEXIST:\n                    print(\n                        \"Failed to create ${} dir. Maybe due to \"\n                        \"insufficient permissions.\".format(var)\n                    )\n\n        hou.hscript(\"set {}={}\".format(var, new))\n        os.environ[var] = new\n        print(\"Updated ${} to {}\".format(var, new))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.update_houdini_vars_context_dialog","title":"<code>update_houdini_vars_context_dialog()</code>","text":"<p>Show pop-up to update task context variables</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def update_houdini_vars_context_dialog():\n    \"\"\"Show pop-up to update task context variables\"\"\"\n    update_vars = get_context_var_changes()\n    if not update_vars:\n        # Nothing to change\n        print(\"Nothing to change, Houdini vars are already up to date.\")\n        return\n\n    message = \"\\n\".join(\n        \"${}: {} -&gt; {}\".format(var, old or \"None\", new or \"None\")\n        for var, (old, new, _is_directory) in update_vars.items()\n    )\n\n    # TODO: Use better UI!\n    parent = hou.ui.mainQtWindow()\n    dialog = SimplePopup(parent=parent)\n    dialog.setModal(True)\n    dialog.setWindowTitle(\"Houdini scene has outdated task variables\")\n    dialog.set_message(message)\n    dialog.set_button_text(\"Fix\")\n\n    # on_show is the Fix button clicked callback\n    dialog.on_clicked.connect(update_houdini_vars_context)\n\n    dialog.show()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/lib.html#client.ayon_houdini.api.lib.validate_fps","title":"<code>validate_fps()</code>","text":"<p>Validate current scene FPS and show pop-up when it is incorrect</p> <p>Returns:</p> Type Description <p>bool</p> Source code in <code>client/ayon_houdini/api/lib.py</code> <pre><code>def validate_fps():\n    \"\"\"Validate current scene FPS and show pop-up when it is incorrect\n\n    Returns:\n        bool\n\n    \"\"\"\n\n    fps = get_entity_fps()\n    current_fps = hou.fps()  # returns float\n\n    if current_fps != fps:\n\n        # Find main window\n        parent = hou.ui.mainQtWindow()\n        if parent is None:\n            pass\n        else:\n            dialog = PopupUpdateKeys(parent=parent)\n            dialog.setModal(True)\n            dialog.setWindowTitle(\"Houdini scene does not match project FPS\")\n            dialog.set_message(\"Scene %i FPS does not match project %i FPS\" %\n                              (current_fps, fps))\n            dialog.set_button_text(\"Fix\")\n\n            # on_show is the Fix button clicked callback\n            dialog.on_clicked_state.connect(lambda: set_scene_fps(fps))\n\n            dialog.show()\n\n            return False\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/pipeline.html","title":"pipeline","text":"<p>Pipeline tools for OpenPype Houdini integration.</p>"},{"location":"autoapi/client/ayon_houdini/api/pipeline.html#client.ayon_houdini.api.pipeline.HoudiniHost","title":"<code>HoudiniHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_houdini/api/pipeline.py</code> <pre><code>class HoudiniHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"houdini\"\n\n    def __init__(self):\n        super(HoudiniHost, self).__init__()\n        self._op_events = {}\n        self._has_been_setup = False\n\n    def install(self):\n        pyblish.api.register_host(\"houdini\")\n        pyblish.api.register_host(\"hython\")\n        pyblish.api.register_host(\"hpython\")\n\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_inventory_action_path(INVENTORY_PATH)\n        register_workfile_build_plugin_path(WORKFILE_BUILD_PATH)\n\n        log.info(\"Installing callbacks ... \")\n        # register_event_callback(\"init\", on_init)\n        self._register_callbacks()\n        register_event_callback(\"workfile.save.before\", before_workfile_save)\n        register_event_callback(\"before.save\", before_save)\n        register_event_callback(\"save\", on_save)\n        register_event_callback(\"open\", on_open)\n        register_event_callback(\"new\", on_new)\n        register_event_callback(\"taskChanged\", on_task_changed)\n\n        self._has_been_setup = True\n\n        # Manually call on_new callback as it doesn't get called when AYON\n        # launches for the first time on a context, only when going to\n        # File -&gt; New\n        on_new()\n\n        if not IS_HEADLESS:\n            import hdefereval  # noqa, hdefereval is only available in ui mode\n            # Defer generation of shelves due to issue on Windows where shelf\n            # initialization during start up delays Houdini UI by minutes\n            # making it extremely slow to launch.\n            hdefereval.executeDeferred(shelves.generate_shelves)\n            hdefereval.executeDeferred(creator_node_shelves.install)\n            if env_value_to_bool(\"AYON_WORKFILE_TOOL_ON_START\"):\n                hdefereval.executeDeferred(\n                    lambda: host_tools.show_workfiles(\n                        parent=hou.qt.mainWindow()\n                    )\n                )\n\n    def workfile_has_unsaved_changes(self):\n        return hou.hipFile.hasUnsavedChanges()\n\n    def get_workfile_extensions(self):\n        return [\".hip\", \".hiplc\", \".hipnc\"]\n\n    def save_workfile(self, dst_path=None):\n        # Force forwards slashes to avoid segfault\n        if dst_path:\n            dst_path = dst_path.replace(\"\\\\\", \"/\")\n        hou.hipFile.save(file_name=dst_path,\n                         save_to_recent_files=True)\n        return dst_path\n\n    def open_workfile(self, filepath):\n        # Force forwards slashes to avoid segfault\n        filepath = filepath.replace(\"\\\\\", \"/\")\n\n        try:\n            hou.hipFile.load(filepath,\n                             suppress_save_prompt=True,\n                             ignore_load_warnings=False)\n        except hou.LoadWarning as exc:\n            log.warning(exc)\n\n        return filepath\n\n    def get_current_workfile(self):\n        current_filepath = hou.hipFile.path()\n        if (os.path.basename(current_filepath) == \"untitled.hip\" and\n                not os.path.exists(current_filepath)):\n            # By default a new scene in houdini is saved in the current\n            # working directory as \"untitled.hip\" so we need to capture\n            # that and consider it 'not saved' when it's in that state.\n            return None\n\n        return current_filepath\n\n    def get_containers(self):\n        return ls()\n\n    def _register_callbacks(self):\n        for event in self._op_events.copy().values():\n            if event is None:\n                continue\n\n            try:\n                hou.hipFile.removeEventCallback(event)\n            except RuntimeError as e:\n                log.info(e)\n\n        self._op_events[on_file_event_callback] = hou.hipFile.addEventCallback(\n            on_file_event_callback\n        )\n\n    @staticmethod\n    def create_context_node():\n        \"\"\"Helper for creating context holding node.\n\n        Returns:\n            hou.Node: context node\n\n        \"\"\"\n        obj_network = hou.node(\"/obj\")\n        op_ctx = obj_network.createNode(\"subnet\",\n                                        node_name=\"OpenPypeContext\",\n                                        run_init_scripts=False,\n                                        load_contents=False)\n\n        op_ctx.moveToGoodPosition()\n        op_ctx.setBuiltExplicitly(False)\n        op_ctx.setCreatorState(\"OpenPype\")\n        op_ctx.setComment(\"OpenPype node to hold context metadata\")\n        op_ctx.setColor(hou.Color((0.081, 0.798, 0.810)))\n        op_ctx.setDisplayFlag(False)\n        op_ctx.hide(True)\n        return op_ctx\n\n    def update_context_data(self, data, changes):\n        op_ctx = hou.node(CONTEXT_CONTAINER)\n        if not op_ctx:\n            op_ctx = self.create_context_node()\n\n        lib.imprint(op_ctx, data, update=True)\n\n    def get_context_data(self):\n        op_ctx = hou.node(CONTEXT_CONTAINER)\n        if not op_ctx:\n            op_ctx = self.create_context_node()\n        return lib.read(op_ctx)\n\n    def save_file(self, dst_path=None):\n        # Force forwards slashes to avoid segfault\n        dst_path = dst_path.replace(\"\\\\\", \"/\")\n\n        hou.hipFile.save(file_name=dst_path,\n                         save_to_recent_files=True)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/pipeline.html#client.ayon_houdini.api.pipeline.HoudiniHost.create_context_node","title":"<code>create_context_node()</code>  <code>staticmethod</code>","text":"<p>Helper for creating context holding node.</p> <p>Returns:</p> Type Description <p>hou.Node: context node</p> Source code in <code>client/ayon_houdini/api/pipeline.py</code> <pre><code>@staticmethod\ndef create_context_node():\n    \"\"\"Helper for creating context holding node.\n\n    Returns:\n        hou.Node: context node\n\n    \"\"\"\n    obj_network = hou.node(\"/obj\")\n    op_ctx = obj_network.createNode(\"subnet\",\n                                    node_name=\"OpenPypeContext\",\n                                    run_init_scripts=False,\n                                    load_contents=False)\n\n    op_ctx.moveToGoodPosition()\n    op_ctx.setBuiltExplicitly(False)\n    op_ctx.setCreatorState(\"OpenPype\")\n    op_ctx.setComment(\"OpenPype node to hold context metadata\")\n    op_ctx.setColor(hou.Color((0.081, 0.798, 0.810)))\n    op_ctx.setDisplayFlag(False)\n    op_ctx.hide(True)\n    return op_ctx\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/pipeline.html#client.ayon_houdini.api.pipeline.containerise","title":"<code>containerise(name, namespace, nodes, context, loader=None, suffix='')</code>","text":"<p>Bundle <code>nodes</code> into a subnet and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>nodes</code> <code>list</code> <p>Long names of nodes to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Name of container assembly</p> Source code in <code>client/ayon_houdini/api/pipeline.py</code> <pre><code>def containerise(name,\n                 namespace,\n                 nodes,\n                 context,\n                 loader=None,\n                 suffix=\"\"):\n    \"\"\"Bundle `nodes` into a subnet and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        nodes (list): Long names of nodes to containerise\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Name of container assembly\n\n    \"\"\"\n\n    # Get AVALON_CONTAINERS subnet\n    subnet = get_or_create_avalon_container()\n\n    # Create proper container name\n    container_name = \"{}_{}\".format(name, suffix or \"CON\")\n    container = hou.node(\"/obj/{}\".format(name))\n    container.setName(container_name, unique_name=True)\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"]\n    }\n\n    lib.imprint(container, data)\n\n    # \"Parent\" the container under the container network\n    hou.moveNodesTo([container], subnet)\n\n    subnet.node(container_name).moveToGoodPosition()\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/pipeline.html#client.ayon_houdini.api.pipeline.on_new","title":"<code>on_new()</code>","text":"<p>Set project resolution and fps when create a new file</p> Source code in <code>client/ayon_houdini/api/pipeline.py</code> <pre><code>def on_new():\n    \"\"\"Set project resolution and fps when create a new file\"\"\"\n\n    if hou.hipFile.isLoadingHipFile():\n        # This event also triggers when Houdini opens a file due to the\n        # new event being registered to 'afterClear'. As such we can skip\n        # 'new' logic if the user is opening a file anyway\n        log.debug(\"Skipping on new callback due to scene being opened.\")\n        return\n\n    log.info(\"Running callback on new..\")\n    _set_context_settings()\n\n    # It seems that the current frame always gets reset to frame 1 on\n    # new scene. So we enforce current frame to be at the start of the playbar\n    # with execute deferred\n    def _enforce_start_frame():\n        start = hou.playbar.playbackRange()[0]\n        hou.setFrame(start)\n\n    if hou.isUIAvailable():\n        import hdefereval\n        hdefereval.executeDeferred(lib.start_workfile_template_builder)\n        hdefereval.executeDeferred(_enforce_start_frame)\n    else:\n        # Run without execute deferred when no UI is available because\n        # without UI `hdefereval` is not available to import\n        _enforce_start_frame()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/pipeline.html#client.ayon_houdini.api.pipeline.parse_container","title":"<code>parse_container(container)</code>","text":"<p>Return the container node's full container data.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>Node</code> <p>A container node name.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The container schema data for this container node.</p> Source code in <code>client/ayon_houdini/api/pipeline.py</code> <pre><code>def parse_container(container):\n    \"\"\"Return the container node's full container data.\n\n    Args:\n        container (hou.Node): A container node name.\n\n    Returns:\n        dict: The container schema data for this container node.\n\n    \"\"\"\n    # Read only relevant parms\n    # TODO: Clean up this hack replacing `lib.read(container)`\n\n    data = {}\n    for name in [\"name\", \"namespace\", \"loader\", \"representation\", \"id\"]:\n        parm = container.parm(name)\n        if not parm:\n            return {}\n\n        value = parm.eval()\n\n        # test if value is json encoded dict\n        if isinstance(value, str) and value.startswith(JSON_PREFIX):\n            try:\n                value = json.loads(value[len(JSON_PREFIX):])\n            except json.JSONDecodeError:\n                # not a json\n                pass\n        data[name] = value\n\n    # Support project name in container as optional attribute\n    for name in [\"project_name\"]:\n        parm = container.parm(name)\n        if not parm:\n            continue\n        data[name] = parm.eval()\n\n    # Backwards compatibility pre-schemas for containers\n    data[\"schema\"] = data.get(\"schema\", \"openpype:container-1.0\")\n\n    # Append transient data\n    data[\"objectName\"] = container.path()\n    data[\"node\"] = container\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html","title":"plugin","text":"<p>Houdini specific AYON/Pyblish plugin definitions.</p>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniContextPlugin","title":"<code>HoudiniContextPlugin</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Base class for Houdini context publish plugins.</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>class HoudiniContextPlugin(pyblish.api.ContextPlugin):\n    \"\"\"Base class for Houdini context publish plugins.\"\"\"\n\n    hosts = [\"houdini\"]\n    settings_category = SETTINGS_CATEGORY\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniCreator","title":"<code>HoudiniCreator</code>","text":"<p>               Bases: <code>Creator</code>, <code>HoudiniCreatorBase</code></p> <p>Base class for most of the Houdini creator plugins.</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>class HoudiniCreator(Creator, HoudiniCreatorBase):\n    \"\"\"Base class for most of the Houdini creator plugins.\"\"\"\n    selected_nodes = []\n    settings_name = None\n    add_publish_button = False\n\n    settings_category = SETTINGS_CATEGORY\n\n    def create(self, product_name, instance_data, pre_create_data):\n        try:\n            self.selected_nodes = []\n\n            if pre_create_data.get(\"use_selection\"):\n                self.selected_nodes = hou.selectedNodes()\n\n            # Get the node type and remove it from the data, not needed\n            node_type = instance_data.pop(\"node_type\", None)\n            if node_type is None:\n                node_type = \"geometry\"\n\n            folder_path = instance_data[\"folderPath\"]\n\n            instance_node = self.create_instance_node(\n                folder_path,\n                product_name,\n                \"/out\",\n                node_type,\n                pre_create_data\n            )\n\n            self.customize_node_look(instance_node)\n\n            instance_data[\"instance_node\"] = instance_node.path()\n            instance_data[\"instance_id\"] = instance_node.path()\n            instance_data[\"families\"] = self.get_publish_families()\n            instance = CreatedInstance(\n                self.product_type,\n                product_name,\n                instance_data,\n                self)\n            self._add_instance_to_context(instance)\n            self.imprint(instance_node, instance.data_to_store())\n\n            if self.add_publish_button:\n                add_self_publish_button(instance_node)\n\n            return instance\n\n        except hou.Error as exc:\n            raise CreatorError(f\"Creator error: {exc}\") from exc\n\n    def lock_parameters(self, node, parameters):\n        \"\"\"Lock list of specified parameters on the node.\n\n        Args:\n            node (hou.Node): Houdini node to lock parameters on.\n            parameters (list of str): List of parameter names.\n\n        \"\"\"\n        for name in parameters:\n            try:\n                parm = node.parm(name)\n                parm.lock(True)\n            except AttributeError:\n                self.log.debug(\"missing lock pattern {}\".format(name))\n\n    def collect_instances(self):\n        # cache instances  if missing\n        self.cache_instance_data(self.collection_shared_data)\n        for instance in self.collection_shared_data[\n                \"houdini_cached_instances\"].get(self.identifier, []):\n\n            node_data = read(instance)\n\n            # Node paths are always the full node path since that is unique\n            # Because it's the node's path it's not written into attributes\n            # but explicitly collected\n            node_path = instance.path()\n            node_data[\"instance_id\"] = node_path\n            node_data[\"instance_node\"] = node_path\n            node_data[\"families\"] = self.get_publish_families()\n            if \"AYON_productName\" in node_data:\n                node_data[\"productName\"] = node_data.pop(\"AYON_productName\")\n\n            created_instance = CreatedInstance.from_existing(\n                node_data, self\n            )\n            self._add_instance_to_context(created_instance)\n\n    def update_instances(self, update_list):\n        for created_inst, changes in update_list:\n            instance_node = hou.node(created_inst.get(\"instance_node\"))\n            new_values = {\n                key: changes[key].new_value\n                for key in changes.changed_keys\n            }\n            # Update parm templates and values\n            self.imprint(\n                instance_node,\n                new_values,\n                update=True\n            )\n\n    def imprint(self, node, values, update=False):\n        # Never store instance node and instance id since that data comes\n        # from the node's path\n        if \"productName\" in values:\n            values[\"AYON_productName\"] = values.pop(\"productName\")\n        values.pop(\"instance_node\", None)\n        values.pop(\"instance_id\", None)\n        values.pop(\"families\", None)\n        imprint(node, values, update=update)\n\n    def remove_instances(self, instances):\n        \"\"\"Remove specified instance from the scene.\n\n        This is only removing `id` parameter so instance is no longer\n        instance, because it might contain valuable data for artist.\n\n        \"\"\"\n        for instance in instances:\n            instance_node = hou.node(instance.data.get(\"instance_node\"))\n            if instance_node:\n                instance_node.destroy()\n\n            self._remove_instance_from_context(instance)\n\n    def get_pre_create_attr_defs(self):\n        return [\n            BoolDef(\"use_selection\", default=True, label=\"Use selection\")\n        ]\n\n    @staticmethod\n    def customize_node_look(\n            node, color=None,\n            shape=\"chevron_down\"):\n        \"\"\"Set custom look for instance nodes.\n\n        Args:\n            node (hou.Node): Node to set look.\n            color (hou.Color, Optional): Color of the node.\n            shape (str, Optional): Shape name of the node.\n\n        Returns:\n            None\n\n        \"\"\"\n        if not color:\n            color = hou.Color((0.616, 0.871, 0.769))\n        node.setUserData('nodeshape', shape)\n        node.setColor(color)\n\n    def get_publish_families(self):\n        \"\"\"Return families for the instances of this creator.\n\n        Allow a Creator to define multiple families so that a creator can\n        e.g. specify `usd` and `usdrop`.\n\n        There is no need to override this method if you only have the\n        primary family defined by the `product_type` property as that will\n        always be set.\n\n        Returns:\n            List[str]: families for instances of this creator\n        \"\"\"\n        return []\n\n    def get_network_categories(self):\n        \"\"\"Return in which network view type this creator should show.\n\n        The node type categories returned here will be used to define where\n        the creator will show up in the TAB search for nodes in Houdini's\n        Network View.\n\n        This can be overridden in inherited classes to define where that\n        particular Creator should be visible in the TAB search.\n\n        Returns:\n            list: List of houdini node type categories\n\n        \"\"\"\n        return [hou.ropNodeTypeCategory()]\n\n    def apply_settings(self, project_settings):\n        \"\"\"Method called on initialization of plugin to apply settings.\"\"\"\n\n        # Apply General Settings\n        houdini_general_settings = project_settings[\"houdini\"][\"general\"]\n        self.add_publish_button = houdini_general_settings.get(\n            \"add_self_publish_button\", False)\n\n        # Apply Creator Settings\n        settings_name = self.settings_name\n        if settings_name is None:\n            settings_name = self.__class__.__name__\n\n        settings = project_settings[\"houdini\"][\"create\"]\n        settings = settings.get(settings_name)\n        if settings is None:\n            self.log.debug(\n                \"No settings found for {}\".format(self.__class__.__name__)\n            )\n            return\n\n        for key, value in settings.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniCreator.apply_settings","title":"<code>apply_settings(project_settings)</code>","text":"<p>Method called on initialization of plugin to apply settings.</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>def apply_settings(self, project_settings):\n    \"\"\"Method called on initialization of plugin to apply settings.\"\"\"\n\n    # Apply General Settings\n    houdini_general_settings = project_settings[\"houdini\"][\"general\"]\n    self.add_publish_button = houdini_general_settings.get(\n        \"add_self_publish_button\", False)\n\n    # Apply Creator Settings\n    settings_name = self.settings_name\n    if settings_name is None:\n        settings_name = self.__class__.__name__\n\n    settings = project_settings[\"houdini\"][\"create\"]\n    settings = settings.get(settings_name)\n    if settings is None:\n        self.log.debug(\n            \"No settings found for {}\".format(self.__class__.__name__)\n        )\n        return\n\n    for key, value in settings.items():\n        setattr(self, key, value)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniCreator.customize_node_look","title":"<code>customize_node_look(node, color=None, shape='chevron_down')</code>  <code>staticmethod</code>","text":"<p>Set custom look for instance nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to set look.</p> required <code>color</code> <code>(Color, Optional)</code> <p>Color of the node.</p> <code>None</code> <code>shape</code> <code>(str, Optional)</code> <p>Shape name of the node.</p> <code>'chevron_down'</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>@staticmethod\ndef customize_node_look(\n        node, color=None,\n        shape=\"chevron_down\"):\n    \"\"\"Set custom look for instance nodes.\n\n    Args:\n        node (hou.Node): Node to set look.\n        color (hou.Color, Optional): Color of the node.\n        shape (str, Optional): Shape name of the node.\n\n    Returns:\n        None\n\n    \"\"\"\n    if not color:\n        color = hou.Color((0.616, 0.871, 0.769))\n    node.setUserData('nodeshape', shape)\n    node.setColor(color)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniCreator.get_network_categories","title":"<code>get_network_categories()</code>","text":"<p>Return in which network view type this creator should show.</p> <p>The node type categories returned here will be used to define where the creator will show up in the TAB search for nodes in Houdini's Network View.</p> <p>This can be overridden in inherited classes to define where that particular Creator should be visible in the TAB search.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of houdini node type categories</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>def get_network_categories(self):\n    \"\"\"Return in which network view type this creator should show.\n\n    The node type categories returned here will be used to define where\n    the creator will show up in the TAB search for nodes in Houdini's\n    Network View.\n\n    This can be overridden in inherited classes to define where that\n    particular Creator should be visible in the TAB search.\n\n    Returns:\n        list: List of houdini node type categories\n\n    \"\"\"\n    return [hou.ropNodeTypeCategory()]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniCreator.get_publish_families","title":"<code>get_publish_families()</code>","text":"<p>Return families for the instances of this creator.</p> <p>Allow a Creator to define multiple families so that a creator can e.g. specify <code>usd</code> and <code>usdrop</code>.</p> <p>There is no need to override this method if you only have the primary family defined by the <code>product_type</code> property as that will always be set.</p> <p>Returns:</p> Type Description <p>List[str]: families for instances of this creator</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>def get_publish_families(self):\n    \"\"\"Return families for the instances of this creator.\n\n    Allow a Creator to define multiple families so that a creator can\n    e.g. specify `usd` and `usdrop`.\n\n    There is no need to override this method if you only have the\n    primary family defined by the `product_type` property as that will\n    always be set.\n\n    Returns:\n        List[str]: families for instances of this creator\n    \"\"\"\n    return []\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniCreator.lock_parameters","title":"<code>lock_parameters(node, parameters)</code>","text":"<p>Lock list of specified parameters on the node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Houdini node to lock parameters on.</p> required <code>parameters</code> <code>list of str</code> <p>List of parameter names.</p> required Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>def lock_parameters(self, node, parameters):\n    \"\"\"Lock list of specified parameters on the node.\n\n    Args:\n        node (hou.Node): Houdini node to lock parameters on.\n        parameters (list of str): List of parameter names.\n\n    \"\"\"\n    for name in parameters:\n        try:\n            parm = node.parm(name)\n            parm.lock(True)\n        except AttributeError:\n            self.log.debug(\"missing lock pattern {}\".format(name))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniCreator.remove_instances","title":"<code>remove_instances(instances)</code>","text":"<p>Remove specified instance from the scene.</p> <p>This is only removing <code>id</code> parameter so instance is no longer instance, because it might contain valuable data for artist.</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>def remove_instances(self, instances):\n    \"\"\"Remove specified instance from the scene.\n\n    This is only removing `id` parameter so instance is no longer\n    instance, because it might contain valuable data for artist.\n\n    \"\"\"\n    for instance in instances:\n        instance_node = hou.node(instance.data.get(\"instance_node\"))\n        if instance_node:\n            instance_node.destroy()\n\n        self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniCreatorBase","title":"<code>HoudiniCreatorBase</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>class HoudiniCreatorBase(object):\n    @staticmethod\n    def cache_instance_data(shared_data):\n        \"\"\"Cache instances for Creators to shared data.\n\n        Create `houdini_cached_instances` key when needed in shared data and\n        fill it with all collected instances from the scene under its\n        respective creator identifiers.\n\n        Create `houdini_cached_legacy_instance` key for any legacy instances\n        detected in the scene as instances per family.\n\n        Args:\n            Dict[str, Any]: Shared data.\n\n        \"\"\"\n        if shared_data.get(\"houdini_cached_instances\") is None:\n            cache = dict()\n            cache_legacy = dict()\n\n            nodes = []\n            for id_type in [AYON_INSTANCE_ID, AVALON_INSTANCE_ID]:\n                nodes.extend(lsattr(\"id\", id_type))\n            for node in nodes:\n\n                creator_identifier_parm = node.parm(\"creator_identifier\")\n                if creator_identifier_parm:\n                    # creator instance\n                    creator_id = creator_identifier_parm.eval()\n                    cache.setdefault(creator_id, []).append(node)\n\n                else:\n                    # legacy instance\n                    family_parm = node.parm(\"family\")\n                    if not family_parm:\n                        # must be a broken instance\n                        continue\n\n                    family = family_parm.eval()\n                    cache_legacy.setdefault(family, []).append(node)\n\n            shared_data[\"houdini_cached_instances\"] = cache\n            shared_data[\"houdini_cached_legacy_instance\"] = cache_legacy\n\n        return shared_data\n\n    @staticmethod\n    def create_instance_node(\n        folder_path,\n        node_name,\n        parent,\n        node_type=\"geometry\",\n        pre_create_data=None\n    ):\n        \"\"\"Create node representing instance.\n\n        Arguments:\n            folder_path (str): Folder path.\n            node_name (str): Name of the new node.\n            parent (str): Name of the parent node.\n            node_type (str, optional): Type of the node.\n            pre_create_data (Optional[Dict]): Pre create data.\n\n        Returns:\n            hou.Node: Newly created instance node.\n\n        \"\"\"\n        parent_node = hou.node(parent)\n        instance_node = parent_node.createNode(\n            node_type, node_name=node_name)\n        instance_node.moveToGoodPosition()\n        return instance_node\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniCreatorBase.cache_instance_data","title":"<code>cache_instance_data(shared_data)</code>  <code>staticmethod</code>","text":"<p>Cache instances for Creators to shared data.</p> <p>Create <code>houdini_cached_instances</code> key when needed in shared data and fill it with all collected instances from the scene under its respective creator identifiers.</p> <p>Create <code>houdini_cached_legacy_instance</code> key for any legacy instances detected in the scene as instances per family.</p> <p>Parameters:</p> Name Type Description Default <code>Dict[str,</code> <code>Any]</code> <p>Shared data.</p> required Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>@staticmethod\ndef cache_instance_data(shared_data):\n    \"\"\"Cache instances for Creators to shared data.\n\n    Create `houdini_cached_instances` key when needed in shared data and\n    fill it with all collected instances from the scene under its\n    respective creator identifiers.\n\n    Create `houdini_cached_legacy_instance` key for any legacy instances\n    detected in the scene as instances per family.\n\n    Args:\n        Dict[str, Any]: Shared data.\n\n    \"\"\"\n    if shared_data.get(\"houdini_cached_instances\") is None:\n        cache = dict()\n        cache_legacy = dict()\n\n        nodes = []\n        for id_type in [AYON_INSTANCE_ID, AVALON_INSTANCE_ID]:\n            nodes.extend(lsattr(\"id\", id_type))\n        for node in nodes:\n\n            creator_identifier_parm = node.parm(\"creator_identifier\")\n            if creator_identifier_parm:\n                # creator instance\n                creator_id = creator_identifier_parm.eval()\n                cache.setdefault(creator_id, []).append(node)\n\n            else:\n                # legacy instance\n                family_parm = node.parm(\"family\")\n                if not family_parm:\n                    # must be a broken instance\n                    continue\n\n                family = family_parm.eval()\n                cache_legacy.setdefault(family, []).append(node)\n\n        shared_data[\"houdini_cached_instances\"] = cache\n        shared_data[\"houdini_cached_legacy_instance\"] = cache_legacy\n\n    return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniCreatorBase.create_instance_node","title":"<code>create_instance_node(folder_path, node_name, parent, node_type='geometry', pre_create_data=None)</code>  <code>staticmethod</code>","text":"<p>Create node representing instance.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>node_name</code> <code>str</code> <p>Name of the new node.</p> required <code>parent</code> <code>str</code> <p>Name of the parent node.</p> required <code>node_type</code> <code>str</code> <p>Type of the node.</p> <code>'geometry'</code> <code>pre_create_data</code> <code>Optional[Dict]</code> <p>Pre create data.</p> <code>None</code> <p>Returns:</p> Type Description <p>hou.Node: Newly created instance node.</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>@staticmethod\ndef create_instance_node(\n    folder_path,\n    node_name,\n    parent,\n    node_type=\"geometry\",\n    pre_create_data=None\n):\n    \"\"\"Create node representing instance.\n\n    Arguments:\n        folder_path (str): Folder path.\n        node_name (str): Name of the new node.\n        parent (str): Name of the parent node.\n        node_type (str, optional): Type of the node.\n        pre_create_data (Optional[Dict]): Pre create data.\n\n    Returns:\n        hou.Node: Newly created instance node.\n\n    \"\"\"\n    parent_node = hou.node(parent)\n    instance_node = parent_node.createNode(\n        node_type, node_name=node_name)\n    instance_node.moveToGoodPosition()\n    return instance_node\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniExtractorPlugin","title":"<code>HoudiniExtractorPlugin</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Base class for Houdini extract plugins.</p> Note <p>The <code>HoudiniExtractorPlugin</code> is a subclass of <code>publish.Extractor</code>,     which in turn is a subclass of <code>pyblish.api.InstancePlugin</code>. Should there be a requirement to create an extractor that operates     as a context plugin, it would be beneficial to incorporate     the functionalities present in <code>publish.Extractor</code>.</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>class HoudiniExtractorPlugin(publish.Extractor):\n    \"\"\"Base class for Houdini extract plugins.\n\n    Note:\n        The `HoudiniExtractorPlugin` is a subclass of `publish.Extractor`,\n            which in turn is a subclass of `pyblish.api.InstancePlugin`.\n        Should there be a requirement to create an extractor that operates\n            as a context plugin, it would be beneficial to incorporate\n            the functionalities present in `publish.Extractor`.\n    \"\"\"\n\n    hosts = [\"houdini\"]\n    settings_category = SETTINGS_CATEGORY\n\n    def render_rop(self, instance: pyblish.api.Instance):\n        \"\"\"Render the ROP node of the instance.\n\n        If `instance.data[\"frames_to_fix\"]` is set and is not empty it will\n        be interpreted as a set of frames that will be rendered instead of the\n        full rop nodes frame range.\n\n        Only `instance.data[\"instance_node\"]` is required.\n        \"\"\"\n        # Log the start of the render\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        self.log.debug(f\"Rendering {rop_node.path()}\")\n\n        frames_to_fix = clique.parse(instance.data.get(\"frames_to_fix\", \"\"),\n                                     \"{ranges}\")\n        if len(set(frames_to_fix)) &lt; 2:\n            render_rop(rop_node)\n            return\n\n        # Render only frames to fix\n        for frame_range in frames_to_fix.separate():\n            frame_range = list(frame_range)\n            first_frame = int(frame_range[0])\n            last_frame = int(frame_range[-1])\n            self.log.debug(\n                f\"Rendering frames to fix [{first_frame}, {last_frame}]\"\n            )\n            # for step to be 1 since clique doesn't support steps.\n            frame_range = (first_frame, last_frame, 1)\n            render_rop(rop_node, frame_range=frame_range)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniExtractorPlugin.render_rop","title":"<code>render_rop(instance)</code>","text":"<p>Render the ROP node of the instance.</p> <p>If <code>instance.data[\"frames_to_fix\"]</code> is set and is not empty it will be interpreted as a set of frames that will be rendered instead of the full rop nodes frame range.</p> <p>Only <code>instance.data[\"instance_node\"]</code> is required.</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>def render_rop(self, instance: pyblish.api.Instance):\n    \"\"\"Render the ROP node of the instance.\n\n    If `instance.data[\"frames_to_fix\"]` is set and is not empty it will\n    be interpreted as a set of frames that will be rendered instead of the\n    full rop nodes frame range.\n\n    Only `instance.data[\"instance_node\"]` is required.\n    \"\"\"\n    # Log the start of the render\n    rop_node = hou.node(instance.data[\"instance_node\"])\n    self.log.debug(f\"Rendering {rop_node.path()}\")\n\n    frames_to_fix = clique.parse(instance.data.get(\"frames_to_fix\", \"\"),\n                                 \"{ranges}\")\n    if len(set(frames_to_fix)) &lt; 2:\n        render_rop(rop_node)\n        return\n\n    # Render only frames to fix\n    for frame_range in frames_to_fix.separate():\n        frame_range = list(frame_range)\n        first_frame = int(frame_range[0])\n        last_frame = int(frame_range[-1])\n        self.log.debug(\n            f\"Rendering frames to fix [{first_frame}, {last_frame}]\"\n        )\n        # for step to be 1 since clique doesn't support steps.\n        frame_range = (first_frame, last_frame, 1)\n        render_rop(rop_node, frame_range=frame_range)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniInstancePlugin","title":"<code>HoudiniInstancePlugin</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Base class for Houdini instance publish plugins.</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>class HoudiniInstancePlugin(pyblish.api.InstancePlugin):\n    \"\"\"Base class for Houdini instance publish plugins.\"\"\"\n\n    hosts = [\"houdini\"]\n    settings_category = SETTINGS_CATEGORY\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/plugin.html#client.ayon_houdini.api.plugin.HoudiniLoader","title":"<code>HoudiniLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Base class for Houdini load plugins.</p> Source code in <code>client/ayon_houdini/api/plugin.py</code> <pre><code>class HoudiniLoader(load.LoaderPlugin):\n    \"\"\"Base class for Houdini load plugins.\"\"\"\n\n    hosts = [\"houdini\"]\n    settings_category = SETTINGS_CATEGORY\n    use_ayon_entity_uri = False\n    collapse_paths_to_root_vars = False\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Prepare collapsible variable mapping using entries in `os.environ`\n        # that are set to the project root paths\n        cls.collapse_paths_to_root_vars: bool = (\n            project_settings[\"houdini\"][\"load\"]\n            .get(\"collapse_path_to_project_root_vars\", False)\n        )\n\n        super().apply_settings(project_settings)\n\n    @classmethod\n    def _get_collapsible_vars(cls) -&gt; Dict[str, str]:\n        \"\"\"Return which variables keys may be collapsed to if path starts with\n        the values.\"\"\"\n        collapsible_vars = {}\n        for key, value in os.environ.items():\n            if key.startswith(\"AYON_PROJECT_ROOT_\"):\n                if not value:\n                    continue\n                collapsible_vars[key] = value.replace(\"\\\\\", \"/\")\n\n        # Sort by length to ensure that the longest matching key is first\n        # so that the nearest matching root is used\n        return {\n            key: value\n            for key, value\n            in sorted(collapsible_vars.items(),\n                      key=lambda x: len(x[1]),\n                      reverse=True)\n        }\n\n    @classmethod\n    def filepath_from_context(cls, context):\n        if cls.use_ayon_entity_uri:\n            return get_ayon_entity_uri_from_representation_context(context)\n\n        path = super().filepath_from_context(context)\n\n        # Remap project roots to the collapsible path variables\n        if cls.collapse_paths_to_root_vars:\n            collapsible_vars = cls._get_collapsible_vars()\n            if collapsible_vars:\n                match_path = path.replace(\"\\\\\", \"/\")\n                for key, value in collapsible_vars.items():\n                    if match_path.startswith(value):\n                        # Replace start of string with the key\n                        path = f\"${key}\" + path[len(value):]\n                        break\n\n        return path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/shelves.html","title":"shelves","text":""},{"location":"autoapi/client/ayon_houdini/api/shelves.html#client.ayon_houdini.api.shelves.generate_shelves","title":"<code>generate_shelves()</code>","text":"<p>This function generates complete shelves from shelf set to tools in Houdini from openpype project settings houdini shelf definition.</p> Source code in <code>client/ayon_houdini/api/shelves.py</code> <pre><code>def generate_shelves():\n    \"\"\"This function generates complete shelves from shelf set to tools\n    in Houdini from openpype project settings houdini shelf definition.\n    \"\"\"\n    current_os = platform.system().lower()\n\n    # load configuration of houdini shelves\n    project_name = get_current_project_name()\n    project_settings = get_project_settings(project_name)\n    shelves_configs = project_settings[\"houdini\"][\"shelves\"]\n\n    if not shelves_configs:\n        log.debug(\"No custom shelves found in project settings.\")\n        return\n\n    # Get Template data\n    template_data = get_current_context_template_data_with_entity_attrs()\n\n    for config in shelves_configs:\n        selected_option = config[\"options\"]\n        shelf_set_config = config[selected_option]\n\n        shelf_set_filepath = shelf_set_config.get('shelf_set_source_path')\n        if shelf_set_filepath:\n            shelf_set_os_filepath = shelf_set_filepath[current_os]\n            if shelf_set_os_filepath:\n                shelf_set_os_filepath = get_path_using_template_data(\n                    shelf_set_os_filepath, template_data\n                )\n                if not os.path.isfile(shelf_set_os_filepath):\n                    log.error(\"Shelf path doesn't exist - \"\n                              \"{}\".format(shelf_set_os_filepath))\n                    continue\n\n                hou.shelves.loadFile(shelf_set_os_filepath)\n                continue\n\n        shelf_set_name = shelf_set_config.get('shelf_set_name')\n        if not shelf_set_name:\n            log.warning(\"No name found in shelf set definition.\")\n            continue\n\n        shelves_definition = shelf_set_config.get('shelf_definition')\n        if not shelves_definition:\n            log.debug(\n                \"No shelf definition found for shelf set named '{}'\".format(\n                    shelf_set_name\n                )\n            )\n            continue\n\n        shelf_set = get_or_create_shelf_set(shelf_set_name)\n        for shelf_definition in shelves_definition:\n            shelf_name = shelf_definition.get('shelf_name')\n            if not shelf_name:\n                log.warning(\"No name found in shelf definition.\")\n                continue\n\n            shelf = get_or_create_shelf(shelf_name)\n\n            if not shelf_definition.get('tools_list'):\n                log.debug(\n                    \"No tool definition found for shelf named {}\".format(\n                        shelf_name\n                    )\n                )\n                continue\n\n            mandatory_attributes = {'label', 'script'}\n            for tool_definition in shelf_definition.get('tools_list'):\n                # We verify that the name and script attributes of the tool\n                # are set\n                if not all(\n                    tool_definition[key] for key in mandatory_attributes\n                ):\n                    log.warning(\n                        \"You need to specify at least the name and the \"\n                        \"script path of the tool.\")\n                    continue\n\n                tool = get_or_create_tool(\n                    tool_definition, shelf, template_data\n                )\n\n                if not tool:\n                    continue\n\n                # Add the tool to the shelf if not already in it\n                if tool not in shelf.tools():\n                    shelf.setTools(list(shelf.tools()) + [tool])\n\n            # Add the shelf in the shelf set if not already in it\n            if shelf not in shelf_set.shelves():\n                shelf_set.setShelves(shelf_set.shelves() + (shelf,))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/shelves.html#client.ayon_houdini.api.shelves.get_or_create_shelf","title":"<code>get_or_create_shelf(shelf_label)</code>","text":"<p>This function verifies if the shelf label exists. If not, creates a new shelf.</p> <p>Parameters:</p> Name Type Description Default <code>shelf_label</code> <code>str</code> <p>The label of the shelf</p> required <p>Returns:</p> Type Description <p>hou.Shelf: The shelf existing or the new one</p> Source code in <code>client/ayon_houdini/api/shelves.py</code> <pre><code>def get_or_create_shelf(shelf_label):\n    \"\"\"This function verifies if the shelf label exists. If not, creates\n    a new shelf.\n\n    Arguments:\n        shelf_label (str): The label of the shelf\n\n    Returns:\n        hou.Shelf: The shelf existing or the new one\n    \"\"\"\n    all_shelves = hou.shelves.shelves().values()\n\n    shelf = next((s for s in all_shelves if s.label() == shelf_label), None)\n    if shelf:\n        return shelf\n\n    shelf_name = shelf_label.replace(' ', '_').lower()\n    new_shelf = hou.shelves.newShelf(\n        name=shelf_name,\n        label=shelf_label\n    )\n    return new_shelf\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/shelves.html#client.ayon_houdini.api.shelves.get_or_create_shelf_set","title":"<code>get_or_create_shelf_set(shelf_set_label)</code>","text":"<p>This function verifies if the shelf set label exists. If not, creates a new shelf set.</p> <p>Parameters:</p> Name Type Description Default <code>shelf_set_label</code> <code>str</code> <p>The label of the shelf set</p> required <p>Returns:</p> Type Description <p>hou.ShelfSet: The shelf set existing or the new one</p> Source code in <code>client/ayon_houdini/api/shelves.py</code> <pre><code>def get_or_create_shelf_set(shelf_set_label):\n    \"\"\"This function verifies if the shelf set label exists. If not,\n    creates a new shelf set.\n\n    Arguments:\n        shelf_set_label (str): The label of the shelf set\n\n    Returns:\n        hou.ShelfSet: The shelf set existing or the new one\n    \"\"\"\n    all_shelves_sets = hou.shelves.shelfSets().values()\n\n    shelf_set = next((shelf for shelf in all_shelves_sets if\n                      shelf.label() == shelf_set_label), None)\n    if shelf_set:\n        return shelf_set\n\n    shelf_set_name = shelf_set_label.replace(' ', '_').lower()\n    new_shelf_set = hou.shelves.newShelfSet(\n        name=shelf_set_name,\n        label=shelf_set_label\n    )\n    return new_shelf_set\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/shelves.html#client.ayon_houdini.api.shelves.get_or_create_tool","title":"<code>get_or_create_tool(tool_definition, shelf, template_data)</code>","text":"<p>This function verifies if the tool exists and updates it. If not, creates a new one.</p> <p>Parameters:</p> Name Type Description Default <code>tool_definition</code> <code>dict</code> <p>Dict with label, script, icon and help</p> required <code>shelf</code> <code>Shelf</code> <p>The parent shelf of the tool</p> required <p>Returns:</p> Type Description <p>hou.Tool: The tool updated or the new one</p> Source code in <code>client/ayon_houdini/api/shelves.py</code> <pre><code>def get_or_create_tool(tool_definition, shelf, template_data):\n    \"\"\"This function verifies if the tool exists and updates it. If not,\n    creates a new one.\n\n    Arguments:\n        tool_definition (dict): Dict with label, script, icon and help\n        shelf (hou.Shelf): The parent shelf of the tool\n\n    Returns:\n        hou.Tool: The tool updated or the new one\n    \"\"\"\n\n    tool_label = tool_definition.get(\"label\")\n    if not tool_label:\n        log.warning(\"Skipped shelf without label\")\n        return\n\n    script_path = tool_definition[\"script\"]\n    script_path = get_path_using_template_data(script_path, template_data)\n    if not script_path or not os.path.exists(script_path):\n        log.warning(\"This path doesn't exist - {}\".format(script_path))\n        return\n\n    icon_path = tool_definition[\"icon\"]\n    if icon_path:\n        icon_path = get_path_using_template_data(icon_path, template_data)\n        tool_definition[\"icon\"] = icon_path\n\n    existing_tools = shelf.tools()\n    existing_tool = next(\n        (tool for tool in existing_tools if tool.label() == tool_label),\n        None\n    )\n\n    with open(script_path) as stream:\n        script = stream.read()\n\n    tool_definition[\"script\"] = script\n\n    if existing_tool:\n        tool_definition.pop(\"label\", None)\n        existing_tool.setData(**tool_definition)\n        return existing_tool\n\n    tool_name = re.sub(r\"[^\\w\\d]+\", \"_\", tool_label).lower()\n    return hou.shelves.newTool(name=tool_name, **tool_definition)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html","title":"usd","text":"<p>Houdini-specific USD Library functions.</p>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.add_usd_output_processor","title":"<code>add_usd_output_processor(ropnode, processor)</code>","text":"<p>Add USD Output Processor to USD Rop node.</p> <p>Parameters:</p> Name Type Description Default <code>ropnode</code> <code>RopNode</code> <p>The USD Rop node.</p> required <code>processor</code> <code>str</code> <p>The output processor name. This is the basename of the python file that contains the Houdini USD Output Processor.</p> required Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>def add_usd_output_processor(ropnode, processor):\n    \"\"\"Add USD Output Processor to USD Rop node.\n\n    Args:\n        ropnode (hou.RopNode): The USD Rop node.\n        processor (str): The output processor name. This is the basename of\n            the python file that contains the Houdini USD Output Processor.\n\n    \"\"\"\n\n    import loputils\n\n    loputils.handleOutputProcessorAdd(\n        {\n            \"node\": ropnode,\n            \"parm\": ropnode.parm(\"outputprocessors\"),\n            \"script_value\": processor,\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.get_ayon_entity_uri_from_representation_context","title":"<code>get_ayon_entity_uri_from_representation_context(context)</code>","text":"<p>Resolve AYON Entity URI from representation context.</p> Note <p>The representation context is the <code>get_representation_context</code> dict containing the <code>project</code>, <code>folder,</code>representation<code>and so forth. It is not the representation entity</code>context` key.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>The representation context.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Unable to resolve to a single valid URI.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The AYON entity URI.</p> Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>def get_ayon_entity_uri_from_representation_context(context: dict) -&gt; str:\n    \"\"\"Resolve AYON Entity URI from representation context.\n\n    Note:\n        The representation context is the `get_representation_context` dict\n        containing the `project`, `folder, `representation` and so forth.\n        It is not the representation entity `context` key.\n\n    Arguments:\n        context (dict): The representation context.\n\n    Raises:\n        RuntimeError: Unable to resolve to a single valid URI.\n\n    Returns:\n        str: The AYON entity URI.\n\n    \"\"\"\n    project_name = context[\"project\"][\"name\"]\n    representation_id = context[\"representation\"][\"id\"]\n    response = ayon_api.post(\n        f\"projects/{project_name}/uris\",\n        entityType=\"representation\",\n        ids=[representation_id])\n    if response.status_code != 200:\n        raise RuntimeError(\n            f\"Unable to resolve AYON entity URI for '{project_name}' \"\n            f\"representation id '{representation_id}': {response.text}\"\n        )\n    uris = response.data[\"uris\"]\n    if len(uris) != 1:\n        raise RuntimeError(\n            f\"Unable to resolve AYON entity URI for '{project_name}' \"\n            f\"representation id '{representation_id}' to single URI. \"\n            f\"Received data: {response.data}\"\n        )\n    return uris[0][\"uri\"]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.get_configured_save_layers","title":"<code>get_configured_save_layers(usd_rop, strip_above_layer_break=True)</code>","text":"<p>Retrieve the layer save paths from a USD ROP.</p> <p>Parameters:</p> Name Type Description Default <code>usdrop</code> <code>RopNode</code> <p>USD Rop Node</p> required <code>strip_above_layer_break</code> <code>Optional[bool]</code> <p>Whether to exclude any layers that are above layer breaks. This defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>List[Sdf.Layer]: The layers with configured save paths.</p> Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>def get_configured_save_layers(usd_rop, strip_above_layer_break=True):\n    \"\"\"Retrieve the layer save paths from a USD ROP.\n\n    Arguments:\n        usdrop (hou.RopNode): USD Rop Node\n        strip_above_layer_break (Optional[bool]): Whether to exclude any\n            layers that are above layer breaks. This defaults to True.\n\n    Returns:\n        List[Sdf.Layer]: The layers with configured save paths.\n\n    \"\"\"\n\n    lop_node = get_usd_rop_loppath(usd_rop)\n    stage = lop_node.stage(apply_viewport_overrides=False)\n    if not stage:\n        raise RuntimeError(\n            \"No valid USD stage for ROP node: \" \"%s\" % usd_rop.path()\n        )\n\n    root_layer = stage.GetRootLayer()\n\n    if strip_above_layer_break:\n        layers_above_layer_break = set(lop_node.layersAboveLayerBreak())\n    else:\n        layers_above_layer_break = set()\n\n    save_layers = []\n    for layer in iter_layer_recursive(root_layer):\n        if (\n            strip_above_layer_break and\n            layer.identifier in layers_above_layer_break\n        ):\n            continue\n\n        save_path = get_layer_save_path(layer)\n        if save_path is not None:\n            save_layers.append(layer)\n\n    return save_layers\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.get_layer_save_path","title":"<code>get_layer_save_path(layer, expand_string=True)</code>","text":"<p>Get custom HoudiniLayerInfo-&gt;HoudiniSavePath from SdfLayer.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The Layer to retrieve the save pah data from.</p> required <code>expand_string</code> <code>bool</code> <p>Whether to expand any houdini vars in the save path before computing the absolute path.</p> <code>True</code> <p>Returns:</p> Type Description <p>str or None: Path to save to when data exists.</p> Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>def get_layer_save_path(layer, expand_string=True):\n    \"\"\"Get custom HoudiniLayerInfo-&gt;HoudiniSavePath from SdfLayer.\n\n    Args:\n        layer (pxr.Sdf.Layer): The Layer to retrieve the save pah data from.\n        expand_string (bool): Whether to expand any houdini vars in the save\n            path before computing the absolute path.\n\n    Returns:\n        str or None: Path to save to when data exists.\n\n    \"\"\"\n    hou_layer_info = layer.rootPrims.get(\"HoudiniLayerInfo\")\n    if not hou_layer_info:\n        return\n\n    save_path = hou_layer_info.customData.get(\"HoudiniSavePath\", None)\n    if save_path:\n        # Unfortunately this doesn't actually resolve the full absolute path\n        if expand_string:\n            save_path = hou.text.expandString(save_path)\n        return layer.ComputeAbsolutePath(save_path)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.get_referenced_layers","title":"<code>get_referenced_layers(layer)</code>","text":"<p>Return SdfLayers for all external references of the current layer</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The Layer to retrieve the save pah data from.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of pxr.Sdf.Layer that are external references to this layer</p> Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>def get_referenced_layers(layer):\n    \"\"\"Return SdfLayers for all external references of the current layer\n\n    Args:\n        layer (pxr.Sdf.Layer): The Layer to retrieve the save pah data from.\n\n    Returns:\n        list: List of pxr.Sdf.Layer that are external references to this layer\n\n    \"\"\"\n\n    layers = []\n    for layer_id in layer.GetExternalReferences():\n        layer = Sdf.Layer.Find(layer_id)\n        if not layer:\n            # A file may not be in memory and is\n            # referenced from disk. As such it cannot\n            # be found. We will ignore those layers.\n            continue\n\n        layers.append(layer)\n\n    return layers\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.get_schema_type_names","title":"<code>get_schema_type_names(type_name)</code>","text":"<p>Return schema type name for type name and its derived types</p> <p>This can be useful for checking whether a <code>Sdf.PrimSpec</code>'s type name is of a given type or any of its derived types.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The type name, like e.g. 'UsdGeomMesh'</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of schema type names and their derived types.</p> Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>def get_schema_type_names(type_name: str) -&gt; List[str]:\n    \"\"\"Return schema type name for type name and its derived types\n\n    This can be useful for checking whether a `Sdf.PrimSpec`'s type name is of\n    a given type or any of its derived types.\n\n    Args:\n        type_name (str): The type name, like e.g. 'UsdGeomMesh'\n\n    Returns:\n        List[str]: List of schema type names and their derived types.\n\n    \"\"\"\n    schema_registry = Usd.SchemaRegistry\n    type_ = Tf.Type.FindByName(type_name)\n\n    if type_ == Tf.Type.Unknown:\n        type_ = schema_registry.GetTypeFromSchemaTypeName(type_name)\n        if type_ == Tf.Type.Unknown:\n            # Type not found\n            return []\n\n    results = []\n    derived = type_.GetAllDerivedTypes()\n    for derived_type in itertools.chain([type_], derived):\n        schema_type_name = schema_registry.GetSchemaTypeName(derived_type)\n        if schema_type_name:\n            results.append(schema_type_name)\n\n    return results\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.get_usd_render_rop_rendersettings","title":"<code>get_usd_render_rop_rendersettings(rop_node, stage=None, logger=None)</code>","text":"<p>Return the chosen UsdRender.Settings from the stage (if any).</p> <p>Parameters:</p> Name Type Description Default <code>rop_node</code> <code>Node</code> <p>The Houdini USD Render ROP node.</p> required <code>stage</code> <code>Stage</code> <p>The USD stage to find the render settings  in. This is usually the stage from the LOP path the USD Render  ROP node refers to.</p> <code>None</code> <code>logger</code> <code>Logger</code> <p>Logger to log warnings to if no render settings were find in stage.</p> <code>None</code> <p>Returns:</p> Type Description <p>Optional[UsdRender.Settings]: Render Settings.</p> Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>def get_usd_render_rop_rendersettings(rop_node, stage=None, logger=None):\n    \"\"\"Return the chosen UsdRender.Settings from the stage (if any).\n\n    Args:\n        rop_node (hou.Node): The Houdini USD Render ROP node.\n        stage (pxr.Usd.Stage): The USD stage to find the render settings\n             in. This is usually the stage from the LOP path the USD Render\n             ROP node refers to.\n        logger (logging.Logger): Logger to log warnings to if no render\n            settings were find in stage.\n\n    Returns:\n        Optional[UsdRender.Settings]: Render Settings.\n\n    \"\"\"\n    if logger is None:\n        logger = log\n\n    if stage is None:\n        lop_node = get_usd_rop_loppath(rop_node)\n        stage = lop_node.stage()\n\n    path = rop_node.evalParm(\"rendersettings\")\n    if not path:\n        # Default behavior\n        path = \"/Render/rendersettings\"\n\n    prim = stage.GetPrimAtPath(path)\n    if not prim:\n        logger.warning(\"No render settings primitive found at: %s\", path)\n        return\n\n    render_settings = UsdRender.Settings(prim)\n    if not render_settings:\n        logger.warning(\"Prim at %s is not a valid RenderSettings prim.\", path)\n        return\n\n    return render_settings\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.iter_layer_recursive","title":"<code>iter_layer_recursive(layer)</code>","text":"<p>Recursively iterate all 'external' referenced layers</p> Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>def iter_layer_recursive(layer):\n    \"\"\"Recursively iterate all 'external' referenced layers\"\"\"\n\n    layers = get_referenced_layers(layer)\n    traversed = set(layers)  # Avoid recursion to itself (if even possible)\n    traverse = list(layers)\n    for layer in traverse:\n\n        # Include children layers (recursion)\n        children_layers = get_referenced_layers(layer)\n        children_layers = [x for x in children_layers if x not in traversed]\n        traverse.extend(children_layers)\n        traversed.update(children_layers)\n\n        yield layer\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.outputprocessors","title":"<code>outputprocessors(ropnode, processors=tuple(), disable_all_others=True)</code>","text":"<p>Context manager to temporarily add Output Processors to USD ROP node.</p> <p>Parameters:</p> Name Type Description Default <code>ropnode</code> <code>RopNode</code> <p>The USD Rop node.</p> required <code>processors</code> <code>tuple or list</code> <p>The processors to add.</p> <code>tuple()</code> <code>disable_all_others</code> <code>(bool, Optional)</code> <p>Whether to disable all output processors currently on the ROP node that are not in the <code>processors</code> list passed to this function.</p> <code>True</code> Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>@contextlib.contextmanager\ndef outputprocessors(ropnode, processors=tuple(), disable_all_others=True):\n    \"\"\"Context manager to temporarily add Output Processors to USD ROP node.\n\n    Args:\n        ropnode (hou.RopNode): The USD Rop node.\n        processors (tuple or list): The processors to add.\n        disable_all_others (bool, Optional): Whether to disable all\n            output processors currently on the ROP node that are not in the\n            `processors` list passed to this function.\n\n    \"\"\"\n    # TODO: Add support for forcing the correct Order of the processors\n\n    original = []\n    prefix = \"enableoutputprocessor_\"\n    processor_parms = ropnode.globParms(prefix + \"*\")\n    for parm in processor_parms:\n        original.append((parm, parm.eval()))\n\n    if disable_all_others:\n        for parm in processor_parms:\n            parm.set(False)\n\n    added = []\n    for processor in processors:\n\n        parm = ropnode.parm(prefix + processor)\n        if parm:\n            # If processor already exists, just enable it\n            parm.set(True)\n\n        else:\n            # Else add the new processor\n            add_usd_output_processor(ropnode, processor)\n            added.append(processor)\n\n    try:\n        yield\n    finally:\n\n        # Remove newly added processors\n        for processor in added:\n            remove_usd_output_processor(ropnode, processor)\n\n        # Revert to original values\n        for parm, value in original:\n            if parm:\n                parm.set(value)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.remap_paths","title":"<code>remap_paths(rop_node, mapping)</code>","text":"<p>Enable the AyonRemapPaths output processor with provided <code>mapping</code></p> Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>@contextlib.contextmanager\ndef remap_paths(rop_node, mapping):\n    \"\"\"Enable the AyonRemapPaths output processor with provided `mapping`\"\"\"\n    from ayon_houdini.api.lib import parm_values\n\n    if not mapping:\n        # Do nothing\n        yield\n        return\n\n    # Houdini string parms need to escape backslashes due to the support\n    # of expressions - as such we do so on the json data\n    value = json.dumps(mapping).replace(\"\\\\\", \"\\\\\\\\\")\n    with outputprocessors(\n        rop_node,\n        processors=[\"ayon_remap_paths\"],\n        disable_all_others=True,\n    ):\n        with parm_values([\n            (rop_node.parm(\"ayon_remap_paths_remap_json\"), value)\n        ]):\n            yield\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.remove_usd_output_processor","title":"<code>remove_usd_output_processor(ropnode, processor)</code>","text":"<p>Removes USD Output Processor from USD Rop node.</p> <p>Parameters:</p> Name Type Description Default <code>ropnode</code> <code>RopNode</code> <p>The USD Rop node.</p> required <code>processor</code> <code>str</code> <p>The output processor name. This is the basename of the python file that contains the Houdini USD Output Processor.</p> required Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>def remove_usd_output_processor(ropnode, processor):\n    \"\"\"Removes USD Output Processor from USD Rop node.\n\n    Args:\n        ropnode (hou.RopNode): The USD Rop node.\n        processor (str): The output processor name. This is the basename of\n            the python file that contains the Houdini USD Output Processor.\n\n    \"\"\"\n    import loputils\n\n    parm = ropnode.parm(processor + \"_remove\")\n    if not parm:\n        raise RuntimeError(\n            \"Output Processor %s does not \"\n            \"exist on %s\" % (processor, ropnode.name())\n        )\n\n    loputils.handleOutputProcessorRemove({\"node\": ropnode, \"parm\": parm})\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/usd.html#client.ayon_houdini.api.usd.setup_lop_python_layer","title":"<code>setup_lop_python_layer(layer, node, savepath=None, apply_file_format_args=True)</code>","text":"<p>Set up Sdf.Layer with HoudiniLayerInfo prim for metadata.</p> <p>This is the same as <code>loputils.createPythonLayer</code> but can be run on top of <code>pxr.Sdf.Layer</code> instances that are already created in a Python LOP node. That's useful if your layer creation itself is built to be DCC agnostic, then we just need to run this after per layer to make it explicitly stored for houdini.</p> <p>By default, Houdini doesn't apply the FileFormatArguments supplied to the created layer; however it does support USD's file save suffix of <code>:SDF_FORMAT_ARGS:</code> to supply them. With <code>apply_file_format_args</code> any file format args set on the layer's creation will be added to the save path through that.</p> The <code>node.addHeldLayer</code> call will only work from a LOP python node <p>whenever <code>node.editableStage()</code> or <code>node.editableLayer()</code> was called.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>An existing layer (most likely just created in the current runtime)</p> required <code>node</code> <code>LopNode</code> <p>The Python LOP node to attach the layer to so it does not get garbage collected/mangled after the downstream.</p> required <code>savepath</code> <code>Optional[str]</code> <p>When provided the HoudiniSaveControl will be set to Explicit with HoudiniSavePath to this path.</p> <code>None</code> <code>apply_file_format_args</code> <code>Optional[bool]</code> <p>When enabled any FileFormatArgs defined for the layer on creation will be set in the HoudiniSavePath so Houdini USD ROP will use them top.</p> <code>True</code> <p>Returns:</p> Type Description <p>Sdf.PrimSpec: The Created HoudiniLayerInfo prim spec.</p> Source code in <code>client/ayon_houdini/api/usd.py</code> <pre><code>def setup_lop_python_layer(layer, node, savepath=None,\n                           apply_file_format_args=True):\n    \"\"\"Set up Sdf.Layer with HoudiniLayerInfo prim for metadata.\n\n    This is the same as `loputils.createPythonLayer` but can be run on top\n    of `pxr.Sdf.Layer` instances that are already created in a Python LOP node.\n    That's useful if your layer creation itself is built to be DCC agnostic,\n    then we just need to run this after per layer to make it explicitly\n    stored for houdini.\n\n    By default, Houdini doesn't apply the FileFormatArguments supplied to\n    the created layer; however it does support USD's file save suffix\n    of `:SDF_FORMAT_ARGS:` to supply them. With `apply_file_format_args` any\n    file format args set on the layer's creation will be added to the\n    save path through that.\n\n    Note: The `node.addHeldLayer` call will only work from a LOP python node\n        whenever `node.editableStage()` or `node.editableLayer()` was called.\n\n    Arguments:\n        layer (Sdf.Layer): An existing layer (most likely just created\n            in the current runtime)\n        node (hou.LopNode): The Python LOP node to attach the layer to so\n            it does not get garbage collected/mangled after the downstream.\n        savepath (Optional[str]): When provided the HoudiniSaveControl\n            will be set to Explicit with HoudiniSavePath to this path.\n        apply_file_format_args (Optional[bool]): When enabled any\n            FileFormatArgs defined for the layer on creation will be set\n            in the HoudiniSavePath so Houdini USD ROP will use them top.\n\n    Returns:\n        Sdf.PrimSpec: The Created HoudiniLayerInfo prim spec.\n\n    \"\"\"\n    # Add a Houdini Layer Info prim where we can put the save path.\n    p = Sdf.CreatePrimInLayer(layer, '/HoudiniLayerInfo')\n    p.specifier = Sdf.SpecifierDef\n    p.typeName = 'HoudiniLayerInfo'\n    if savepath:\n        if apply_file_format_args:\n            args = layer.GetFileFormatArguments()\n            savepath = Sdf.Layer.CreateIdentifier(savepath, args)\n\n        p.customData['HoudiniSavePath'] = savepath\n        p.customData['HoudiniSaveControl'] = 'Explicit'\n    # Let everyone know what node created this layer.\n    p.customData['HoudiniCreatorNode'] = node.sessionId()\n    p.customData['HoudiniEditorNodes'] = Vt.IntArray([node.sessionId()])\n    node.addHeldLayer(layer.identifier)\n\n    return p\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/workfile_template_builder.html","title":"workfile_template_builder","text":""},{"location":"autoapi/client/ayon_houdini/api/workfile_template_builder.html#client.ayon_houdini.api.workfile_template_builder.HoudiniPlaceholderPlugin","title":"<code>HoudiniPlaceholderPlugin</code>","text":"<p>               Bases: <code>PlaceholderPlugin</code></p> <p>Base Placeholder Plugin for Houdini with one unified cache.</p> <p>Inherited classes must still implement <code>populate_placeholder</code></p> Source code in <code>client/ayon_houdini/api/workfile_template_builder.py</code> <pre><code>class HoudiniPlaceholderPlugin(PlaceholderPlugin):\n    \"\"\"Base Placeholder Plugin for Houdini with one unified cache.\n\n    Inherited classes must still implement `populate_placeholder`\n    \"\"\"\n\n    def get_placeholder_node_name(self, placeholder_data):\n        return self.identifier.replace(\".\", \"_\")\n\n    def create_placeholder_node(self, node_name=None):\n        \"\"\"Create node to be used as placeholder.\n\n        By default, it creates a null node in '/out'.\n        Feel free to override it in different workfile build plugins.\n        \"\"\"\n\n        node = hou.node(\"/out\").createNode(\n            \"null\", node_name, force_valid_node_name=True)\n        node.moveToGoodPosition()\n        parms = node.parmTemplateGroup()\n        for parm in {\"execute\", \"renderdialog\"}:\n            p = parms.find(parm)\n            p.hide(True)\n            parms.replace(parm, p)\n        node.setParmTemplateGroup(parms)\n        return node\n\n    def create_placeholder(self, placeholder_data):\n        node_name = self.get_placeholder_node_name(placeholder_data)\n\n        placeholder_node = self.create_placeholder_node(node_name)\n        HoudiniCreator.customize_node_look(placeholder_node)\n\n        placeholder_data[\"plugin_identifier\"] = self.identifier\n\n        imprint(placeholder_node, placeholder_data)\n\n    def collect_scene_placeholders(self):\n        # Read the cache by identifier\n        placeholder_nodes = self.builder.get_shared_populate_data(\n            self.identifier\n        )\n        if placeholder_nodes is None:\n            placeholder_nodes = []\n\n            nodes = lsattr(\"plugin_identifier\", self.identifier)\n\n            for node in nodes:\n                placeholder_nodes.append(node)\n\n            # Set the cache by identifier\n            self.builder.set_shared_populate_data(\n                    self.identifier, placeholder_nodes\n                )\n\n        return placeholder_nodes\n\n    def update_placeholder(self, placeholder_item, placeholder_data):\n        placeholder_node = hou.node(placeholder_item.scene_identifier)\n        imprint(placeholder_node, placeholder_data, update=True)\n\n        # Update node name\n        node_name = self.get_placeholder_node_name(placeholder_data)\n        node_name = hou.text.variableName(node_name)\n        placeholder_node.setName(node_name, unique_name=True)\n\n    def delete_placeholder(self, placeholder):\n        placeholder_node = hou.node(placeholder.scene_identifier)\n        placeholder_node.destroy()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/workfile_template_builder.html#client.ayon_houdini.api.workfile_template_builder.HoudiniPlaceholderPlugin.create_placeholder_node","title":"<code>create_placeholder_node(node_name=None)</code>","text":"<p>Create node to be used as placeholder.</p> <p>By default, it creates a null node in '/out'. Feel free to override it in different workfile build plugins.</p> Source code in <code>client/ayon_houdini/api/workfile_template_builder.py</code> <pre><code>def create_placeholder_node(self, node_name=None):\n    \"\"\"Create node to be used as placeholder.\n\n    By default, it creates a null node in '/out'.\n    Feel free to override it in different workfile build plugins.\n    \"\"\"\n\n    node = hou.node(\"/out\").createNode(\n        \"null\", node_name, force_valid_node_name=True)\n    node.moveToGoodPosition()\n    parms = node.parmTemplateGroup()\n    for parm in {\"execute\", \"renderdialog\"}:\n        p = parms.find(parm)\n        p.hide(True)\n        parms.replace(parm, p)\n    node.setParmTemplateGroup(parms)\n    return node\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/workfile_template_builder.html#client.ayon_houdini.api.workfile_template_builder.HoudiniTemplateBuilder","title":"<code>HoudiniTemplateBuilder</code>","text":"<p>               Bases: <code>AbstractTemplateBuilder</code></p> <p>Concrete implementation of AbstractTemplateBuilder for Houdini</p> Source code in <code>client/ayon_houdini/api/workfile_template_builder.py</code> <pre><code>class HoudiniTemplateBuilder(AbstractTemplateBuilder):\n    \"\"\"Concrete implementation of AbstractTemplateBuilder for Houdini\"\"\"\n\n    def resolve_template_path(self, path, fill_data):\n        \"\"\"Allows additional resolving over the template path using custom\n        integration methods, like Houdini's expand string functionality.\n\n        This only works with ayon-core 0.4.5+\n        \"\"\"\n        # use default template data formatting\n        path = super().resolve_template_path(path, fill_data)\n\n        # escape backslashes for `expandString` and expand houdini vars\n        path = path.replace(\"\\\\\", \"\\\\\\\\\")\n        path = hou.text.expandString(path)\n        return path\n\n    def import_template(self, path):\n        \"\"\"Import template into current scene.\n        Block if a template is already loaded.\n\n        Args:\n            path (str): A path to current template (usually given by\n            get_template_preset implementation)\n\n        Returns:\n            bool: Whether the template was successfully imported or not\n        \"\"\"\n\n        # TODO Check if template is already imported\n\n        # Merge (Load) template workfile in the current scene.\n        try:\n            hou.hipFile.merge(path, ignore_load_warnings=True)\n            return True\n        except hou.OperationFailed:\n            return False\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/workfile_template_builder.html#client.ayon_houdini.api.workfile_template_builder.HoudiniTemplateBuilder.import_template","title":"<code>import_template(path)</code>","text":"<p>Import template into current scene. Block if a template is already loaded.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>A path to current template (usually given by</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the template was successfully imported or not</p> Source code in <code>client/ayon_houdini/api/workfile_template_builder.py</code> <pre><code>def import_template(self, path):\n    \"\"\"Import template into current scene.\n    Block if a template is already loaded.\n\n    Args:\n        path (str): A path to current template (usually given by\n        get_template_preset implementation)\n\n    Returns:\n        bool: Whether the template was successfully imported or not\n    \"\"\"\n\n    # TODO Check if template is already imported\n\n    # Merge (Load) template workfile in the current scene.\n    try:\n        hou.hipFile.merge(path, ignore_load_warnings=True)\n        return True\n    except hou.OperationFailed:\n        return False\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/api/workfile_template_builder.html#client.ayon_houdini.api.workfile_template_builder.HoudiniTemplateBuilder.resolve_template_path","title":"<code>resolve_template_path(path, fill_data)</code>","text":"<p>Allows additional resolving over the template path using custom integration methods, like Houdini's expand string functionality.</p> <p>This only works with ayon-core 0.4.5+</p> Source code in <code>client/ayon_houdini/api/workfile_template_builder.py</code> <pre><code>def resolve_template_path(self, path, fill_data):\n    \"\"\"Allows additional resolving over the template path using custom\n    integration methods, like Houdini's expand string functionality.\n\n    This only works with ayon-core 0.4.5+\n    \"\"\"\n    # use default template data formatting\n    path = super().resolve_template_path(path, fill_data)\n\n    # escape backslashes for `expandString` and expand houdini vars\n    path = path.replace(\"\\\\\", \"\\\\\\\\\")\n    path = hou.text.expandString(path)\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_houdini/hooks/set_default_display_and_view.html","title":"set_default_display_and_view","text":""},{"location":"autoapi/client/ayon_houdini/hooks/set_default_display_and_view.html#client.ayon_houdini.hooks.set_default_display_and_view.SetDefaultDisplayView","title":"<code>SetDefaultDisplayView</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Set default view and default display for houdini via OpenColorIO.</p> <p>Houdini's defaultDisplay and defaultView are set by setting 'OCIO_ACTIVE_DISPLAYS' and 'OCIO_ACTIVE_VIEWS' environment variables respectively.</p> <p>More info: https://www.sidefx.com/docs/houdini/io/ocio.html#set-up</p> Source code in <code>client/ayon_houdini/hooks/set_default_display_and_view.py</code> <pre><code>class SetDefaultDisplayView(PreLaunchHook):\n    \"\"\"Set default view and default display for houdini via OpenColorIO.\n\n    Houdini's defaultDisplay and defaultView are set by\n    setting 'OCIO_ACTIVE_DISPLAYS' and 'OCIO_ACTIVE_VIEWS'\n    environment variables respectively.\n\n    More info: https://www.sidefx.com/docs/houdini/io/ocio.html#set-up\n    \"\"\"\n\n    app_groups = {\"houdini\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n\n        OCIO = self.launch_context.env.get(\"OCIO\")\n\n        # This is a cheap way to skip this hook if either global color\n        # management or houdini color management was disabled because the\n        # OCIO var would be set by the global OCIOEnvHook\n        if not OCIO:\n            return\n\n        # workfile settings added in '0.2.13'\n        houdini_color_settings = \\\n            self.data[\"project_settings\"][\"houdini\"][\"imageio\"].get(\"workfile\")\n\n        if not houdini_color_settings:\n            self.log.info(\"Hook 'SetDefaultDisplayView' requires Houdini \"\n                           \"addon version &gt;= '0.2.13'\")\n            return\n\n        if not houdini_color_settings[\"enabled\"]:\n            self.log.info(\n                \"Houdini workfile color management is disabled.\"\n            )\n            return\n\n        # 'OCIO_ACTIVE_DISPLAYS', 'OCIO_ACTIVE_VIEWS' are checked\n        # as Admins can add them in Ayon env vars or Ayon tools.\n\n        default_display = houdini_color_settings[\"default_display\"]\n        if default_display:\n            # get 'OCIO_ACTIVE_DISPLAYS' value if exists.\n            self._set_context_env(\"OCIO_ACTIVE_DISPLAYS\", default_display)\n\n        default_view = houdini_color_settings[\"default_view\"]\n        if default_view:\n            # get 'OCIO_ACTIVE_VIEWS' value if exists.\n            self._set_context_env(\"OCIO_ACTIVE_VIEWS\", default_view)\n\n    def _set_context_env(self, env_var, default_value):\n        env_value = self.launch_context.env.get(env_var, \"\")\n        new_value = \":\".join(\n            key for key in [default_value, env_value] if key\n        )\n        self.log.info(\n            \"Setting {} environment to: {}\"\n            .format(env_var, new_value)\n        )\n        self.launch_context.env[env_var] = new_value\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/hooks/set_paths.html","title":"set_paths","text":""},{"location":"autoapi/client/ayon_houdini/hooks/set_paths.html#client.ayon_houdini.hooks.set_paths.SetPath","title":"<code>SetPath</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Set current dir to workdir.</p> <p>Hook <code>GlobalHostDataHook</code> must be executed before this hook.</p> Source code in <code>client/ayon_houdini/hooks/set_paths.py</code> <pre><code>class SetPath(PreLaunchHook):\n    \"\"\"Set current dir to workdir.\n\n    Hook `GlobalHostDataHook` must be executed before this hook.\n    \"\"\"\n    app_groups = {\"houdini\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        workdir = self.launch_context.env.get(\"AYON_WORKDIR\", \"\")\n        if not workdir:\n            self.log.warning(\"BUG: Workdir is not filled.\")\n            return\n\n        self.launch_context.kwargs[\"cwd\"] = workdir\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_houdini/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_houdini/plugins/create/convert_legacy.html","title":"convert_legacy","text":"<p>Converter for legacy Houdini products.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/convert_legacy.html#client.ayon_houdini.plugins.create.convert_legacy.HoudiniLegacyConvertor","title":"<code>HoudiniLegacyConvertor</code>","text":"<p>               Bases: <code>ProductConvertorPlugin</code></p> <p>Find and convert any legacy products in the scene.</p> <p>This Converter will find all legacy products in the scene and will transform them to the current system. Since the old products doesn't retain any information about their original creators, the only mapping we can do is based on their families.</p> <p>Its limitation is that you can have multiple creators creating product name of the same product type and there is no way to handle it. This code should nevertheless cover all creators that came with AYON.</p> Source code in <code>client/ayon_houdini/plugins/create/convert_legacy.py</code> <pre><code>class HoudiniLegacyConvertor(ProductConvertorPlugin):\n    \"\"\"Find and convert any legacy products in the scene.\n\n    This Converter will find all legacy products in the scene and will\n    transform them to the current system. Since the old products doesn't\n    retain any information about their original creators, the only mapping\n    we can do is based on their families.\n\n    Its limitation is that you can have multiple creators creating product\n    name of the same product type and there is no way to handle it. This code\n    should nevertheless cover all creators that came with AYON.\n\n    \"\"\"\n    identifier = \"io.openpype.creators.houdini.legacy\"\n    product_type_to_id = {\n        \"camera\": \"io.openpype.creators.houdini.camera\",\n        \"ass\": \"io.openpype.creators.houdini.ass\",\n        \"imagesequence\": \"io.openpype.creators.houdini.imagesequence\",\n        \"hda\": \"io.openpype.creators.houdini.hda\",\n        \"pointcache\": \"io.openpype.creators.houdini.pointcache\",\n        \"redshiftproxy\": \"io.openpype.creators.houdini.redshiftproxy\",\n        \"redshift_rop\": \"io.openpype.creators.houdini.redshift_rop\",\n        \"usd\": \"io.openpype.creators.houdini.usd\",\n        \"usdrender\": \"io.openpype.creators.houdini.usdrender\",\n        \"vdbcache\": \"io.openpype.creators.houdini.vdbcache\"\n    }\n\n    def __init__(self, *args, **kwargs):\n        super(HoudiniLegacyConvertor, self).__init__(*args, **kwargs)\n        self.legacy_instances = {}\n\n    def find_instances(self):\n        \"\"\"Find legacy products in the scene.\n\n        Legacy products are the ones that doesn't have `creator_identifier`\n        parameter on them.\n\n        This is using cached entries done in\n        :py:meth:`~HoudiniCreatorBase.cache_instance_data()`\n\n        \"\"\"\n        self.legacy_instances = self.collection_shared_data.get(\n            \"houdini_cached_legacy_instance\")\n        if not self.legacy_instances:\n            return\n        self.add_convertor_item(\"Found {} incompatible product{}.\".format(\n            len(self.legacy_instances),\n            \"s\" if len(self.legacy_instances) &gt; 1 else \"\"\n        ))\n\n    def convert(self):\n        \"\"\"Convert all legacy products to current.\n\n        It is enough to add `creator_identifier` and `instance_node`.\n\n        \"\"\"\n        if not self.legacy_instances:\n            return\n\n        for product_type, legacy_instances in self.legacy_instances.items():\n            if product_type in self.product_type_to_id:\n                for instance in legacy_instances:\n                    creator_id = self.product_type_to_id[product_type]\n                    data = {\n                        \"creator_identifier\": creator_id,\n                        \"instance_node\": instance.path()\n                    }\n                    if product_type == \"pointcache\":\n                        data[\"families\"] = [\"abc\"]\n                    self.log.info(\"Converting {} to {}\".format(\n                        instance.path(), creator_id))\n                    imprint(instance, data)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/convert_legacy.html#client.ayon_houdini.plugins.create.convert_legacy.HoudiniLegacyConvertor.convert","title":"<code>convert()</code>","text":"<p>Convert all legacy products to current.</p> <p>It is enough to add <code>creator_identifier</code> and <code>instance_node</code>.</p> Source code in <code>client/ayon_houdini/plugins/create/convert_legacy.py</code> <pre><code>def convert(self):\n    \"\"\"Convert all legacy products to current.\n\n    It is enough to add `creator_identifier` and `instance_node`.\n\n    \"\"\"\n    if not self.legacy_instances:\n        return\n\n    for product_type, legacy_instances in self.legacy_instances.items():\n        if product_type in self.product_type_to_id:\n            for instance in legacy_instances:\n                creator_id = self.product_type_to_id[product_type]\n                data = {\n                    \"creator_identifier\": creator_id,\n                    \"instance_node\": instance.path()\n                }\n                if product_type == \"pointcache\":\n                    data[\"families\"] = [\"abc\"]\n                self.log.info(\"Converting {} to {}\".format(\n                    instance.path(), creator_id))\n                imprint(instance, data)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/convert_legacy.html#client.ayon_houdini.plugins.create.convert_legacy.HoudiniLegacyConvertor.find_instances","title":"<code>find_instances()</code>","text":"<p>Find legacy products in the scene.</p> <p>Legacy products are the ones that doesn't have <code>creator_identifier</code> parameter on them.</p> <p>This is using cached entries done in :py:meth:<code>~HoudiniCreatorBase.cache_instance_data()</code></p> Source code in <code>client/ayon_houdini/plugins/create/convert_legacy.py</code> <pre><code>def find_instances(self):\n    \"\"\"Find legacy products in the scene.\n\n    Legacy products are the ones that doesn't have `creator_identifier`\n    parameter on them.\n\n    This is using cached entries done in\n    :py:meth:`~HoudiniCreatorBase.cache_instance_data()`\n\n    \"\"\"\n    self.legacy_instances = self.collection_shared_data.get(\n        \"houdini_cached_legacy_instance\")\n    if not self.legacy_instances:\n        return\n    self.add_convertor_item(\"Found {} incompatible product{}.\".format(\n        len(self.legacy_instances),\n        \"s\" if len(self.legacy_instances) &gt; 1 else \"\"\n    ))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_alembic_camera.html","title":"create_alembic_camera","text":"<p>Creator plugin for creating alembic camera products.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_alembic_camera.html#client.ayon_houdini.plugins.create.create_alembic_camera.CreateAlembicCamera","title":"<code>CreateAlembicCamera</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Single baked camera from Alembic ROP.</p> Source code in <code>client/ayon_houdini/plugins/create/create_alembic_camera.py</code> <pre><code>class CreateAlembicCamera(plugin.HoudiniCreator):\n    \"\"\"Single baked camera from Alembic ROP.\"\"\"\n\n    identifier = \"io.openpype.creators.houdini.camera\"\n    label = \"Camera (Abc)\"\n    product_type = \"camera\"\n    icon = \"camera\"\n\n    # Default render target\n    render_target = \"local\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        import hou\n\n        instance_data.update({\"node_type\": \"alembic\"})\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n\n        instance = super(CreateAlembicCamera, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n        parms = {\n            \"filename\": hou.text.expandString(\n                \"$HIP/pyblish/{}.abc\".format(product_name)),\n            \"use_sop_path\": False,\n        }\n\n        if self.selected_nodes:\n            if len(self.selected_nodes) &gt; 1:\n                raise CreatorError(\"More than one item selected.\")\n            path = self.selected_nodes[0].path()\n            # Split the node path into the first root and the remainder\n            # So we can set the root and objects parameters correctly\n            _, root, remainder = path.split(\"/\", 2)\n            parms.update({\"root\": \"/\" + root, \"objects\": remainder})\n\n        instance_node.setParms(parms)\n\n        # Lock the Use Sop Path setting so the\n        # user doesn't accidentally enable it.\n        to_lock = [\"use_sop_path\"]\n        self.lock_parameters(instance_node, to_lock)\n\n        instance_node.parm(\"trange\").set(1)\n\n    def get_network_categories(self):\n        return [\n            hou.ropNodeTypeCategory(),\n            hou.objNodeTypeCategory()\n        ]\n\n    def get_instance_attr_defs(self):\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        attrs = super().get_pre_create_attr_defs()\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_arnold_ass.html","title":"create_arnold_ass","text":"<p>Creator plugin for creating Arnold ASS files.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_arnold_ass.html#client.ayon_houdini.plugins.create.create_arnold_ass.CreateArnoldAss","title":"<code>CreateArnoldAss</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Arnold .ass Archive</p> Source code in <code>client/ayon_houdini/plugins/create/create_arnold_ass.py</code> <pre><code>class CreateArnoldAss(plugin.HoudiniCreator):\n    \"\"\"Arnold .ass Archive\"\"\"\n\n    identifier = \"io.openpype.creators.houdini.ass\"\n    label = \"Arnold ASS\"\n    product_type = \"ass\"\n    icon = \"magic\"\n\n    # Default extension: `.ass` or `.ass.gz`\n    # however calling HoudiniCreator.create()\n    # will override it by the value in the project settings\n    ext = \".ass\"\n\n    # Default render target\n    render_target = \"local\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        import hou\n\n        instance_data.update({\"node_type\": \"arnold\"})\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n\n        instance = super(CreateArnoldAss, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        # Hide Properties Tab on Arnold ROP since that's used\n        # for rendering instead of .ass Archive Export\n        parm_template_group = instance_node.parmTemplateGroup()\n        parm_template_group.hideFolder(\"Properties\", True)\n        instance_node.setParmTemplateGroup(parm_template_group)\n\n        filepath = \"{}{}\".format(\n            hou.text.expandString(\"$HIP/pyblish/\"),\n            \"{}.$F4{}\".format(product_name, self.ext)\n        )\n        parms = {\n            # Render frame range\n            \"trange\": 1,\n            # Arnold ROP settings\n            \"ar_ass_file\": filepath,\n            \"ar_ass_export_enable\": 1\n        }\n\n        instance_node.setParms(parms)\n\n        # Lock any parameters in this list\n        to_lock = [\"ar_ass_export_enable\", \"productType\", \"id\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_instance_attr_defs(self):\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        attrs = super().get_pre_create_attr_defs()\n        # Use same attributes as for instance attributes\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_arnold_rop.html","title":"create_arnold_rop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/create/create_arnold_rop.html#client.ayon_houdini.plugins.create.create_arnold_rop.CreateArnoldRop","title":"<code>CreateArnoldRop</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Arnold ROP</p> Source code in <code>client/ayon_houdini/plugins/create/create_arnold_rop.py</code> <pre><code>class CreateArnoldRop(plugin.HoudiniCreator):\n    \"\"\"Arnold ROP\"\"\"\n\n    identifier = \"io.openpype.creators.houdini.arnold_rop\"\n    label = \"Arnold ROP\"\n    product_type = \"arnold_rop\"\n    icon = \"magic\"\n\n    # Default extension\n    ext = \"exr\"\n\n    # Default render target\n    render_target = \"farm_split\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        import hou\n        # Transfer settings from pre create to instance\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        for key in [\"render_target\", \"review\"]:\n            if key in pre_create_data:\n                creator_attributes[key] = pre_create_data[key]\n\n        # Remove the active, we are checking the bypass flag of the nodes\n        instance_data.update({\"node_type\": \"arnold\"})\n\n        instance = super(CreateArnoldRop, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        ext = pre_create_data.get(\"image_format\")\n\n        renders_dir = hou.text.expandString(\"$HIP/pyblish/renders/\")\n        filepath = f\"{renders_dir}{product_name}/{product_name}.$F4.{ext}\"\n        parms = {\n            # Render frame range\n            \"trange\": 1,\n\n            # Arnold ROP settings\n            \"ar_picture\": filepath,\n            \"ar_exr_half_precision\": 1           # half precision\n        }\n\n        if pre_create_data.get(\"render_target\") == \"farm_split\":\n            ass_filepath = \\\n                \"{export_dir}{product_name}/{product_name}.$F4.ass\".format(\n                    export_dir=hou.text.expandString(\"$HIP/pyblish/ass/\"),\n                    product_name=product_name,\n                )\n            parms[\"ar_ass_export_enable\"] = 1\n            parms[\"ar_ass_file\"] = ass_filepath\n\n        instance_node.setParms(parms)\n\n        # Lock any parameters in this list\n        to_lock = [\"productType\", \"id\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_instance_attr_defs(self):\n        \"\"\"get instance attribute definitions.\n\n        Attributes defined in this method are exposed in\n            publish tab in the publisher UI.\n        \"\"\"\n\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n            \"farm_split\": \"Farm Rendering - Split export &amp; render jobs\",\n        }\n\n        return [\n            BoolDef(\"review\",\n                    label=\"Review\",\n                    tooltip=\"Mark as reviewable\",\n                    default=True),\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target),\n        ]\n\n    def get_pre_create_attr_defs(self):\n        image_format_enum = [\n            \"bmp\", \"cin\", \"exr\", \"jpg\", \"pic\", \"pic.gz\", \"png\",\n            \"rad\", \"rat\", \"rta\", \"sgi\", \"tga\", \"tif\",\n        ]\n\n        attrs = [\n            EnumDef(\"image_format\",\n                    image_format_enum,\n                    default=self.ext,\n                    label=\"Image Format Options\"),\n        ]\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_arnold_rop.html#client.ayon_houdini.plugins.create.create_arnold_rop.CreateArnoldRop.get_instance_attr_defs","title":"<code>get_instance_attr_defs()</code>","text":"<p>get instance attribute definitions.</p> <p>Attributes defined in this method are exposed in     publish tab in the publisher UI.</p> Source code in <code>client/ayon_houdini/plugins/create/create_arnold_rop.py</code> <pre><code>def get_instance_attr_defs(self):\n    \"\"\"get instance attribute definitions.\n\n    Attributes defined in this method are exposed in\n        publish tab in the publisher UI.\n    \"\"\"\n\n    render_target_items = {\n        \"local\": \"Local machine rendering\",\n        \"local_no_render\": \"Use existing frames (local)\",\n        \"farm\": \"Farm Rendering\",\n        \"farm_split\": \"Farm Rendering - Split export &amp; render jobs\",\n    }\n\n    return [\n        BoolDef(\"review\",\n                label=\"Review\",\n                tooltip=\"Mark as reviewable\",\n                default=True),\n        EnumDef(\"render_target\",\n                items=render_target_items,\n                label=\"Render target\",\n                default=self.render_target),\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_bgeo.html","title":"create_bgeo","text":"<p>Creator plugin for creating pointcache bgeo files.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_bgeo.html#client.ayon_houdini.plugins.create.create_bgeo.CreateBGEO","title":"<code>CreateBGEO</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>BGEO pointcache creator.</p> Source code in <code>client/ayon_houdini/plugins/create/create_bgeo.py</code> <pre><code>class CreateBGEO(plugin.HoudiniCreator):\n    \"\"\"BGEO pointcache creator.\"\"\"\n    identifier = \"io.openpype.creators.houdini.bgeo\"\n    label = \"PointCache (Bgeo)\"\n    product_type = \"pointcache\"\n    icon = \"gears\"\n\n    # Default render target\n    render_target = \"local\"\n\n    def get_publish_families(self):\n        return [\"pointcache\", \"bgeo\"]\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        instance_data.update({\"node_type\": \"geometry\"})\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n\n        instance = super(CreateBGEO, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        file_path = \"{}{}\".format(\n            hou.text.expandString(\"$HIP/pyblish/\"),\n            \"{}.$F4.{}\".format(\n                product_name,\n                pre_create_data.get(\"bgeo_type\") or \"bgeo.sc\")\n        )\n        parms = {\n            \"sopoutput\": file_path\n        }\n\n        instance_node.parm(\"trange\").set(1)\n        if self.selected_nodes:\n            # if selection is on SOP level, use it\n            if isinstance(self.selected_nodes[0], hou.SopNode):\n                parms[\"soppath\"] = self.selected_nodes[0].path()\n            else:\n                # try to find output node with the lowest index\n                outputs = [\n                    child for child in self.selected_nodes[0].children()\n                    if child.type().name() == \"output\"\n                ]\n                if not outputs:\n                    instance_node.setParms(parms)\n                    raise CreatorError((\n                        \"Missing output node in SOP level for the selection. \"\n                        \"Please select correct SOP path in created instance.\"\n                    ))\n                outputs.sort(key=lambda output: output.evalParm(\"outputidx\"))\n                parms[\"soppath\"] = outputs[0].path()\n\n        instance_node.setParms(parms)\n\n    def get_instance_attr_defs(self):\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        attrs = super().get_pre_create_attr_defs()\n        bgeo_enum = [\n            {\n                \"value\": \"bgeo\",\n                \"label\": \"uncompressed bgeo (.bgeo)\"\n            },\n            {\n                \"value\": \"bgeosc\",\n                \"label\": \"BLOSC compressed bgeo (.bgeosc)\"\n            },\n            {\n                \"value\": \"bgeo.sc\",\n                \"label\": \"BLOSC compressed bgeo (.bgeo.sc)\"\n            },\n            {\n                \"value\": \"bgeo.gz\",\n                \"label\": \"GZ compressed bgeo (.bgeo.gz)\"\n            },\n            {\n                \"value\": \"bgeo.lzma\",\n                \"label\": \"LZMA compressed bgeo (.bgeo.lzma)\"\n            },\n            {\n                \"value\": \"bgeo.bz2\",\n                \"label\": \"BZip2 compressed bgeo (.bgeo.bz2)\"\n            }\n        ]\n\n        return attrs + [\n            EnumDef(\n                \"bgeo_type\",\n                bgeo_enum,\n                default=\"bgeo.sc\",\n                label=\"BGEO Options\"\n            ),\n        ] + self.get_instance_attr_defs()\n\n    def get_network_categories(self):\n        return [\n            hou.ropNodeTypeCategory(),\n            hou.sopNodeTypeCategory()\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_composite.html","title":"create_composite","text":"<p>Creator plugin for creating composite sequences.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_composite.html#client.ayon_houdini.plugins.create.create_composite.CreateCompositeSequence","title":"<code>CreateCompositeSequence</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Composite ROP to Image Sequence</p> Source code in <code>client/ayon_houdini/plugins/create/create_composite.py</code> <pre><code>class CreateCompositeSequence(plugin.HoudiniCreator):\n    \"\"\"Composite ROP to Image Sequence\"\"\"\n\n    identifier = \"io.openpype.creators.houdini.imagesequence\"\n    label = \"Composite (Image Sequence)\"\n    product_type = \"imagesequence\"\n    icon = \"gears\"\n\n    ext = \".exr\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        import hou  # noqa\n\n        instance_data.update({\"node_type\": \"comp\"})\n\n        instance = super(CreateCompositeSequence, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n        filepath = \"{}{}\".format(\n            hou.text.expandString(\"$HIP/pyblish/\"),\n            \"{}.$F4{}\".format(product_name, self.ext)\n        )\n        parms = {\n            \"trange\": 1,\n            \"copoutput\": filepath\n        }\n\n        if self.selected_nodes:\n            if len(self.selected_nodes) &gt; 1:\n                raise CreatorError(\"More than one item selected.\")\n            path = self.selected_nodes[0].path()\n            parms[\"coppath\"] = path\n\n        instance_node.setParms(parms)\n\n        # Manually set f1 &amp; f2 to $FSTART and $FEND respectively\n        # to match other Houdini nodes default.\n        instance_node.parm(\"f1\").setExpression(\"$FSTART\")\n        instance_node.parm(\"f2\").setExpression(\"$FEND\")\n\n        # Lock any parameters in this list\n        to_lock = [\"prim_to_detail_pattern\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_network_categories(self):\n        return [\n            hou.ropNodeTypeCategory(),\n            hou.cop2NodeTypeCategory()\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_fbx.html","title":"create_fbx","text":"<p>Creator plugins for FBX, like static mesh and model products</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_fbx.html#client.ayon_houdini.plugins.create.create_fbx.CreateFBX","title":"<code>CreateFBX</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Model as FBX.</p> Source code in <code>client/ayon_houdini/plugins/create/create_fbx.py</code> <pre><code>class CreateFBX(plugin.HoudiniCreator):\n    \"\"\"Model as FBX.\"\"\"\n\n    identifier = \"io.ayon.creators.houdini.model.fbx\"\n    label = \"model (FBX)\"\n    product_type = \"model\"\n    icon = \"cube\"\n    default_variants = [\"Main\"]\n\n    # Default render target\n    render_target = \"local\"\n\n    def get_publish_families(self):\n        return [\"fbx\", \"model\"]\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        instance_data.update({\"node_type\": \"filmboxfbx\"})\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n\n        instance = super().create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        # get the created rop node\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        # prepare parms\n        output_path = hou.text.expandString(\n            \"$HIP/pyblish/{}.fbx\".format(product_name)\n        )\n\n        parms = {\n            \"startnode\": self.get_selection(),\n            \"sopoutput\": output_path,\n            # vertex cache format\n            \"vcformat\": pre_create_data.get(\"vcformat\"),\n            \"convertunits\": pre_create_data.get(\"convertunits\"),\n            # set render range to use frame range start-end frame\n            \"trange\": 1,\n            \"createsubnetroot\": pre_create_data.get(\"createsubnetroot\"),\n            \"exportkind\": pre_create_data.get(\"exportkind\")\n        }\n\n        # set parms\n        instance_node.setParms(parms)\n\n        # Lock any parameters in this list\n        to_lock = [\"productType\", \"id\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_network_categories(self):\n        return [\n            hou.ropNodeTypeCategory(),\n            hou.objNodeTypeCategory(),\n            hou.sopNodeTypeCategory()\n        ]\n\n    def get_instance_attr_defs(self):\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        \"\"\"Add settings for users. \"\"\"\n\n        attrs = super().get_pre_create_attr_defs()\n        createsubnetroot = BoolDef(\"createsubnetroot\",\n                                   tooltip=\"Create an extra root for the \"\n                                           \"Export node when it's a \"\n                                           \"subnetwork. This causes the \"\n                                           \"exporting subnetwork node to be \"\n                                           \"represented in the FBX file.\",\n                                   default=False,\n                                   label=\"Create Root for Subnet\")\n        vcformat = EnumDef(\"vcformat\",\n                           items={\n                               0: \"Maya Compatible (MC)\",\n                               1: \"3DS MAX Compatible (PC2)\"\n                           },\n                           default=0,\n                           label=\"Vertex Cache Format\")\n        convert_units = BoolDef(\"convertunits\",\n                                tooltip=\"When on, the FBX is converted\"\n                                        \"from the current Houdini \"\n                                        \"system units to the native \"\n                                        \"FBX unit of centimeters.\",\n                                default=False,\n                                label=\"Convert Units\")\n        format_ascii = EnumDef(\"exportkind\",\n                               items={\n                                   0: \"Binary\",\n                                   1: \"ASCII\"\n                               },\n                               default=0,\n                               label=\"Export Format\")\n        return attrs + [\n            createsubnetroot,\n            vcformat,\n            convert_units,\n            format_ascii,\n        ] + self.get_instance_attr_defs()\n\n    def get_dynamic_data(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    ):\n        \"\"\"\n        The default prodcut name templates for Unreal include {asset} and thus\n        we should pass that along as dynamic data.\n        \"\"\"\n        dynamic_data = super().get_dynamic_data(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n            instance\n        )\n        dynamic_data[\"asset\"] = folder_entity[\"name\"]\n        return dynamic_data\n\n    def get_selection(self):\n        \"\"\"Selection Logic.\n\n        how self.selected_nodes should be processed to get\n        the desirable node from selection.\n\n        Returns:\n            str : node path\n        \"\"\"\n\n        selection = \"\"\n\n        if self.selected_nodes:\n            selected_node = self.selected_nodes[0]\n\n            # Accept sop level nodes (e.g. /obj/geo1/box1)\n            if isinstance(selected_node, hou.SopNode):\n                selection = selected_node.path()\n                self.log.debug(\n                    \"Valid SopNode selection, 'Export' in filmboxfbx\"\n                    \" will be set to '%s'.\", selected_node\n                )\n\n            # Accept object level nodes (e.g. /obj/geo1)\n            elif isinstance(selected_node, hou.ObjNode):\n                selection = selected_node.path()\n                self.log.debug(\n                    \"Valid ObjNode selection, 'Export' in filmboxfbx \"\n                    \"will be set to the child path '%s'.\", selection\n                )\n\n            else:\n                self.log.debug(\n                    \"Selection isn't valid. 'Export' in \"\n                    \"filmboxfbx will be empty.\"\n                )\n        else:\n            self.log.debug(\n                \"No Selection. 'Export' in filmboxfbx will be empty.\"\n            )\n\n        return selection\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_fbx.html#client.ayon_houdini.plugins.create.create_fbx.CreateFBX.get_dynamic_data","title":"<code>get_dynamic_data(project_name, folder_entity, task_entity, variant, host_name, instance)</code>","text":"<p>The default prodcut name templates for Unreal include {asset} and thus we should pass that along as dynamic data.</p> Source code in <code>client/ayon_houdini/plugins/create/create_fbx.py</code> <pre><code>def get_dynamic_data(\n    self,\n    project_name,\n    folder_entity,\n    task_entity,\n    variant,\n    host_name,\n    instance\n):\n    \"\"\"\n    The default prodcut name templates for Unreal include {asset} and thus\n    we should pass that along as dynamic data.\n    \"\"\"\n    dynamic_data = super().get_dynamic_data(\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    )\n    dynamic_data[\"asset\"] = folder_entity[\"name\"]\n    return dynamic_data\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_fbx.html#client.ayon_houdini.plugins.create.create_fbx.CreateFBX.get_pre_create_attr_defs","title":"<code>get_pre_create_attr_defs()</code>","text":"<p>Add settings for users.</p> Source code in <code>client/ayon_houdini/plugins/create/create_fbx.py</code> <pre><code>def get_pre_create_attr_defs(self):\n    \"\"\"Add settings for users. \"\"\"\n\n    attrs = super().get_pre_create_attr_defs()\n    createsubnetroot = BoolDef(\"createsubnetroot\",\n                               tooltip=\"Create an extra root for the \"\n                                       \"Export node when it's a \"\n                                       \"subnetwork. This causes the \"\n                                       \"exporting subnetwork node to be \"\n                                       \"represented in the FBX file.\",\n                               default=False,\n                               label=\"Create Root for Subnet\")\n    vcformat = EnumDef(\"vcformat\",\n                       items={\n                           0: \"Maya Compatible (MC)\",\n                           1: \"3DS MAX Compatible (PC2)\"\n                       },\n                       default=0,\n                       label=\"Vertex Cache Format\")\n    convert_units = BoolDef(\"convertunits\",\n                            tooltip=\"When on, the FBX is converted\"\n                                    \"from the current Houdini \"\n                                    \"system units to the native \"\n                                    \"FBX unit of centimeters.\",\n                            default=False,\n                            label=\"Convert Units\")\n    format_ascii = EnumDef(\"exportkind\",\n                           items={\n                               0: \"Binary\",\n                               1: \"ASCII\"\n                           },\n                           default=0,\n                           label=\"Export Format\")\n    return attrs + [\n        createsubnetroot,\n        vcformat,\n        convert_units,\n        format_ascii,\n    ] + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_fbx.html#client.ayon_houdini.plugins.create.create_fbx.CreateFBX.get_selection","title":"<code>get_selection()</code>","text":"<p>Selection Logic.</p> <p>how self.selected_nodes should be processed to get the desirable node from selection.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>node path</p> Source code in <code>client/ayon_houdini/plugins/create/create_fbx.py</code> <pre><code>def get_selection(self):\n    \"\"\"Selection Logic.\n\n    how self.selected_nodes should be processed to get\n    the desirable node from selection.\n\n    Returns:\n        str : node path\n    \"\"\"\n\n    selection = \"\"\n\n    if self.selected_nodes:\n        selected_node = self.selected_nodes[0]\n\n        # Accept sop level nodes (e.g. /obj/geo1/box1)\n        if isinstance(selected_node, hou.SopNode):\n            selection = selected_node.path()\n            self.log.debug(\n                \"Valid SopNode selection, 'Export' in filmboxfbx\"\n                \" will be set to '%s'.\", selected_node\n            )\n\n        # Accept object level nodes (e.g. /obj/geo1)\n        elif isinstance(selected_node, hou.ObjNode):\n            selection = selected_node.path()\n            self.log.debug(\n                \"Valid ObjNode selection, 'Export' in filmboxfbx \"\n                \"will be set to the child path '%s'.\", selection\n            )\n\n        else:\n            self.log.debug(\n                \"Selection isn't valid. 'Export' in \"\n                \"filmboxfbx will be empty.\"\n            )\n    else:\n        self.log.debug(\n            \"No Selection. 'Export' in filmboxfbx will be empty.\"\n        )\n\n    return selection\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_fbx.html#client.ayon_houdini.plugins.create.create_fbx.CreateStaticMesh","title":"<code>CreateStaticMesh</code>","text":"<p>               Bases: <code>CreateFBX</code></p> <p>Static Meshes as FBX.</p> Source code in <code>client/ayon_houdini/plugins/create/create_fbx.py</code> <pre><code>class CreateStaticMesh(CreateFBX):\n    \"\"\"Static Meshes as FBX.\"\"\"\n\n    identifier = \"io.openpype.creators.houdini.staticmesh.fbx\"\n    label = \"Static Mesh (FBX)\"\n    product_type = \"staticMesh\"\n    icon = \"cube\"\n\n    def get_publish_families(self):\n        return [\"fbx\", \"staticMesh\"]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_hda.html","title":"create_hda","text":"<p>Creator plugin for creating publishable Houdini Digital Assets.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_hda.html#client.ayon_houdini.plugins.create.create_hda.CreateHDA","title":"<code>CreateHDA</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Publish Houdini Digital Asset file.</p> Source code in <code>client/ayon_houdini/plugins/create/create_hda.py</code> <pre><code>class CreateHDA(plugin.HoudiniCreator):\n    \"\"\"Publish Houdini Digital Asset file.\"\"\"\n\n    identifier = \"io.openpype.creators.houdini.hda\"\n    label = \"Houdini Digital Asset (Hda)\"\n    product_type = \"hda\"\n    icon = \"gears\"\n    maintain_selection = False\n\n    def _check_existing(self, folder_path, product_name):\n        # type: (str, str) -&gt; bool\n        \"\"\"Check if existing product name versions already exists.\"\"\"\n        # Get all products of the current folder\n        project_name = self.project_name\n        folder_entity = ayon_api.get_folder_by_path(\n            project_name, folder_path, fields={\"id\"}\n        )\n        product_entities = ayon_api.get_products(\n            project_name, folder_ids={folder_entity[\"id\"]}, fields={\"name\"}\n        )\n        existing_product_names_low = {\n            product_entity[\"name\"].lower()\n            for product_entity in product_entities\n        }\n        return product_name.lower() in existing_product_names_low\n\n    def create_instance_node(\n        self,\n        folder_path,\n        node_name,\n        parent,\n        node_type=\"geometry\",\n        pre_create_data=None\n    ):\n        if pre_create_data is None:\n            pre_create_data = {}\n\n        use_promote_spare_parameters = pre_create_data.get(\n            \"use_promote_spare_parameters\", True)\n\n        if self.selected_nodes:\n            # if we have `use selection` enabled, and we have some\n            # selected nodes ...\n            one_node_selected = len(self.selected_nodes) == 1\n            first_selected_node = self.selected_nodes[0]\n\n            # If only an HDA is selected, publish just that node as HDA.\n            if one_node_selected and first_selected_node.type().definition():\n                to_hda = first_selected_node\n                use_promote_spare_parameters = False\n\n            # If only a single subnet is selected, turn that into the HDA.\n            elif (\n                one_node_selected\n                and first_selected_node.type().name() == \"subnet\"\n            ):\n                to_hda = first_selected_node\n                to_hda.setName(\"{}_subnet\".format(node_name), unique_name=True)\n\n            # Collapse all selected nodes into a subnet and turn that into\n            # the HDA.\n            else:\n                parent_node = self.selected_nodes[0].parent()\n                subnet = parent_node.collapseIntoSubnet(\n                    self.selected_nodes,\n                    subnet_name=\"{}_subnet\".format(node_name))\n                subnet.moveToGoodPosition()\n                to_hda = subnet\n        else:\n            # Use Obj as the default path\n            parent_node = hou.node(\"/obj\")\n            # Find and return the NetworkEditor pane tab with the minimum index\n            pane = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)\n            if isinstance(pane, hou.NetworkEditor):\n                # Use the NetworkEditor pane path as the parent path.\n                parent_node = pane.pwd()\n\n            to_hda = parent_node.createNode(\n                \"subnet\", node_name=\"{}_subnet\".format(node_name))\n\n        if not to_hda.type().definition():\n            # if node type has not its definition, it is not user\n            # created hda. We test if hda can be created from the node.\n            if not to_hda.canCreateDigitalAsset():\n                raise CreatorError(\n                    \"cannot create hda from node {}\".format(to_hda))\n\n            # Pick a unique type name for HDA product per folder path\n            #   per project.\n            type_name = (\n                \"{project_name}{folder_path}_{node_name}\".format(\n                    project_name=get_current_project_name(),\n                    folder_path=folder_path.replace(\"/\",\"_\"),\n                    node_name=node_name\n                )\n            )\n\n            hda_node = to_hda.createDigitalAsset(\n                name=type_name,\n                description=node_name,\n                hda_file_name=\"$HIP/{}.hda\".format(node_name),\n                ignore_external_references=True,\n                min_num_inputs=0,\n                max_num_inputs=len(to_hda.inputs()) or 1,\n            )\n\n            if use_promote_spare_parameters:\n                # Similar to Houdini default behavior, when enabled this will\n                # promote spare parameters to type properties on initial\n                # creation of the HDA.\n                promote_spare_parameters(hda_node)\n\n            hda_node.layoutChildren()\n        elif self._check_existing(folder_path, node_name):\n            raise CreatorError(\n                (\"product {} is already published with different HDA\"\n                 \"definition.\").format(node_name))\n        else:\n            hda_node = to_hda\n\n        # If user tries to create the same HDA instance more than\n        # once, then all of them will have the same product name and\n        # point to the same hda_file_name. But, their node names will\n        # be incremented.\n        hda_node.setName(node_name, unique_name=True)\n        self.customize_node_look(hda_node)\n\n        # Set Custom settings.\n        hda_def = hda_node.type().definition()\n\n        if pre_create_data.get(\"set_user\"):\n            hda_def.setUserInfo(get_ayon_username())\n\n        if pre_create_data.get(\"use_project\"):\n            set_tool_submenu(hda_def, \"AYON/{}\".format(self.project_name))\n\n        return hda_node\n\n    def get_network_categories(self):\n        # Houdini allows creating sub-network nodes inside\n        # these categories.\n        # Therefore this plugin can work in these categories.\n        return [\n            hou.chopNodeTypeCategory(),\n            hou.cop2NodeTypeCategory(),\n            hou.dopNodeTypeCategory(),\n            hou.ropNodeTypeCategory(),\n            hou.lopNodeTypeCategory(),\n            hou.objNodeTypeCategory(),\n            hou.sopNodeTypeCategory(),\n            hou.topNodeTypeCategory(),\n            hou.vopNodeTypeCategory()\n        ]\n\n    def get_pre_create_attr_defs(self):\n        attrs = super(CreateHDA, self).get_pre_create_attr_defs()\n        return attrs + [\n            BoolDef(\"set_user\",\n                    tooltip=\"Set current user as the author of the HDA\",\n                    default=False,\n                    label=\"Set Current User\"),\n            BoolDef(\"use_project\",\n                    tooltip=\"Use project name as tab submenu path.\\n\"\n                            \"The location in TAB Menu will be\\n\"\n                            \"'AYON/project_name/your_HDA_name'\",\n                    default=True,\n                    label=\"Use Project as menu entry\"),\n            BoolDef(\"use_promote_spare_parameters\",\n                    tooltip=\"Similar to Houdini default behavior, when \"\n                            \"enabled this will promote spare parameters to \"\n                            \"type properties on initial creation of the HDA.\",\n                    default=True,\n                    label=\"Promote Spare Parameters\"),\n        ]\n\n    def get_dynamic_data(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    ):\n        \"\"\"\n        Pass product name from product name templates as dynamic data.\n        \"\"\"\n        dynamic_data = super(CreateHDA, self).get_dynamic_data(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n            instance\n        )\n\n        dynamic_data.update(\n            {\n                \"asset\": folder_entity[\"name\"],\n                \"folder\": {\n                            \"label\": folder_entity[\"label\"],\n                            \"name\": folder_entity[\"name\"]\n                }\n            }\n        )\n\n        return dynamic_data\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_hda.html#client.ayon_houdini.plugins.create.create_hda.CreateHDA.get_dynamic_data","title":"<code>get_dynamic_data(project_name, folder_entity, task_entity, variant, host_name, instance)</code>","text":"<p>Pass product name from product name templates as dynamic data.</p> Source code in <code>client/ayon_houdini/plugins/create/create_hda.py</code> <pre><code>def get_dynamic_data(\n    self,\n    project_name,\n    folder_entity,\n    task_entity,\n    variant,\n    host_name,\n    instance\n):\n    \"\"\"\n    Pass product name from product name templates as dynamic data.\n    \"\"\"\n    dynamic_data = super(CreateHDA, self).get_dynamic_data(\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    )\n\n    dynamic_data.update(\n        {\n            \"asset\": folder_entity[\"name\"],\n            \"folder\": {\n                        \"label\": folder_entity[\"label\"],\n                        \"name\": folder_entity[\"name\"]\n            }\n        }\n    )\n\n    return dynamic_data\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_hda.html#client.ayon_houdini.plugins.create.create_hda.get_tool_submenus","title":"<code>get_tool_submenus(hda_def)</code>","text":"<p>Returns the tab submenu entries of this node.</p> <p>Note: A node could be placed in multiple entries at once.</p> <p>Parameters:</p> Name Type Description Default <code>hda_def</code> <p>the HDA Definition by hou.node.type().definition()</p> required <p>Returns:</p> Type Description <p>Optional[list[str]]: A list of submenus</p> Source code in <code>client/ayon_houdini/plugins/create/create_hda.py</code> <pre><code>def get_tool_submenus(hda_def):\n    \"\"\"Returns the tab submenu entries of this node.\n\n     Note: A node could be placed in multiple entries at once.\n\n    Arguments:\n        hda_def: the HDA Definition by hou.node.type().definition()\n\n    Returns:\n        Optional[list[str]]: A list of submenus\n    \"\"\"\n\n    import xml.etree.ElementTree as ET\n    if hda_def.hasSection('Tools.shelf'):\n        sections = hda_def.sections()\n        ts_section = sections['Tools.shelf'].contents()\n        try:\n            root = ET.fromstring(ts_section)\n        except ET.ParseError:\n            return None\n        tool = root[0]\n        submenus = tool.findall('toolSubmenu')\n        if submenus:\n            tool_submenus = []\n            for submenu in submenus:\n                if submenu is not None:\n                    text = submenu.text\n                    if text:\n                        tool_submenus.append(submenu.text)\n            if tool_submenus:\n                return tool_submenus\n            else:\n                return None\n        else:\n            return None\n    else:\n        return None\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_hda.html#client.ayon_houdini.plugins.create.create_hda.promote_spare_parameters","title":"<code>promote_spare_parameters(node)</code>","text":"<p>Promote spare parameters to HDA node type definition</p> Source code in <code>client/ayon_houdini/plugins/create/create_hda.py</code> <pre><code>def promote_spare_parameters(node):\n    \"\"\"Promote spare parameters to HDA node type definition\"\"\"\n    ptg = node.parmTemplateGroup()\n    node.type().definition().setParmTemplateGroup(ptg)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_hda.html#client.ayon_houdini.plugins.create.create_hda.set_tool_submenu","title":"<code>set_tool_submenu(hda_def, new_submenu='Digital Assets')</code>","text":"<p>Sets the tab menu entry for a node.</p> <p>Parameters:</p> Name Type Description Default <code>hda_def</code> <p>the HDA Definition by hou.node.type().definition()</p> required <code>new_submenu</code> <code>Optional[str]</code> <p>This will be the new submenu, replacing old_submenu entry</p> <code>'Digital Assets'</code> Source code in <code>client/ayon_houdini/plugins/create/create_hda.py</code> <pre><code>def set_tool_submenu(hda_def,\n                     new_submenu='Digital Assets'):\n    \"\"\"Sets the tab menu entry for a node.\n\n    Arguments:\n        hda_def: the HDA Definition by hou.node.type().definition()\n        new_submenu (Optional[str]): This will be the new submenu, replacing\n            old_submenu entry\n    \"\"\"\n\n    context_dict = {\n        'Shop': 'SHOP',\n        'Cop2': 'COP2',\n        'Object': 'OBJ',\n        'Chop': 'CHOP',\n        'Sop': 'SOP',\n        'Vop': 'VOP',\n        'VopNet': 'VOPNET',\n        'Driver': 'ROP',\n        'TOP': 'TOP',\n        'Top': 'TOP',\n        'Lop': 'LOP',\n        'Dop': 'DOP'}\n\n    utils_dict = {\n        'Shop': 'shoptoolutils',\n        'Cop2': 'cop2toolutils',\n        'Object': 'objecttoolutils',\n        'Chop': 'choptoolutils',\n        'Sop': 'soptoolutils',\n        'Vop': 'voptoolutils',\n        'VopNet': 'vopnettoolutils',\n        'Driver': 'drivertoolutils',\n        'TOP': 'toptoolutils',\n        'Top': 'toptoolutils',\n        'Lop': 'loptoolutils',\n        'Dop': 'doptoolutils'}\n\n    if hda_def.hasSection('Tools.shelf'):\n        old_submenu = get_tool_submenus(hda_def)[0]\n    else:\n        # Add default tools shelf section\n        content = \"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;shelfDocument&gt;\n&lt;!-- This file contains definitions of shelves, toolbars, and tools.\nIt should not be hand-edited when it is being used by the application.\nNote, that two definitions of the same element are not allowed in\na single file. --&gt;\n&lt;tool name=\"$HDA_DEFAULT_TOOL\" label=\"$HDA_LABEL\" icon=\"$HDA_ICON\"&gt;\n&lt;toolMenuContext name=\"viewer\"&gt;\n&lt;contextNetType&gt;SOP&lt;/contextNetType&gt;\n&lt;/toolMenuContext&gt;\n&lt;toolMenuContext name=\"network\"&gt;\n&lt;contextOpType&gt;$HDA_TABLE_AND_NAME&lt;/contextOpType&gt;\n&lt;/toolMenuContext&gt;\n&lt;toolSubmenu&gt;Digital Assets&lt;/toolSubmenu&gt;\n&lt;script scriptType=\"python\"&gt;&lt;![CDATA[import soptoolutils\nsoptoolutils.genericTool(kwargs, \\'$HDA_NAME\\')]]&gt;&lt;/script&gt;\n&lt;/tool&gt;\n&lt;/shelfDocument&gt;\n        \"\"\"\n\n        nodetype_category_name = hda_def.nodeType().category().name()\n        context = context_dict[nodetype_category_name]\n        util = utils_dict[nodetype_category_name]\n        content = content.replace(\n            \"&lt;contextNetType&gt;SOP&lt;/contextNetType&gt;\",\n            f\"&lt;contextNetType&gt;{context}&lt;/contextNetType&gt;\")\n        content = content.replace('soptoolutils', util)\n        hda_def.addSection('Tools.shelf', content)\n        old_submenu = 'Digital Assets'\n\n    # Replace submenu\n    tools = hda_def.sections()[\"Tools.shelf\"]\n    content = tools.contents()\n    content = content.replace(\n        f\"&lt;toolSubmenu&gt;{old_submenu}&lt;/toolSubmenu&gt;\",\n        f\"&lt;toolSubmenu&gt;{new_submenu}&lt;/toolSubmenu&gt;\"\n    )\n\n    hda_def.addSection('Tools.shelf', content)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_karma_rop.html","title":"create_karma_rop","text":"<p>Creator plugin to create Karma ROP.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_karma_rop.html#client.ayon_houdini.plugins.create.create_karma_rop.CreateKarmaROP","title":"<code>CreateKarmaROP</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Karma ROP</p> Source code in <code>client/ayon_houdini/plugins/create/create_karma_rop.py</code> <pre><code>class CreateKarmaROP(plugin.HoudiniCreator):\n    \"\"\"Karma ROP\"\"\"\n    identifier = \"io.openpype.creators.houdini.karma_rop\"\n    label = \"Karma ROP\"\n    product_type = \"karma_rop\"\n    icon = \"magic\"\n\n    # Default render target\n    render_target = \"farm\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        import hou  # noqa\n        # Transfer settings from pre create to instance\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n\n        for key in [\"render_target\", \"review\"]:\n            if key in pre_create_data:\n                creator_attributes[key] = pre_create_data[key]\n\n        instance_data.update({\"node_type\": \"karma\"})\n\n        instance = super(CreateKarmaROP, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        ext = pre_create_data.get(\"image_format\")\n\n        renders_dir = hou.text.expandString(\"$HIP/pyblish/renders/\")\n        filepath = f\"{renders_dir}{product_name}/{product_name}.$F4.{ext}\"\n        checkpoint = \"{cp_dir}{product_name}.$F4.checkpoint\".format(\n            cp_dir=hou.text.expandString(\"$HIP/pyblish/\"),\n            product_name=product_name\n        )\n\n        usd_directory = \"{usd_dir}{product_name}_$RENDERID\".format(\n            usd_dir=hou.text.expandString(\"$HIP/pyblish/renders/usd_renders/\"),     # noqa\n            product_name=product_name\n        )\n\n        parms = {\n            # Render Frame Range\n            \"trange\": 1,\n            # Karma ROP Setting\n            \"picture\": filepath,\n            # Karma Checkpoint Setting\n            \"productName\": checkpoint,\n            # USD Output Directory\n            \"savetodirectory\": usd_directory,\n        }\n\n        res_x = pre_create_data.get(\"res_x\")\n        res_y = pre_create_data.get(\"res_y\")\n\n        if self.selected_nodes:\n            # If camera found in selection\n            # we will use as render camera\n            camera = None\n            for node in self.selected_nodes:\n                if node.type().name() == \"cam\":\n                    camera = node.path()\n                    has_camera = pre_create_data.get(\"cam_res\")\n                    if has_camera:\n                        res_x = node.evalParm(\"resx\")\n                        res_y = node.evalParm(\"resy\")\n\n            if not camera:\n                self.log.warning(\"No render camera found in selection\")\n\n            parms.update({\n                \"camera\": camera or \"\",\n                \"resolutionx\": res_x,\n                \"resolutiony\": res_y,\n            })\n\n        instance_node.setParms(parms)\n\n        # Lock some Avalon attributes\n        to_lock = [\"productType\", \"id\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_instance_attr_defs(self):\n        \"\"\"get instance attribute definitions.\n\n        Attributes defined in this method are exposed in\n            publish tab in the publisher UI.\n        \"\"\"\n\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            BoolDef(\"review\",\n                    label=\"Review\",\n                    tooltip=\"Mark as reviewable\",\n                    default=True),\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n\n    def get_pre_create_attr_defs(self):\n        image_format_enum = [\n            \"bmp\", \"cin\", \"exr\", \"jpg\", \"pic\", \"pic.gz\", \"png\",\n            \"rad\", \"rat\", \"rta\", \"sgi\", \"tga\", \"tif\",\n        ]\n\n        attrs = super(CreateKarmaROP, self).get_pre_create_attr_defs()\n\n        attrs += [\n            EnumDef(\"image_format\",\n                    image_format_enum,\n                    default=\"exr\",\n                    label=\"Image Format Options\"),\n            NumberDef(\"res_x\",\n                      label=\"width\",\n                      default=1920,\n                      decimals=0),\n            NumberDef(\"res_y\",\n                      label=\"height\",\n                      default=720,\n                      decimals=0),\n            BoolDef(\"cam_res\",\n                    label=\"Camera Resolution\",\n                    default=False),\n        ]\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_karma_rop.html#client.ayon_houdini.plugins.create.create_karma_rop.CreateKarmaROP.get_instance_attr_defs","title":"<code>get_instance_attr_defs()</code>","text":"<p>get instance attribute definitions.</p> <p>Attributes defined in this method are exposed in     publish tab in the publisher UI.</p> Source code in <code>client/ayon_houdini/plugins/create/create_karma_rop.py</code> <pre><code>def get_instance_attr_defs(self):\n    \"\"\"get instance attribute definitions.\n\n    Attributes defined in this method are exposed in\n        publish tab in the publisher UI.\n    \"\"\"\n\n    render_target_items = {\n        \"local\": \"Local machine rendering\",\n        \"local_no_render\": \"Use existing frames (local)\",\n        \"farm\": \"Farm Rendering\",\n    }\n\n    return [\n        BoolDef(\"review\",\n                label=\"Review\",\n                tooltip=\"Mark as reviewable\",\n                default=True),\n        EnumDef(\"render_target\",\n                items=render_target_items,\n                label=\"Render target\",\n                default=self.render_target)\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_mantra_rop.html","title":"create_mantra_rop","text":"<p>Creator plugin to create Mantra ROP.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_mantra_rop.html#client.ayon_houdini.plugins.create.create_mantra_rop.CreateMantraROP","title":"<code>CreateMantraROP</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Mantra ROP</p> Source code in <code>client/ayon_houdini/plugins/create/create_mantra_rop.py</code> <pre><code>class CreateMantraROP(plugin.HoudiniCreator):\n    \"\"\"Mantra ROP\"\"\"\n    identifier = \"io.openpype.creators.houdini.mantra_rop\"\n    label = \"Mantra ROP\"\n    product_type = \"mantra_rop\"\n    icon = \"magic\"\n\n    # Default render target\n    render_target = \"farm_split\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        import hou  # noqa\n        # Transfer settings from pre create to instance\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        for key in [\"render_target\", \"review\"]:\n            if key in pre_create_data:\n                creator_attributes[key] = pre_create_data[key]\n\n        instance_data.update({\"node_type\": \"ifd\"})\n\n        instance = super(CreateMantraROP, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        ext = pre_create_data.get(\"image_format\")\n\n        renders_dir = hou.text.expandString(\"$HIP/pyblish/renders/\")\n        filepath = f\"{renders_dir}{product_name}/{product_name}.$F4.{ext}\"\n\n        parms = {\n            # Render Frame Range\n            \"trange\": 1,\n            # Mantra ROP Setting\n            \"vm_picture\": filepath,\n        }\n\n        if pre_create_data.get(\"render_target\") == \"farm_split\":\n            export_dir = hou.text.expandString(\"$HIP/pyblish/ifd/\")\n            ifd_filepath = (\n                f\"{export_dir}{product_name}/{product_name}.$F4.ifd\"\n            )\n            parms[\"soho_outputmode\"] = 1\n            parms[\"soho_diskfile\"] = ifd_filepath\n\n        if self.selected_nodes:\n            # If camera found in selection\n            # we will use as render camera\n            camera = None\n            for node in self.selected_nodes:\n                if node.type().name() == \"cam\":\n                    camera = node.path()\n\n            if not camera:\n                self.log.warning(\"No render camera found in selection\")\n\n            parms.update({\"camera\": camera or \"\"})\n\n        custom_res = pre_create_data.get(\"override_resolution\")\n        if custom_res:\n            parms.update({\"override_camerares\": 1})\n        instance_node.setParms(parms)\n\n        # Lock some Avalon attributes\n        to_lock = [\"productType\", \"id\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_instance_attr_defs(self):\n        \"\"\"get instance attribute definitions.\n\n        Attributes defined in this method are exposed in\n            publish tab in the publisher UI.\n        \"\"\"\n\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n            \"farm_split\": \"Farm Rendering - Split export &amp; render jobs\",\n        }\n\n        return [\n            BoolDef(\"review\",\n                    label=\"Review\",\n                    tooltip=\"Mark as reviewable\",\n                    default=True),\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        image_format_enum = [\n            \"bmp\", \"cin\", \"exr\", \"jpg\", \"pic\", \"pic.gz\", \"png\",\n            \"rad\", \"rat\", \"rta\", \"sgi\", \"tga\", \"tif\",\n        ]\n\n        attrs = super(CreateMantraROP, self).get_pre_create_attr_defs()\n\n        attrs += [\n            EnumDef(\"image_format\",\n                    image_format_enum,\n                    default=\"exr\",\n                    label=\"Image Format Options\"),\n            BoolDef(\"override_resolution\",\n                    label=\"Override Camera Resolution\",\n                    tooltip=\"Override the current camera \"\n                            \"resolution, recommended for IPR.\",\n                    default=False),\n        ]\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_mantra_rop.html#client.ayon_houdini.plugins.create.create_mantra_rop.CreateMantraROP.get_instance_attr_defs","title":"<code>get_instance_attr_defs()</code>","text":"<p>get instance attribute definitions.</p> <p>Attributes defined in this method are exposed in     publish tab in the publisher UI.</p> Source code in <code>client/ayon_houdini/plugins/create/create_mantra_rop.py</code> <pre><code>def get_instance_attr_defs(self):\n    \"\"\"get instance attribute definitions.\n\n    Attributes defined in this method are exposed in\n        publish tab in the publisher UI.\n    \"\"\"\n\n    render_target_items = {\n        \"local\": \"Local machine rendering\",\n        \"local_no_render\": \"Use existing frames (local)\",\n        \"farm\": \"Farm Rendering\",\n        \"farm_split\": \"Farm Rendering - Split export &amp; render jobs\",\n    }\n\n    return [\n        BoolDef(\"review\",\n                label=\"Review\",\n                tooltip=\"Mark as reviewable\",\n                default=True),\n        EnumDef(\"render_target\",\n                items=render_target_items,\n                label=\"Render target\",\n                default=self.render_target)\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_model.html","title":"create_model","text":"<p>Creator plugin for creating Model product type.</p> Note <p>Currently, This creator plugin is the same as 'create_pointcache.py' But renaming the product type to 'model'.</p> <p>It's purpose to support Maya (load/publish model from maya to/from houdini).</p> <p>It's considered to support multiple representations in the future.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_model.html#client.ayon_houdini.plugins.create.create_model.CreateModel","title":"<code>CreateModel</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Create Model</p> Source code in <code>client/ayon_houdini/plugins/create/create_model.py</code> <pre><code>class CreateModel(plugin.HoudiniCreator):\n    \"\"\"Create Model\"\"\"\n    identifier = \"io.openpype.creators.houdini.model\"\n    label = \"Model\"\n    product_type = \"model\"\n    icon = \"cube\"\n\n    # Default render target\n    render_target = \"local\"\n\n    def get_publish_families(self):\n        return [\"model\", \"abc\"]\n\n    def create(self, product_name, instance_data, pre_create_data):\n        instance_data.update({\"node_type\": \"alembic\"})\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n\n        instance = super(CreateModel, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n        parms = {\n            \"use_sop_path\": True,\n            \"build_from_path\": True,\n            \"path_attrib\": \"path\",\n            \"prim_to_detail_pattern\": \"cbId\",\n            \"format\": 2,\n            \"facesets\": 0,\n            \"filename\": hou.text.expandString(\n                \"$HIP/pyblish/{}.abc\".format(product_name))\n        }\n\n        if self.selected_nodes:\n            selected_node = self.selected_nodes[0]\n\n            # Although Houdini allows ObjNode path on `sop_path` for the\n            # the ROP node we prefer it set to the SopNode path explicitly\n\n            # Allow sop level paths (e.g. /obj/geo1/box1)\n            if isinstance(selected_node, hou.SopNode):\n                parms[\"sop_path\"] = selected_node.path()\n                self.log.debug(\n                   \"Valid SopNode selection, 'SOP Path' in ROP\"\n                   \" will be set to '%s'.\"\n                   % selected_node.path()\n                )\n\n            # Allow object level paths to Geometry nodes (e.g. /obj/geo1)\n            #   but do not allow other object level nodes types\n            #   like cameras, etc.\n            elif isinstance(selected_node, hou.ObjNode) and \\\n                    selected_node.type().name() in [\"geo\"]:\n\n                # get the output node with the minimum\n                # 'outputidx' or the node with display flag\n                sop_path = self.get_obj_output(selected_node)\n\n                if sop_path:\n                    parms[\"sop_path\"] = sop_path.path()\n                    self.log.debug(\n                        \"Valid ObjNode selection, 'SOP Path' in ROP\"\n                        \" will be set to the child path '%s'.\"\n                        % sop_path.path()\n                    )\n\n            if not parms.get(\"sop_path\", None):\n                self.log.debug(\n                    \"Selection isn't valid. 'SOP Path' in ROP will be empty.\"\n                )\n        else:\n            self.log.debug(\n                \"No Selection. 'SOP Path' in ROP will be empty.\"\n            )\n\n        instance_node.setParms(parms)\n        instance_node.parm(\"trange\").set(1)\n\n        # Explicitly set f1 and f2 to frame start.\n        # Which forces the rop node to export one frame.\n        instance_node.parmTuple('f').deleteAllKeyframes()\n        fstart = int(hou.hscriptExpression(\"$FSTART\"))\n        instance_node.parmTuple('f').set((fstart, fstart, 1))\n\n        # Lock any parameters in this list\n        to_lock = [\"prim_to_detail_pattern\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_network_categories(self):\n        return [\n            hou.ropNodeTypeCategory(),\n            hou.sopNodeTypeCategory()\n        ]\n\n    def get_obj_output(self, obj_node):\n        \"\"\"Find output node with the smallest 'outputidx'.\"\"\"\n\n        outputs = obj_node.subnetOutputs()\n\n        # if obj_node is empty\n        if not outputs:\n            return\n\n        # if obj_node has one output child whether its\n        # sop output node or a node with the render flag\n        elif len(outputs) == 1:\n            return outputs[0]\n\n        # if there are more than one, then it have multiple output nodes\n        # return the one with the minimum 'outputidx'\n        else:\n            return min(outputs,\n                       key=lambda node: node.evalParm('outputidx'))\n\n    def get_instance_attr_defs(self):\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        attrs = super().get_pre_create_attr_defs()\n        # Use same attributes as for instance attributes\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_model.html#client.ayon_houdini.plugins.create.create_model.CreateModel.get_obj_output","title":"<code>get_obj_output(obj_node)</code>","text":"<p>Find output node with the smallest 'outputidx'.</p> Source code in <code>client/ayon_houdini/plugins/create/create_model.py</code> <pre><code>def get_obj_output(self, obj_node):\n    \"\"\"Find output node with the smallest 'outputidx'.\"\"\"\n\n    outputs = obj_node.subnetOutputs()\n\n    # if obj_node is empty\n    if not outputs:\n        return\n\n    # if obj_node has one output child whether its\n    # sop output node or a node with the render flag\n    elif len(outputs) == 1:\n        return outputs[0]\n\n    # if there are more than one, then it have multiple output nodes\n    # return the one with the minimum 'outputidx'\n    else:\n        return min(outputs,\n                   key=lambda node: node.evalParm('outputidx'))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_pointcache.html","title":"create_pointcache","text":"<p>Creator plugin for creating pointcache alembics.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_pointcache.html#client.ayon_houdini.plugins.create.create_pointcache.CreatePointCache","title":"<code>CreatePointCache</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Alembic ROP to pointcache</p> Source code in <code>client/ayon_houdini/plugins/create/create_pointcache.py</code> <pre><code>class CreatePointCache(plugin.HoudiniCreator):\n    \"\"\"Alembic ROP to pointcache\"\"\"\n    identifier = \"io.openpype.creators.houdini.pointcache\"\n    label = \"PointCache (Abc)\"\n    product_type = \"pointcache\"\n    icon = \"gears\"\n\n    # Default render target\n    render_target = \"local\"\n\n    def get_publish_families(self):\n        return [\"pointcache\", \"abc\"]\n\n    def create(self, product_name, instance_data, pre_create_data):\n        instance_data.update({\"node_type\": \"alembic\"})\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n\n        instance = super(CreatePointCache, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n        parms = {\n            \"use_sop_path\": True,\n            \"build_from_path\": True,\n            \"path_attrib\": \"path\",\n            \"prim_to_detail_pattern\": \"cbId\",\n            \"format\": 2,\n            \"facesets\": 0,\n            \"filename\": hou.text.expandString(\n                \"$HIP/pyblish/{}.abc\".format(product_name))\n        }\n\n        if self.selected_nodes:\n            selected_node = self.selected_nodes[0]\n\n            # Although Houdini allows ObjNode path on `sop_path` for the\n            # the ROP node we prefer it set to the SopNode path explicitly\n\n            # Allow sop level paths (e.g. /obj/geo1/box1)\n            if isinstance(selected_node, hou.SopNode):\n                parms[\"sop_path\"] = selected_node.path()\n                self.log.debug(\n                   \"Valid SopNode selection, 'SOP Path' in ROP\"\n                   \" will be set to '%s'.\"\n                   % selected_node.path()\n                )\n\n            # Allow object level paths to Geometry nodes (e.g. /obj/geo1)\n            #   but do not allow other object level nodes types\n            #   like cameras, etc.\n            elif isinstance(selected_node, hou.ObjNode) and \\\n                    selected_node.type().name() in [\"geo\"]:\n\n                # get the output node with the minimum\n                # 'outputidx' or the node with display flag\n                sop_path = self.get_obj_output(selected_node)\n\n                if sop_path:\n                    parms[\"sop_path\"] = sop_path.path()\n                    self.log.debug(\n                        \"Valid ObjNode selection, 'SOP Path' in ROP\"\n                        \" will be set to the child path '%s'.\"\n                        % sop_path.path()\n                    )\n\n            if not parms.get(\"sop_path\", None):\n                self.log.debug(\n                    \"Selection isn't valid. 'SOP Path' in ROP will be empty.\"\n                )\n        else:\n            self.log.debug(\n                \"No Selection. 'SOP Path' in ROP will be empty.\"\n            )\n\n        instance_node.setParms(parms)\n        instance_node.parm(\"trange\").set(1)\n\n        # Lock any parameters in this list\n        to_lock = [\"prim_to_detail_pattern\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_network_categories(self):\n        return [\n            hou.ropNodeTypeCategory(),\n            hou.sopNodeTypeCategory()\n        ]\n\n    def get_obj_output(self, obj_node):\n        \"\"\"Find output node with the smallest 'outputidx'.\"\"\"\n\n        outputs = obj_node.subnetOutputs()\n\n        # if obj_node is empty\n        if not outputs:\n            return\n\n        # if obj_node has one output child whether its\n        # sop output node or a node with the render flag\n        elif len(outputs) == 1:\n            return outputs[0]\n\n        # if there are more than one, then it have multiple output nodes\n        # return the one with the minimum 'outputidx'\n        else:\n            return min(outputs,\n                       key=lambda node: node.evalParm('outputidx'))\n\n    def get_instance_attr_defs(self):\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        attrs = super().get_pre_create_attr_defs()\n        # Use same attributes as for instance attributes\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_pointcache.html#client.ayon_houdini.plugins.create.create_pointcache.CreatePointCache.get_obj_output","title":"<code>get_obj_output(obj_node)</code>","text":"<p>Find output node with the smallest 'outputidx'.</p> Source code in <code>client/ayon_houdini/plugins/create/create_pointcache.py</code> <pre><code>def get_obj_output(self, obj_node):\n    \"\"\"Find output node with the smallest 'outputidx'.\"\"\"\n\n    outputs = obj_node.subnetOutputs()\n\n    # if obj_node is empty\n    if not outputs:\n        return\n\n    # if obj_node has one output child whether its\n    # sop output node or a node with the render flag\n    elif len(outputs) == 1:\n        return outputs[0]\n\n    # if there are more than one, then it have multiple output nodes\n    # return the one with the minimum 'outputidx'\n    else:\n        return min(outputs,\n                   key=lambda node: node.evalParm('outputidx'))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_redshift_proxy.html","title":"create_redshift_proxy","text":"<p>Creator plugin for creating Redshift proxies.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_redshift_proxy.html#client.ayon_houdini.plugins.create.create_redshift_proxy.CreateRedshiftProxy","title":"<code>CreateRedshiftProxy</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Redshift Proxy</p> Source code in <code>client/ayon_houdini/plugins/create/create_redshift_proxy.py</code> <pre><code>class CreateRedshiftProxy(plugin.HoudiniCreator):\n    \"\"\"Redshift Proxy\"\"\"\n    identifier = \"io.openpype.creators.houdini.redshiftproxy\"\n    label = \"Redshift Proxy\"\n    product_type = \"redshiftproxy\"\n    icon = \"magic\"\n\n    # Default render target\n    render_target = \"local\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        # Redshift provides a `Redshift_Proxy_Output` node type which shows\n        # a limited set of parameters by default and is set to extract a\n        # Redshift Proxy. However when \"imprinting\" extra parameters needed\n        # for OpenPype it starts showing all its parameters again. It's unclear\n        # why this happens.\n        # TODO: Somehow enforce so that it only shows the original limited\n        #       attributes of the Redshift_Proxy_Output node type\n        instance_data.update({\"node_type\": \"Redshift_Proxy_Output\"})\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n\n        instance = super(CreateRedshiftProxy, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        parms = {\n            \"RS_archive_file\": '$HIP/pyblish/{}.$F4.rs'.format(product_name),\n        }\n\n        if self.selected_nodes:\n            parms[\"RS_archive_sopPath\"] = self.selected_nodes[0].path()\n\n        instance_node.setParms(parms)\n\n        # Lock some Avalon attributes\n        to_lock = [\"productType\", \"id\", \"prim_to_detail_pattern\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_network_categories(self):\n        return [\n            hou.ropNodeTypeCategory(),\n            hou.sopNodeTypeCategory()\n        ]\n\n    def get_instance_attr_defs(self):\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        attrs = super().get_pre_create_attr_defs()\n        # Use same attributes as for instance attributes\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_redshift_rop.html","title":"create_redshift_rop","text":"<p>Creator plugin to create Redshift ROP.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_redshift_rop.html#client.ayon_houdini.plugins.create.create_redshift_rop.CreateRedshiftROP","title":"<code>CreateRedshiftROP</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Redshift ROP</p> Source code in <code>client/ayon_houdini/plugins/create/create_redshift_rop.py</code> <pre><code>class CreateRedshiftROP(plugin.HoudiniCreator):\n    \"\"\"Redshift ROP\"\"\"\n\n    identifier = \"io.openpype.creators.houdini.redshift_rop\"\n    label = \"Redshift ROP\"\n    product_type = \"redshift_rop\"\n    icon = \"magic\"\n    ext = \"exr\"\n    multi_layered_mode = \"1\"  # No Multi-Layered EXR File\n\n    # Default render target\n    render_target = \"farm_split\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        # Transfer settings from pre create to instance\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        for key in [\"render_target\", \"review\"]:\n            if key in pre_create_data:\n                creator_attributes[key] = pre_create_data[key]\n\n        instance_data.update({\"node_type\": \"Redshift_ROP\"})\n\n        instance = super(CreateRedshiftROP, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        basename = instance_node.name()\n\n        # Also create the linked Redshift IPR Rop\n        try:\n            ipr_rop = instance_node.parent().createNode(\n                \"Redshift_IPR\", node_name=f\"{basename}_IPR\"\n            )\n        except hou.OperationFailed as e:\n            raise CreatorError(\n                (\n                    \"Cannot create Redshift node. Is Redshift \"\n                    \"installed and enabled?\"\n                )\n            ) from e\n\n        # Move it to directly under the Redshift ROP\n        ipr_rop.setPosition(instance_node.position() + hou.Vector2(0, -1))\n\n        # Set the linked rop to the Redshift ROP\n        ipr_rop.parm(\"linked_rop\").set(instance_node.path())\n        ext: int = pre_create_data.get(\"image_format\", 0)\n        multi_layered_mode: str = pre_create_data.get(\n            \"multi_layered_mode\", \"1\")\n\n        ext_format_index = {\"exr\": 0, \"tif\": 1, \"jpg\": 2, \"png\": 3}\n\n        filepath = \"{renders_dir}{product_name}/{product_name}.{fmt}\".format(\n                renders_dir=hou.text.expandString(\"$HIP/pyblish/renders/\"),\n                product_name=product_name,\n                fmt=\"$AOV.$F4.{ext}\".format(ext=ext)\n            )\n\n        if multi_layered_mode == \"1\":\n            multipart = False\n        elif multi_layered_mode == \"2\":\n            multipart = True\n        else:\n            raise ValueError(\n                f\"Unknown value for 'multi_layered_mode': {multi_layered_mode}\"\n            )\n\n        parms = {\n            # Render frame range\n            \"trange\": 1,\n            # Redshift ROP settings\n            \"RS_outputFileNamePrefix\": filepath,\n            \"RS_outputBeautyAOVSuffix\": \"beauty\",\n            \"RS_outputFileFormat\": ext_format_index[ext],\n        }\n        if ext == \"exr\":\n            parms[\"RS_outputMultilayerMode\"] = multi_layered_mode\n            parms[\"RS_aovMultipart\"] = multipart\n\n        if self.selected_nodes:\n            # set up the render camera from the selected node\n            camera = None\n            for node in self.selected_nodes:\n                if node.type().name() == \"cam\":\n                    camera = node.path()\n            parms[\"RS_renderCamera\"] = camera or \"\"\n\n        export_dir = hou.text.expandString(\"$HIP/pyblish/rs/\")\n        rs_filepath = f\"{export_dir}{product_name}/{product_name}.$F4.rs\"\n        parms[\"RS_archive_file\"] = rs_filepath\n\n        if pre_create_data.get(\"render_target\") == \"farm_split\":\n            parms[\"RS_archive_enable\"] = 1\n\n        instance_node.setParms(parms)\n\n        # Lock some Avalon attributes\n        to_lock = [\"productType\", \"id\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            node = instance.data.get(\"instance_node\")\n\n            ipr_node = hou.node(f\"{node}_IPR\")\n            if ipr_node:\n                ipr_node.destroy()\n\n        return super(CreateRedshiftROP, self).remove_instances(instances)\n\n    def get_instance_attr_defs(self):\n        \"\"\"get instance attribute definitions.\n\n        Attributes defined in this method are exposed in\n            publish tab in the publisher UI.\n        \"\"\"\n\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n            \"farm_split\": \"Farm Rendering - Split export &amp; render jobs\",\n        }\n\n        return [\n            BoolDef(\"review\",\n                    label=\"Review\",\n                    tooltip=\"Mark as reviewable\",\n                    default=True),\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n\n        image_format_enum = [\n            \"exr\", \"tif\", \"jpg\", \"png\",\n        ]\n\n        multi_layered_mode = [\n            {\"value\": \"1\", \"label\": \"No Multi-Layered EXR File\"},\n            {\"value\": \"2\", \"label\": \"Full Multi-Layered EXR File\"},\n        ]\n\n        attrs = super(CreateRedshiftROP, self).get_pre_create_attr_defs()\n        attrs += [\n            EnumDef(\"image_format\",\n                    image_format_enum,\n                    default=self.ext,\n                    label=\"Image Format Options\"),\n            EnumDef(\"multi_layered_mode\",\n                    multi_layered_mode,\n                    default=self.multi_layered_mode,\n                    label=\"Multi-Layered EXR\"),\n        ]\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_redshift_rop.html#client.ayon_houdini.plugins.create.create_redshift_rop.CreateRedshiftROP.get_instance_attr_defs","title":"<code>get_instance_attr_defs()</code>","text":"<p>get instance attribute definitions.</p> <p>Attributes defined in this method are exposed in     publish tab in the publisher UI.</p> Source code in <code>client/ayon_houdini/plugins/create/create_redshift_rop.py</code> <pre><code>def get_instance_attr_defs(self):\n    \"\"\"get instance attribute definitions.\n\n    Attributes defined in this method are exposed in\n        publish tab in the publisher UI.\n    \"\"\"\n\n    render_target_items = {\n        \"local\": \"Local machine rendering\",\n        \"local_no_render\": \"Use existing frames (local)\",\n        \"farm\": \"Farm Rendering\",\n        \"farm_split\": \"Farm Rendering - Split export &amp; render jobs\",\n    }\n\n    return [\n        BoolDef(\"review\",\n                label=\"Review\",\n                tooltip=\"Mark as reviewable\",\n                default=True),\n        EnumDef(\"render_target\",\n                items=render_target_items,\n                label=\"Render target\",\n                default=self.render_target)\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_review.html","title":"create_review","text":"<p>Creator plugin for creating openGL reviews.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_review.html#client.ayon_houdini.plugins.create.create_review.CreateReview","title":"<code>CreateReview</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Review with OpenGL ROP</p> Source code in <code>client/ayon_houdini/plugins/create/create_review.py</code> <pre><code>class CreateReview(plugin.HoudiniCreator):\n    \"\"\"Review with OpenGL ROP\"\"\"\n\n    identifier = \"io.openpype.creators.houdini.review\"\n    label = \"Review\"\n    product_type = \"review\"\n    icon = \"video-camera\"\n    review_color_space = \"\"\n    node_type = \"opengl\"\n\n    # Default render target\n    render_target = \"local\"\n\n    # TODO: Publish families should reflect the node type,\n    # such as `rop.flipbook` for flipbook nodes\n    # and `rop.opengl` for OpenGL nodes.\n    def get_publish_families(self):\n        return [\"review\", \"rop.opengl\"]\n\n    def apply_settings(self, project_settings):\n        super(CreateReview, self).apply_settings(project_settings)\n        # workfile settings added in '0.2.13'\n        color_settings = project_settings[\"houdini\"][\"imageio\"].get(\n            \"workfile\", {}\n        )\n        if color_settings.get(\"enabled\"):\n            self.review_color_space = color_settings.get(\"review_color_space\")\n\n    def create(self, product_name, instance_data, pre_create_data):\n        self.node_type = pre_create_data.get(\"node_type\")\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n\n        instance_data.update({\"node_type\": self.node_type})\n        instance_data[\"imageFormat\"] = pre_create_data.get(\"imageFormat\")\n        instance_data[\"keepImages\"] = pre_create_data.get(\"keepImages\")\n\n        instance = super(CreateReview, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        frame_range = hou.playbar.frameRange()\n\n        filepath = \"{root}/{product_name}/{product_name}.$F4.{ext}\".format(\n            root=hou.text.expandString(\"$HIP/pyblish\"),\n            # keep dynamic link to product name\n            product_name=\"`chs(\\\"AYON_productName\\\")`\",\n            ext=pre_create_data.get(\"image_format\") or \"png\"\n        )\n\n        parms = {\n            \"picture\": filepath,\n\n            \"trange\": 1,\n\n            # Unlike many other ROP nodes the opengl node does not default\n            # to expression of $FSTART and $FEND so we preserve that behavior\n            # but do set the range to the frame range of the playbar\n            \"f1\": frame_range[0],\n            \"f2\": frame_range[1],\n        }\n\n        override_resolution = pre_create_data.get(\"override_resolution\")\n        if override_resolution:\n            parms.update({\n                \"tres\": override_resolution,\n                \"res1\": pre_create_data.get(\"resx\"),\n                \"res2\": pre_create_data.get(\"resy\"),\n                \"aspect\": pre_create_data.get(\"aspect\"),\n            })\n\n        if self.selected_nodes:\n            # The first camera found in selection we will use as camera\n            # Other node types we set in force objects\n            camera = None\n            force_objects = []\n            for node in self.selected_nodes:\n                path = node.path()\n                if node.type().name() == \"cam\":\n                    if camera:\n                        continue\n                    camera = path\n                else:\n                    force_objects.append(path)\n\n            if not camera:\n                self.log.warning(\"No camera found in selection.\")\n\n            parms.update({\n                \"camera\": camera or \"\",\n                \"scenepath\": \"/obj\",\n                \"forceobjects\": \" \".join(force_objects),\n                \"vobjects\": \"\"  # clear candidate objects from '*' value\n            })\n\n        instance_node.setParms(parms)\n\n        # Set OCIO Colorspace to the default colorspace\n        #  if there's OCIO\n        if os.getenv(\"OCIO\"):\n            # Fall to the default value if cls.review_color_space is empty.\n            if not self.review_color_space:\n                # cls.review_color_space is an empty string\n                #  when the imageio/workfile setting is disabled or\n                #  when the Review colorspace setting is empty.\n                from ayon_houdini.api.colorspace import get_default_display_view_colorspace  # noqa\n                self.review_color_space = get_default_display_view_colorspace()\n\n            lib.set_review_color_space(instance_node,\n                                       self.review_color_space,\n                                       self.log)\n\n        to_lock = [\"id\", \"productType\"]\n\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_instance_attr_defs(self):\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        attrs = super().get_pre_create_attr_defs()\n\n        image_format_enum = [\n            \"bmp\", \"cin\", \"exr\", \"jpg\", \"pic\", \"pic.gz\", \"png\",\n            \"rad\", \"rat\", \"rta\", \"sgi\", \"tga\", \"tif\",\n        ]\n        node_type_enum = [\"opengl\"]\n        if hou.applicationVersion() &gt;= (20, 5, 0):\n            node_type_enum.append(\"flipbook\")\n\n        return attrs + [\n            EnumDef(\"node_type\",\n                    node_type_enum,\n                    default=self.node_type,\n                    label=\"Node Type\"),\n            BoolDef(\"keepImages\",\n                    label=\"Keep Image Sequences\",\n                    default=False),\n            EnumDef(\"imageFormat\",\n                    image_format_enum,\n                    default=\"png\",\n                    label=\"Image Format Options\"),\n            BoolDef(\"override_resolution\",\n                    label=\"Override resolution\",\n                    tooltip=\"When disabled the resolution set on the camera \"\n                            \"is used instead.\",\n                    default=True),\n            NumberDef(\"resx\",\n                      label=\"Resolution Width\",\n                      default=1280,\n                      minimum=2,\n                      decimals=0),\n            NumberDef(\"resy\",\n                      label=\"Resolution Height\",\n                      default=720,\n                      minimum=2,\n                      decimals=0),\n            NumberDef(\"aspect\",\n                      label=\"Aspect Ratio\",\n                      default=1.0,\n                      minimum=0.0001,\n                      decimals=3)\n        ] + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_rig.html","title":"create_rig","text":""},{"location":"autoapi/client/ayon_houdini/plugins/create/create_rig.html#client.ayon_houdini.plugins.create.create_rig.CreateRig","title":"<code>CreateRig</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>APEX Rig (bgeo) creator.</p> Source code in <code>client/ayon_houdini/plugins/create/create_rig.py</code> <pre><code>class CreateRig(plugin.HoudiniCreator):\n    \"\"\"APEX Rig (bgeo) creator.\"\"\"\n    identifier = \"io.ayon.creators.houdini.bgeo.rig\"\n    label = \"Rig\"\n    product_type = \"rig\"\n    icon = \"wheelchair\"\n\n    description = \"APEX rig exported as BGEO file\"\n\n    def get_detail_description(self):\n        return inspect.cleandoc(\n            \"\"\"Write a BGEO output file as `rig` product type. This can be\n            used to publish APEX rigs which are in essence just SOP-level\n            data representing a rig structure.\"\"\"\n        )\n\n    def get_publish_families(self):\n        return [\"rig\", \"bgeo\"]\n\n    def create(self, product_name, instance_data, pre_create_data):\n        instance = super().create(product_name, instance_data, pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        file_path = \"{}{}\".format(\n            hou.text.expandString(\"$HIP/pyblish/\"),\n            \"{}.$F4.{}\".format(\n                product_name,\n                pre_create_data.get(\"bgeo_type\") or \"bgeo.sc\")\n        )\n        parms = {\n            \"sopoutput\": file_path\n        }\n\n        if self.selected_nodes:\n            # if selection is on SOP level, use it\n            if isinstance(self.selected_nodes[0], hou.SopNode):\n                parms[\"soppath\"] = self.selected_nodes[0].path()\n            else:\n                # try to find output node with the lowest index\n                outputs = [\n                    child for child in self.selected_nodes[0].children()\n                    if child.type().name() == \"output\"\n                ]\n                if not outputs:\n                    instance_node.setParms(parms)\n                    raise CreatorError((\n                        \"Missing output node in SOP level for the selection. \"\n                        \"Please select correct SOP path in created instance.\"\n                    ))\n                outputs.sort(key=lambda output: output.evalParm(\"outputidx\"))\n                parms[\"soppath\"] = outputs[0].path()\n\n        instance_node.setParms(parms)\n\n    def get_pre_create_attr_defs(self):\n        attrs = super().get_pre_create_attr_defs()\n        bgeo_enum = [\n            {\n                \"value\": \"bgeo\",\n                \"label\": \"uncompressed bgeo (.bgeo)\"\n            },\n            {\n                \"value\": \"bgeosc\",\n                \"label\": \"BLOSC compressed bgeo (.bgeosc)\"\n            },\n            {\n                \"value\": \"bgeo.sc\",\n                \"label\": \"BLOSC compressed bgeo (.bgeo.sc)\"\n            },\n            {\n                \"value\": \"bgeo.gz\",\n                \"label\": \"GZ compressed bgeo (.bgeo.gz)\"\n            },\n            {\n                \"value\": \"bgeo.lzma\",\n                \"label\": \"LZMA compressed bgeo (.bgeo.lzma)\"\n            },\n            {\n                \"value\": \"bgeo.bz2\",\n                \"label\": \"BZip2 compressed bgeo (.bgeo.bz2)\"\n            }\n        ]\n\n        return attrs + [\n            EnumDef(\n                \"bgeo_type\",\n                bgeo_enum,\n                default=\"bgeo.sc\",\n                label=\"BGEO Options\"\n            ),\n        ] + self.get_instance_attr_defs()\n\n    def get_network_categories(self):\n        return [\n            hou.ropNodeTypeCategory(),\n            hou.sopNodeTypeCategory()\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_usd.html","title":"create_usd","text":"<p>Creator plugin for creating USDs.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_usd.html#client.ayon_houdini.plugins.create.create_usd.CreateUSD","title":"<code>CreateUSD</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>Universal Scene Description</p> Source code in <code>client/ayon_houdini/plugins/create/create_usd.py</code> <pre><code>class CreateUSD(plugin.HoudiniCreator):\n    \"\"\"Universal Scene Description\"\"\"\n    identifier = \"io.openpype.creators.houdini.usd\"\n    label = \"USD\"\n    product_type = \"usd\"\n    icon = \"cubes\"\n    enabled = False\n    description = \"Create USD\"\n\n    # Default render target\n    render_target = \"local\"\n\n    additional_parameters = {}\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        instance_data.update({\"node_type\": \"usd\"})\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n\n        instance = super(CreateUSD, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        parms = {\n            \"lopoutput\": \"$HIP/pyblish/{}.usd\".format(product_name),\n            \"enableoutputprocessor_simplerelativepaths\": False,\n        }\n        parms.update(self.additional_parameters)\n\n        if self.selected_nodes:\n            parms[\"loppath\"] = self.selected_nodes[0].path()\n\n        instance_node.setParms(parms)\n\n        # Lock any parameters in this list\n        to_lock = [\n            \"fileperframe\",\n            # Lock some Avalon attributes\n            \"productType\",\n            \"id\",\n        ]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_network_categories(self):\n        return [\n            hou.ropNodeTypeCategory(),\n            hou.lopNodeTypeCategory()\n        ]\n\n    def get_publish_families(self):\n        return [\"usd\", \"usdrop\"]\n\n    def get_instance_attr_defs(self):\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        attrs = super().get_pre_create_attr_defs()\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_usd.html#client.ayon_houdini.plugins.create.create_usd.CreateUSDLook","title":"<code>CreateUSDLook</code>","text":"<p>               Bases: <code>CreateUSD</code></p> <p>Universal Scene Description Look</p> Source code in <code>client/ayon_houdini/plugins/create/create_usd.py</code> <pre><code>class CreateUSDLook(CreateUSD):\n    \"\"\"Universal Scene Description Look\"\"\"\n\n    identifier = \"io.openpype.creators.houdini.usd.look\"\n    label = \"USD Look\"\n    product_type = \"look\"\n    icon = \"paint-brush\"\n    enabled = True\n    description = \"Create USD Look with localized textures\"\n\n    additional_parameters = {\n        # Set the 'default prim' by default to the folder name being\n        # published to\n        \"defaultprim\": '/`strsplit(chs(\"folderPath\"), \"/\", -1)`',\n    }\n\n    def get_detail_description(self):\n        return inspect.cleandoc(\"\"\"Publish looks in USD data.\n\n        From the Houdini Solaris context (LOPs) this will publish the look for\n        an asset as a USD file with the used textures.\n\n        Any assets used by the look will be relatively remapped to the USD\n        file and integrated into the publish as `resources`.\n        \"\"\")\n\n    def get_publish_families(self):\n        return [\"usd\", \"look\", \"usdrop\"]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_usd_componentbuilder.html","title":"create_usd_componentbuilder","text":""},{"location":"autoapi/client/ayon_houdini/plugins/create/create_usdrender.html","title":"create_usdrender","text":"<p>Creator plugin for creating USD renders.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_usdrender.html#client.ayon_houdini.plugins.create.create_usdrender.CreateUSDRender","title":"<code>CreateUSDRender</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>USD Render ROP in /stage</p> Source code in <code>client/ayon_houdini/plugins/create/create_usdrender.py</code> <pre><code>class CreateUSDRender(plugin.HoudiniCreator):\n    \"\"\"USD Render ROP in /stage\"\"\"\n    identifier = \"io.openpype.creators.houdini.usdrender\"\n    label = \"USD Render\"\n    product_type = \"usdrender\"\n    icon = \"magic\"\n    description = \"Create USD Render\"\n\n    default_renderer = \"Karma CPU\"\n    # Default render target\n    render_target = \"farm_split\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        # Transfer settings from pre create to instance\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n\n        for key in [\"render_target\", \"review\"]:\n            if key in pre_create_data:\n                creator_attributes[key] = pre_create_data[key]\n\n        # TODO: Support creation in /stage if wanted by user\n        # pre_create_data[\"parent\"] = \"/stage\"\n\n        instance_data.update({\"node_type\": \"usdrender\"})\n\n        # Override default value for the Export Chunk Size because if the\n        # a single USD file is written as opposed to per frame we want to\n        # ensure only one machine picks up that sequence\n        # TODO: Probably better to change the default somehow for just this\n        #    Creator on the HoudiniSubmitDeadline plug-in, if possible?\n        (\n            instance_data\n            .setdefault(\"publish_attributes\", {})\n            .setdefault(\"HoudiniSubmitDeadlineUsdRender\", {})[\"export_chunk\"]\n        ) = 1000\n\n        instance = super(CreateUSDRender, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        parms = {\n            # Render frame range\n            \"trange\": 1\n        }\n        if self.selected_nodes:\n            parms[\"loppath\"] = self.selected_nodes[0].path()\n\n        if pre_create_data.get(\"render_target\") == \"farm_split\":\n            # Do not trigger the husk render, only trigger the USD export\n            parms[\"runcommand\"] = False\n            # By default, the render ROP writes out the render file to a\n            # temporary directory. But if we want to render the USD file on\n            # the farm we instead want it in the project available\n            # to all machines. So we ensure all USD files are written to a\n            # folder to our choice. The\n            # `__render__.usd` (default name, defined by `lopoutput` parm)\n            # in that folder will then be the file to render.\n            parms[\"savetodirectory_directory\"] = \"$HIP/render/usd/$HIPNAME/$OS\"\n            parms[\"lopoutput\"] = \"__render__.usd\"\n            parms[\"allframesatonce\"] = True\n\n        # By default strip any Houdini custom data from the output file\n        # since the renderer doesn't care about it\n        parms[\"clearhoudinicustomdata\"] = True\n\n        # Use the first selected LOP node if \"Use Selection\" is enabled\n        # and the user had any nodes selected\n        if self.selected_nodes:\n            for node in self.selected_nodes:\n                if node.type().category() == hou.lopNodeTypeCategory():\n                    parms[\"loppath\"] = node.path()\n                    break\n\n        # Set default renderer if defined in settings\n        if pre_create_data.get(\"renderer\"):\n            parms[\"renderer\"] = pre_create_data.get(\"renderer\")\n\n        instance_node.setParms(parms)\n\n        # Lock some AYON attributes\n        to_lock = [\"productType\", \"id\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def get_instance_attr_defs(self):\n        \"\"\"get instance attribute definitions.\n        Attributes defined in this method are exposed in\n            publish tab in the publisher UI.\n        \"\"\"\n\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n            \"farm_split\": \"Farm Rendering - Split export &amp; render jobs\",\n        }\n\n        return [\n            BoolDef(\"review\",\n                    label=\"Review\",\n                    tooltip=\"Mark as reviewable\",\n                    default=True),\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n\n        # Retrieve available renderers and convert default renderer to\n        # plug-in name if settings provided the display name\n        renderer_plugin_to_display_name = get_usd_rop_renderers()\n        default_renderer = self.default_renderer or None\n        if (\n            default_renderer\n            and default_renderer not in renderer_plugin_to_display_name\n        ):\n            # Map default renderer display name to plugin name\n            for name, display_name in renderer_plugin_to_display_name.items():\n                if default_renderer == display_name:\n                    default_renderer = name\n                    break\n            else:\n                # Default renderer not found in available renderers\n                default_renderer = None\n\n        attrs = super(CreateUSDRender, self).get_pre_create_attr_defs()\n        attrs += [\n            EnumDef(\"renderer\",\n                    label=\"Renderer\",\n                    default=default_renderer,\n                    items=renderer_plugin_to_display_name),\n        ]\n\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_usdrender.html#client.ayon_houdini.plugins.create.create_usdrender.CreateUSDRender.get_instance_attr_defs","title":"<code>get_instance_attr_defs()</code>","text":"<p>get instance attribute definitions. Attributes defined in this method are exposed in     publish tab in the publisher UI.</p> Source code in <code>client/ayon_houdini/plugins/create/create_usdrender.py</code> <pre><code>def get_instance_attr_defs(self):\n    \"\"\"get instance attribute definitions.\n    Attributes defined in this method are exposed in\n        publish tab in the publisher UI.\n    \"\"\"\n\n    render_target_items = {\n        \"local\": \"Local machine rendering\",\n        \"local_no_render\": \"Use existing frames (local)\",\n        \"farm\": \"Farm Rendering\",\n        \"farm_split\": \"Farm Rendering - Split export &amp; render jobs\",\n    }\n\n    return [\n        BoolDef(\"review\",\n                label=\"Review\",\n                tooltip=\"Mark as reviewable\",\n                default=True),\n        EnumDef(\"render_target\",\n                items=render_target_items,\n                label=\"Render target\",\n                default=self.render_target)\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_usdrender.html#client.ayon_houdini.plugins.create.create_usdrender.get_usd_rop_renderers","title":"<code>get_usd_rop_renderers()</code>","text":"<p>Return all available renderers supported by USD Render ROP. Note that the USD Render ROP does not include all Hydra renderers, because it excludes the GL ones like Houdini GL and Storm. USD Render ROP only lists the renderers that have <code>aovsupport</code> enabled. Also see:     https://www.sidefx.com/docs/houdini/nodes/out/usdrender.html#list Returns:     dict[str, str]: Plug-in name to display name mapping.</p> Source code in <code>client/ayon_houdini/plugins/create/create_usdrender.py</code> <pre><code>def get_usd_rop_renderers():\n    \"\"\"Return all available renderers supported by USD Render ROP.\n    Note that the USD Render ROP does not include all Hydra renderers, because\n    it excludes the GL ones like Houdini GL and Storm. USD Render ROP only\n    lists the renderers that have `aovsupport` enabled. Also see:\n        https://www.sidefx.com/docs/houdini/nodes/out/usdrender.html#list\n    Returns:\n        dict[str, str]: Plug-in name to display name mapping.\n    \"\"\"\n    return {\n        info[\"name\"]: info[\"displayname\"] for info\n        in hou.lop.availableRendererInfo() if info.get('aovsupport')\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_vbd_cache.html","title":"create_vbd_cache","text":"<p>Creator plugin for creating VDB Caches.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_vbd_cache.html#client.ayon_houdini.plugins.create.create_vbd_cache.CreateVDBCache","title":"<code>CreateVDBCache</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>OpenVDB from Geometry ROP</p> Source code in <code>client/ayon_houdini/plugins/create/create_vbd_cache.py</code> <pre><code>class CreateVDBCache(plugin.HoudiniCreator):\n    \"\"\"OpenVDB from Geometry ROP\"\"\"\n    identifier = \"io.openpype.creators.houdini.vdbcache\"\n    name = \"vbdcache\"\n    label = \"VDB Cache\"\n    product_type = \"vdbcache\"\n    icon = \"cloud\"\n\n    # Default render target\n    render_target = \"local\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        import hou\n\n        instance_data.update({\"node_type\": \"geometry\"})\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n        instance = super(CreateVDBCache, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n        file_path = \"{}{}\".format(\n            hou.text.expandString(\"$HIP/pyblish/\"),\n            \"{}.$F4.vdb\".format(product_name))\n        parms = {\n            \"sopoutput\": file_path,\n            \"initsim\": True,\n            \"trange\": 1\n        }\n\n        if self.selected_nodes:\n            parms[\"soppath\"] = self.get_sop_node_path(self.selected_nodes[0])\n\n        instance_node.setParms(parms)\n\n    def get_network_categories(self):\n        return [\n            hou.ropNodeTypeCategory(),\n            hou.objNodeTypeCategory(),\n            hou.sopNodeTypeCategory()\n        ]\n\n    def get_sop_node_path(self, selected_node):\n        \"\"\"Get Sop Path of the selected node.\n\n        Although Houdini allows ObjNode path on `sop_path` for the\n        the ROP node, we prefer it set to the SopNode path explicitly.\n        \"\"\"\n\n        # Allow sop level paths (e.g. /obj/geo1/box1)\n        if isinstance(selected_node, hou.SopNode):\n            self.log.debug(\n                \"Valid SopNode selection, 'SOP Path' in ROP will\"\n                \" be set to '%s'.\", selected_node.path()\n            )\n            return selected_node.path()\n\n        # Allow object level paths to Geometry nodes (e.g. /obj/geo1)\n        # but do not allow other object level nodes types like cameras, etc.\n        elif isinstance(selected_node, hou.ObjNode) and \\\n                selected_node.type().name() == \"geo\":\n\n            # Try to find output node.\n            sop_node = self.get_obj_output(selected_node)\n            if sop_node:\n                self.log.debug(\n                    \"Valid ObjNode selection, 'SOP Path' in ROP will \"\n                    \"be set to the child path '%s'.\", sop_node.path()\n                )\n                return sop_node.path()\n\n        self.log.debug(\n            \"Selection isn't valid. 'SOP Path' in ROP will be empty.\"\n        )\n        return \"\"\n\n    def get_obj_output(self, obj_node):\n        \"\"\"Try to find output node.\n\n        If any output nodes are present, return the output node with\n          the minimum 'outputidx'\n        If no output nodes are present, return the node with display flag\n        If no nodes are present at all, return None\n        \"\"\"\n\n        outputs = obj_node.subnetOutputs()\n\n        # if obj_node is empty\n        if not outputs:\n            return\n\n        # if obj_node has one output child whether its\n        # sop output node or a node with the render flag\n        elif len(outputs) == 1:\n            return outputs[0]\n\n        # if there are more than one, then it has multiple output nodes\n        # return the one with the minimum 'outputidx'\n        else:\n            return min(outputs,\n                       key=lambda node: node.evalParm('outputidx'))\n\n    def get_instance_attr_defs(self):\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        return [\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        attrs = super().get_pre_create_attr_defs()\n        # Use same attributes as for instance attributes\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_vbd_cache.html#client.ayon_houdini.plugins.create.create_vbd_cache.CreateVDBCache.get_obj_output","title":"<code>get_obj_output(obj_node)</code>","text":"<p>Try to find output node.</p> <p>If any output nodes are present, return the output node with   the minimum 'outputidx' If no output nodes are present, return the node with display flag If no nodes are present at all, return None</p> Source code in <code>client/ayon_houdini/plugins/create/create_vbd_cache.py</code> <pre><code>def get_obj_output(self, obj_node):\n    \"\"\"Try to find output node.\n\n    If any output nodes are present, return the output node with\n      the minimum 'outputidx'\n    If no output nodes are present, return the node with display flag\n    If no nodes are present at all, return None\n    \"\"\"\n\n    outputs = obj_node.subnetOutputs()\n\n    # if obj_node is empty\n    if not outputs:\n        return\n\n    # if obj_node has one output child whether its\n    # sop output node or a node with the render flag\n    elif len(outputs) == 1:\n        return outputs[0]\n\n    # if there are more than one, then it has multiple output nodes\n    # return the one with the minimum 'outputidx'\n    else:\n        return min(outputs,\n                   key=lambda node: node.evalParm('outputidx'))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_vbd_cache.html#client.ayon_houdini.plugins.create.create_vbd_cache.CreateVDBCache.get_sop_node_path","title":"<code>get_sop_node_path(selected_node)</code>","text":"<p>Get Sop Path of the selected node.</p> <p>Although Houdini allows ObjNode path on <code>sop_path</code> for the the ROP node, we prefer it set to the SopNode path explicitly.</p> Source code in <code>client/ayon_houdini/plugins/create/create_vbd_cache.py</code> <pre><code>def get_sop_node_path(self, selected_node):\n    \"\"\"Get Sop Path of the selected node.\n\n    Although Houdini allows ObjNode path on `sop_path` for the\n    the ROP node, we prefer it set to the SopNode path explicitly.\n    \"\"\"\n\n    # Allow sop level paths (e.g. /obj/geo1/box1)\n    if isinstance(selected_node, hou.SopNode):\n        self.log.debug(\n            \"Valid SopNode selection, 'SOP Path' in ROP will\"\n            \" be set to '%s'.\", selected_node.path()\n        )\n        return selected_node.path()\n\n    # Allow object level paths to Geometry nodes (e.g. /obj/geo1)\n    # but do not allow other object level nodes types like cameras, etc.\n    elif isinstance(selected_node, hou.ObjNode) and \\\n            selected_node.type().name() == \"geo\":\n\n        # Try to find output node.\n        sop_node = self.get_obj_output(selected_node)\n        if sop_node:\n            self.log.debug(\n                \"Valid ObjNode selection, 'SOP Path' in ROP will \"\n                \"be set to the child path '%s'.\", sop_node.path()\n            )\n            return sop_node.path()\n\n    self.log.debug(\n        \"Selection isn't valid. 'SOP Path' in ROP will be empty.\"\n    )\n    return \"\"\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_vray_rop.html","title":"create_vray_rop","text":"<p>Creator plugin to create VRay ROP.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_vray_rop.html#client.ayon_houdini.plugins.create.create_vray_rop.CreateVrayROP","title":"<code>CreateVrayROP</code>","text":"<p>               Bases: <code>HoudiniCreator</code></p> <p>VRay ROP</p> Source code in <code>client/ayon_houdini/plugins/create/create_vray_rop.py</code> <pre><code>class CreateVrayROP(plugin.HoudiniCreator):\n    \"\"\"VRay ROP\"\"\"\n\n    identifier = \"io.openpype.creators.houdini.vray_rop\"\n    label = \"VRay ROP\"\n    product_type = \"vray_rop\"\n    icon = \"magic\"\n    ext = \"exr\"\n\n    # Default render target\n    render_target = \"farm_split\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        # Transfer settings from pre create to instance\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        for key in [\"render_target\", \"review\"]:\n            if key in pre_create_data:\n                creator_attributes[key] = pre_create_data[key]\n\n        instance_data.update({\"node_type\": \"vray_renderer\"})\n\n        instance = super(CreateVrayROP, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        instance_node = hou.node(instance.get(\"instance_node\"))\n\n        # Add IPR for Vray\n        basename = instance_node.name()\n        try:\n            ipr_rop = instance_node.parent().createNode(\n                \"vray\", node_name=basename + \"_IPR\"\n            )\n        except hou.OperationFailed:\n            raise CreatorError(\n                \"Cannot create Vray render node. \"\n                \"Make sure Vray installed and enabled!\"\n            )\n\n        ipr_rop.setPosition(instance_node.position() + hou.Vector2(0, -1))\n        ipr_rop.parm(\"rop\").set(instance_node.path())\n\n        parms = {\n            \"trange\": 1,\n            \"SettingsEXR_bits_per_channel\": \"16\"   # half precision\n        }\n\n        if pre_create_data.get(\"render_target\") == \"farm_split\":\n            export_dir = hou.text.expandString(\"$HIP/pyblish/vrscene/\")\n            scene_filepath = (\n                f\"{export_dir}{product_name}/{product_name}.$F4.vrscene\"\n            )\n            # Setting render_export_mode to \"2\" because that's for\n            # \"Export only\" (\"1\" is for \"Export &amp; Render\")\n            parms[\"render_export_mode\"] = \"2\"\n            parms[\"render_export_filepath\"] = scene_filepath\n\n        if self.selected_nodes:\n            # set up the render camera from the selected node\n            camera = None\n            for node in self.selected_nodes:\n                if node.type().name() == \"cam\":\n                    camera = node.path()\n            parms.update({\n                \"render_camera\": camera or \"\"\n            })\n\n        # Enable render element\n        ext = pre_create_data.get(\"image_format\")\n        instance_data[\"RenderElement\"] = pre_create_data.get(\"render_element_enabled\")         # noqa\n        if pre_create_data.get(\"render_element_enabled\", True):\n            # Vray has its own tag for AOV file output\n            renders_dir = hou.text.expandString(\"$HIP/pyblish/renders/\")\n            filepath = (\n                f\"{renders_dir}{product_name}/{product_name}.$AOV.$F4.{ext}\"\n            )\n\n            re_rop = instance_node.parent().createNode(\n                \"vray_render_channels\",\n                node_name=basename + \"_render_element\"\n            )\n            # move the render element node next to the vray renderer node\n            re_rop.setPosition(instance_node.position() + hou.Vector2(0, 1))\n            re_path = re_rop.path()\n            parms.update({\n                \"use_render_channels\": 1,\n                \"SettingsOutput_img_file_path\": filepath,\n                \"render_network_render_channels\": re_path\n            })\n\n        else:\n            renders_dir = hou.text.expandString(\"$HIP/pyblish/renders/\")\n            filepath = f\"{renders_dir}{product_name}/{product_name}.$F4.{ext}\"\n            parms.update({\n                \"use_render_channels\": 0,\n                \"SettingsOutput_img_file_path\": filepath\n            })\n\n        custom_res = pre_create_data.get(\"override_resolution\")\n        if custom_res:\n            parms.update({\"override_camerares\": 1})\n\n        instance_node.setParms(parms)\n\n        # lock parameters from AVALON\n        to_lock = [\"productType\", \"id\"]\n        self.lock_parameters(instance_node, to_lock)\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            node = instance.data.get(\"instance_node\")\n            # for the extra render node from the plugins\n            # such as vray and redshift\n            ipr_node = hou.node(\"{}{}\".format(node, \"_IPR\"))\n            if ipr_node:\n                ipr_node.destroy()\n            re_node = hou.node(\"{}{}\".format(node,\n                                             \"_render_element\"))\n            if re_node:\n                re_node.destroy()\n\n        return super(CreateVrayROP, self).remove_instances(instances)\n\n    def get_instance_attr_defs(self):\n        \"\"\"get instance attribute definitions.\n\n        Attributes defined in this method are exposed in\n            publish tab in the publisher UI.\n        \"\"\"\n\n\n        render_target_items = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n            \"farm_split\": \"Farm Rendering - Split export &amp; render jobs\",\n        }\n\n        return [\n            BoolDef(\"review\",\n                    label=\"Review\",\n                    tooltip=\"Mark as reviewable\",\n                    default=True),\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        image_format_enum = [\n            \"bmp\", \"cin\", \"exr\", \"jpg\", \"pic\", \"pic.gz\", \"png\",\n            \"rad\", \"rat\", \"rta\", \"sgi\", \"tga\", \"tif\",\n        ]\n\n        attrs = super(CreateVrayROP, self).get_pre_create_attr_defs()\n\n        attrs += [\n            EnumDef(\"image_format\",\n                    image_format_enum,\n                    default=self.ext,\n                    label=\"Image Format Options\"),\n            BoolDef(\"override_resolution\",\n                    label=\"Override Camera Resolution\",\n                    tooltip=\"Override the current camera \"\n                            \"resolution, recommended for IPR.\",\n                    default=False),\n            BoolDef(\"render_element_enabled\",\n                    label=\"Render Element\",\n                    tooltip=\"Create Render Element Node \"\n                            \"if enabled\",\n                    default=False)\n        ]\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_vray_rop.html#client.ayon_houdini.plugins.create.create_vray_rop.CreateVrayROP.get_instance_attr_defs","title":"<code>get_instance_attr_defs()</code>","text":"<p>get instance attribute definitions.</p> <p>Attributes defined in this method are exposed in     publish tab in the publisher UI.</p> Source code in <code>client/ayon_houdini/plugins/create/create_vray_rop.py</code> <pre><code>def get_instance_attr_defs(self):\n    \"\"\"get instance attribute definitions.\n\n    Attributes defined in this method are exposed in\n        publish tab in the publisher UI.\n    \"\"\"\n\n\n    render_target_items = {\n        \"local\": \"Local machine rendering\",\n        \"local_no_render\": \"Use existing frames (local)\",\n        \"farm\": \"Farm Rendering\",\n        \"farm_split\": \"Farm Rendering - Split export &amp; render jobs\",\n    }\n\n    return [\n        BoolDef(\"review\",\n                label=\"Review\",\n                tooltip=\"Mark as reviewable\",\n                default=True),\n        EnumDef(\"render_target\",\n                items=render_target_items,\n                label=\"Render target\",\n                default=self.render_target)\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_workfile.html","title":"create_workfile","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/create/create_workfile.html#client.ayon_houdini.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>HoudiniCreatorBase</code>, <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_houdini/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(plugin.HoudiniCreatorBase, AutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    identifier = \"io.openpype.creators.houdini.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    icon = \"fa5.file\"\n\n    default_variant = \"Main\"\n\n    def create(self):\n        variant = self.default_variant\n        current_instance = next(\n            (\n                instance for instance in self.create_context.instances\n                if instance.creator_identifier == self.identifier\n            ), None)\n\n        project_entity = self.create_context.get_current_project_entity()\n        project_name = project_entity[\"name\"]\n        folder_entity = self.create_context.get_current_folder_entity()\n        folder_path = folder_entity[\"path\"]\n        task_entity = self.create_context.get_current_task_entity()\n        task_name = task_entity[\"name\"]\n        host_name = self.create_context.host_name\n\n        if current_instance is None:\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n            )\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": variant,\n            }\n\n            data.update(\n                self.get_dynamic_data(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    variant,\n                    host_name,\n                    current_instance)\n            )\n            self.log.info(\"Auto-creating workfile instance...\")\n            current_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(current_instance)\n        elif (\n            current_instance[\"folderPath\"] != folder_path\n            or current_instance[\"task\"] != task_name\n        ):\n            # Update instance context if is not the same\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n            )\n            current_instance[\"folderPath\"] = folder_path\n            current_instance[\"task\"] = task_name\n            current_instance[\"productName\"] = product_name\n\n        # write workfile information to context container.\n        op_ctx = hou.node(CONTEXT_CONTAINER)\n        if not op_ctx:\n            op_ctx = self.host.create_context_node()\n\n        workfile_data = {\"workfile\": current_instance.data_to_store()}\n        imprint(op_ctx, workfile_data)\n\n    def collect_instances(self):\n        op_ctx = hou.node(CONTEXT_CONTAINER)\n        instance = read(op_ctx)\n        if not instance:\n            return\n        workfile = instance.get(\"workfile\")\n        if not workfile:\n            return\n        created_instance = CreatedInstance.from_existing(\n            workfile, self\n        )\n        self._add_instance_to_context(created_instance)\n\n    def update_instances(self, update_list):\n        op_ctx = hou.node(CONTEXT_CONTAINER)\n        for created_inst, _changes in update_list:\n            if created_inst[\"creator_identifier\"] == self.identifier:\n                workfile_data = {\"workfile\": created_inst.data_to_store()}\n                imprint(op_ctx, workfile_data, update=True)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/inventory/index.html","title":"inventory","text":""},{"location":"autoapi/client/ayon_houdini/plugins/inventory/select_containers.html","title":"select_containers","text":""},{"location":"autoapi/client/ayon_houdini/plugins/inventory/select_containers.html#client.ayon_houdini.plugins.inventory.select_containers.SelectInScene","title":"<code>SelectInScene</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Select nodes in the scene from selected containers in scene inventory</p> Source code in <code>client/ayon_houdini/plugins/inventory/select_containers.py</code> <pre><code>class SelectInScene(InventoryAction):\n    \"\"\"Select nodes in the scene from selected containers in scene inventory\"\"\"\n\n    label = \"Select in scene\"\n    icon = \"search\"\n    color = \"#888888\"\n    order = 99\n\n    @staticmethod\n    def is_compatible(container) -&gt; bool:\n        object_name: str = container.get(\"objectName\")\n        if not object_name:\n            return False\n\n        node = hou.node(object_name)\n        if not node:\n            return False\n\n        return True\n\n    def process(self, containers):\n        nodes = [hou.node(container[\"objectName\"]) for container in containers]\n        if not nodes:\n            return\n\n        hou.clearAllSelected()\n        for node in nodes:\n            node.setSelected(True)\n\n        # Set last as current\n        nodes[-1].setCurrent(True)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/inventory/set_camera_resolution.html","title":"set_camera_resolution","text":""},{"location":"autoapi/client/ayon_houdini/plugins/inventory/show_parameters.html","title":"show_parameters","text":""},{"location":"autoapi/client/ayon_houdini/plugins/inventory/show_parameters.html#client.ayon_houdini.plugins.inventory.show_parameters.ShowParametersAction","title":"<code>ShowParametersAction</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Show node parameters in a pop-up parameter window.</p> Source code in <code>client/ayon_houdini/plugins/inventory/show_parameters.py</code> <pre><code>class ShowParametersAction(InventoryAction):\n    \"\"\"Show node parameters in a pop-up parameter window.\"\"\"\n    label = \"Show parameters\"\n    icon = \"pencil-square-o\"\n    color = \"#888888\"\n    order = 100\n\n    @staticmethod\n    def is_compatible(container) -&gt; bool:\n        object_name: str = container.get(\"objectName\")\n        if not object_name:\n            return False\n\n        node = hou.node(object_name)\n        if not node:\n            return False\n\n        return True\n\n    def process(self, containers):\n        for container in containers:\n            node = hou.node(container[\"objectName\"])\n            show_node_parmeditor(node)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/actions.html","title":"actions","text":"<p>A module containing generic loader actions that will display in the Loader.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/load/actions.html#client.ayon_houdini.plugins.load.actions.SetFrameRangeLoader","title":"<code>SetFrameRangeLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Set frame range excluding pre- and post-handles</p> Source code in <code>client/ayon_houdini/plugins/load/actions.py</code> <pre><code>class SetFrameRangeLoader(plugin.HoudiniLoader):\n    \"\"\"Set frame range excluding pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"pointcache\",\n        \"vdbcache\",\n        \"usd\",\n    }\n    representations = {\"abc\", \"vdb\", \"usd\"}\n\n    label = \"Set frame range\"\n    order = 11\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name, namespace, data):\n\n        import hou\n\n        version_attributes = context[\"version\"][\"attrib\"]\n\n        start = version_attributes.get(\"frameStart\")\n        end = version_attributes.get(\"frameEnd\")\n\n        if start is None or end is None:\n            print(\n                \"Skipping setting frame range because start or \"\n                \"end frame data is missing..\"\n            )\n            return\n\n        hou.playbar.setFrameRange(start, end)\n        hou.playbar.setPlaybackRange(start, end)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/actions.html#client.ayon_houdini.plugins.load.actions.SetFrameRangeWithHandlesLoader","title":"<code>SetFrameRangeWithHandlesLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Set frame range including pre- and post-handles</p> Source code in <code>client/ayon_houdini/plugins/load/actions.py</code> <pre><code>class SetFrameRangeWithHandlesLoader(plugin.HoudiniLoader):\n    \"\"\"Set frame range including pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"pointcache\",\n        \"vdbcache\",\n        \"usd\",\n    }\n    representations = {\"abc\", \"vdb\", \"usd\"}\n\n    label = \"Set frame range (with handles)\"\n    order = 12\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name, namespace, data):\n\n        import hou\n\n        version_attributes = context[\"version\"][\"attrib\"]\n\n        start = version_attributes.get(\"frameStart\")\n        end = version_attributes.get(\"frameEnd\")\n\n        if start is None or end is None:\n            print(\n                \"Skipping setting frame range because start or \"\n                \"end frame data is missing..\"\n            )\n            return\n\n        # Include handles\n        start -= version_attributes.get(\"handleStart\", 0)\n        end += version_attributes.get(\"handleEnd\", 0)\n\n        hou.playbar.setFrameRange(start, end)\n        hou.playbar.setPlaybackRange(start, end)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_alembic.html","title":"load_alembic","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_alembic.html#client.ayon_houdini.plugins.load.load_alembic.AbcLoader","title":"<code>AbcLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load Alembic</p> Source code in <code>client/ayon_houdini/plugins/load/load_alembic.py</code> <pre><code>class AbcLoader(plugin.HoudiniLoader):\n    \"\"\"Load Alembic\"\"\"\n\n    product_types = {\"model\", \"animation\", \"pointcache\", \"gpuCache\"}\n    label = \"Load Alembic\"\n    representations = {\"*\"}\n    extensions = {\"abc\"}\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Format file name, Houdini only wants forward slashes\n        file_path = self.filepath_from_context(context)\n        file_path = os.path.normpath(file_path)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # Get the root node\n        obj = hou.node(\"/obj\")\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create a new geo node\n        container = obj.createNode(\"geo\", node_name=node_name)\n\n        # Remove the file node, it only loads static meshes\n        # Houdini 17 has removed the file node from the geo node\n        file_node = container.node(\"file1\")\n        if file_node:\n            file_node.destroy()\n\n        # Create an alembic node (supports animation)\n        alembic = container.createNode(\"alembic\", node_name=node_name)\n        alembic.setParms({\"fileName\": file_path})\n\n        # Position nodes nicely\n        container.moveToGoodPosition()\n        container.layoutChildren()\n\n        nodes = [container, alembic]\n\n        return pipeline.containerise(\n            node_name,\n            namespace,\n            nodes,\n            context,\n            self.__class__.__name__,\n            suffix=\"\",\n        )\n\n    def update(self, container, context):\n        node = container[\"node\"]\n        try:\n            alembic_node = next(\n                n for n in node.children() if n.type().name() == \"alembic\"\n            )\n        except StopIteration:\n            self.log.error(\"Could not find node of type `alembic`\")\n            return\n\n        # Update the file path\n        file_path = self.filepath_from_context(context)\n\n        alembic_node.setParms({\"fileName\": file_path})\n\n        # Update attribute\n        node.setParms({\"representation\": context[\"representation\"][\"id\"]})\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_alembic_archive.html","title":"load_alembic_archive","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_alembic_archive.html#client.ayon_houdini.plugins.load.load_alembic_archive.AbcArchiveLoader","title":"<code>AbcArchiveLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load Alembic as full geometry network hierarchy</p> Source code in <code>client/ayon_houdini/plugins/load/load_alembic_archive.py</code> <pre><code>class AbcArchiveLoader(plugin.HoudiniLoader):\n    \"\"\"Load Alembic as full geometry network hierarchy \"\"\"\n\n    product_types = {\"model\", \"animation\", \"pointcache\", \"gpuCache\"}\n    label = \"Load Alembic as Archive\"\n    representations = {\"*\"}\n    extensions = {\"abc\"}\n    order = -5\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Format file name, Houdini only wants forward slashes\n        file_path = self.filepath_from_context(context)\n        file_path = os.path.normpath(file_path)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # Get the root node\n        obj = hou.node(\"/obj\")\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create an Alembic archive node\n        node = obj.createNode(\"alembicarchive\", node_name=node_name)\n        node.moveToGoodPosition()\n\n        # TODO: add FPS of project / folder\n        node.setParms({\"fileName\": file_path,\n                       \"channelRef\": True})\n\n        # Apply some magic\n        node.parm(\"buildHierarchy\").pressButton()\n        node.moveToGoodPosition()\n\n        nodes = [node]\n\n        self[:] = nodes\n\n        return pipeline.containerise(node_name,\n                                     namespace,\n                                     nodes,\n                                     context,\n                                     self.__class__.__name__,\n                                     suffix=\"\")\n\n    def update(self, container, context):\n        node = container[\"node\"]\n\n        # Update the file path\n        file_path = self.filepath_from_context(context)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # Update attributes\n        node.setParms({\"fileName\": file_path,\n                       \"representation\": context[\"representation\"][\"id\"]})\n\n        # Rebuild\n        node.parm(\"buildHierarchy\").pressButton()\n\n    def remove(self, container):\n\n        node = container[\"node\"]\n        node.destroy()\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_ass.html","title":"load_ass","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_ass.html#client.ayon_houdini.plugins.load.load_ass.AssLoader","title":"<code>AssLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load .ass with Arnold Procedural</p> Source code in <code>client/ayon_houdini/plugins/load/load_ass.py</code> <pre><code>class AssLoader(plugin.HoudiniLoader):\n    \"\"\"Load .ass with Arnold Procedural\"\"\"\n\n    product_types = {\"ass\"}\n    label = \"Load Arnold Procedural\"\n    representations = {\"ass\"}\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Get the root node\n        obj = hou.node(\"/obj\")\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create a new geo node\n        procedural = obj.createNode(\"arnold::procedural\", node_name=node_name)\n\n        procedural.setParms(\n            {\n                \"ar_filename\": self.format_path(context)\n            })\n\n        nodes = [procedural]\n        self[:] = nodes\n\n        return pipeline.containerise(\n            node_name,\n            namespace,\n            nodes,\n            context,\n            self.__class__.__name__,\n            suffix=\"\",\n        )\n\n    def update(self, container, context):\n        # Update the file path\n        procedural = container[\"node\"]\n        procedural.setParms({\n            \"ar_filename\": self.format_path(context),\n            \"representation\": context[\"representation\"][\"id\"]\n        })\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def format_path(self, context):\n        \"\"\"Format file path correctly for single ass.* or ass.* sequence.\n\n        Args:\n            context (dict): representation context to be loaded.\n\n        Returns:\n             str: Formatted path to be used by the input node.\n\n        \"\"\"\n        path = self.filepath_from_context(context)\n        # The path is either a single file or sequence in a folder.\n        is_sequence = bool(context[\"representation\"][\"context\"].get(\"frame\"))\n        if is_sequence:\n            folder, filename = os.path.split(path)\n            filename = re.sub(r\"(.*)\\.(\\d+)\\.(ass.*)\", \"\\\\1.$F4.\\\\3\", filename)\n            path = os.path.join(folder, filename)\n\n        path = os.path.normpath(path)\n        path = path.replace(\"\\\\\", \"/\")\n        return path\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_ass.html#client.ayon_houdini.plugins.load.load_ass.AssLoader.format_path","title":"<code>format_path(context)</code>","text":"<p>Format file path correctly for single ass. or ass. sequence.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>representation context to be loaded.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Formatted path to be used by the input node.</p> Source code in <code>client/ayon_houdini/plugins/load/load_ass.py</code> <pre><code>def format_path(self, context):\n    \"\"\"Format file path correctly for single ass.* or ass.* sequence.\n\n    Args:\n        context (dict): representation context to be loaded.\n\n    Returns:\n         str: Formatted path to be used by the input node.\n\n    \"\"\"\n    path = self.filepath_from_context(context)\n    # The path is either a single file or sequence in a folder.\n    is_sequence = bool(context[\"representation\"][\"context\"].get(\"frame\"))\n    if is_sequence:\n        folder, filename = os.path.split(path)\n        filename = re.sub(r\"(.*)\\.(\\d+)\\.(ass.*)\", \"\\\\1.$F4.\\\\3\", filename)\n        path = os.path.join(folder, filename)\n\n    path = os.path.normpath(path)\n    path = path.replace(\"\\\\\", \"/\")\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_asset_lop.html","title":"load_asset_lop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_asset_lop.html#client.ayon_houdini.plugins.load.load_asset_lop.LOPLoadAssetLoader","title":"<code>LOPLoadAssetLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load reference/payload into Solaris using AYON <code>lop_import</code> LOP</p> Source code in <code>client/ayon_houdini/plugins/load/load_asset_lop.py</code> <pre><code>class LOPLoadAssetLoader(load.LoaderPlugin):\n    \"\"\"Load reference/payload into Solaris using AYON `lop_import` LOP\"\"\"\n\n    product_types = {\"*\"}\n    label = \"Load Asset (LOPs)\"\n    representations = [\"usd\", \"abc\", \"usda\", \"usdc\"]\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create node\n        network = find_active_network(\n            category=hou.lopNodeTypeCategory(),\n            default=\"/stage\"\n        )\n        node = network.createNode(\"ayon::lop_import\", node_name=node_name)\n        node.moveToGoodPosition()\n\n        hda_utils.set_node_representation_from_context(node, context)\n\n        nodes = [node]\n        self[:] = nodes\n\n    def update(self, container, context):\n        node = container[\"node\"]\n        hda_utils.set_node_representation_from_context(node, context)\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_bgeo.html","title":"load_bgeo","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_bgeo.html#client.ayon_houdini.plugins.load.load_bgeo.BgeoLoader","title":"<code>BgeoLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load bgeo files to Houdini.</p> Source code in <code>client/ayon_houdini/plugins/load/load_bgeo.py</code> <pre><code>class BgeoLoader(plugin.HoudiniLoader):\n    \"\"\"Load bgeo files to Houdini.\"\"\"\n\n    label = \"Load bgeo\"\n    product_types = {\"model\", \"pointcache\", \"bgeo\"}\n    representations = {\n        \"bgeo\", \"bgeosc\", \"bgeogz\",\n        \"bgeo.sc\", \"bgeo.gz\", \"bgeo.lzma\", \"bgeo.bz2\"}\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Get the root node\n        obj = hou.node(\"/obj\")\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create a new geo node\n        container = obj.createNode(\"geo\", node_name=node_name)\n\n        # Remove the file node, it only loads static meshes\n        # Houdini 17 has removed the file node from the geo node\n        file_node = container.node(\"file1\")\n        if file_node:\n            file_node.destroy()\n\n        # Explicitly create a file node\n        path = self.filepath_from_context(context)\n        file_node = container.createNode(\"file\", node_name=node_name)\n        file_node.setParms(\n            {\"file\": self.format_path(path, context[\"representation\"])})\n\n        # Set display on last node\n        file_node.setDisplayFlag(True)\n\n        nodes = [container, file_node]\n        self[:] = nodes\n\n        return pipeline.containerise(\n            node_name,\n            namespace,\n            nodes,\n            context,\n            self.__class__.__name__,\n            suffix=\"\",\n        )\n\n    @staticmethod\n    def format_path(path, representation):\n        \"\"\"Format file path correctly for single bgeo or bgeo sequence.\"\"\"\n        # The path is either a single file or sequence in a folder.\n        is_sequence = bool(representation[\"context\"].get(\"frame\"))\n        if is_sequence:\n            folder, filename = os.path.split(path)\n            filename = re.sub(\n                r\"(.*)\\.(\\d+)\\.(bgeo.*)\", \"\\\\1.$F4.\\\\3\", filename\n            )\n            path = os.path.join(folder, filename)\n\n        path = os.path.normpath(path)\n        path = path.replace(\"\\\\\", \"/\")\n        return path\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        node = container[\"node\"]\n        try:\n            file_node = next(\n                n for n in node.children() if n.type().name() == \"file\"\n            )\n        except StopIteration:\n            self.log.error(\"Could not find node of type `alembic`\")\n            return\n\n        # Update the file path\n        file_path = self.filepath_from_context(context)\n        file_path = self.format_path(file_path, repre_entity)\n\n        file_node.setParms({\"file\": file_path})\n\n        # Update attribute\n        node.setParms({\"representation\": repre_entity[\"id\"]})\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_bgeo.html#client.ayon_houdini.plugins.load.load_bgeo.BgeoLoader.format_path","title":"<code>format_path(path, representation)</code>  <code>staticmethod</code>","text":"<p>Format file path correctly for single bgeo or bgeo sequence.</p> Source code in <code>client/ayon_houdini/plugins/load/load_bgeo.py</code> <pre><code>@staticmethod\ndef format_path(path, representation):\n    \"\"\"Format file path correctly for single bgeo or bgeo sequence.\"\"\"\n    # The path is either a single file or sequence in a folder.\n    is_sequence = bool(representation[\"context\"].get(\"frame\"))\n    if is_sequence:\n        folder, filename = os.path.split(path)\n        filename = re.sub(\n            r\"(.*)\\.(\\d+)\\.(bgeo.*)\", \"\\\\1.$F4.\\\\3\", filename\n        )\n        path = os.path.join(folder, filename)\n\n    path = os.path.normpath(path)\n    path = path.replace(\"\\\\\", \"/\")\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_camera.html","title":"load_camera","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_camera.html#client.ayon_houdini.plugins.load.load_camera.CameraLoader","title":"<code>CameraLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load camera from an Alembic file</p> Source code in <code>client/ayon_houdini/plugins/load/load_camera.py</code> <pre><code>class CameraLoader(plugin.HoudiniLoader):\n    \"\"\"Load camera from an Alembic file\"\"\"\n\n    product_types = {\"camera\"}\n    label = \"Load Camera (abc)\"\n    representations = {\"abc\"}\n    order = -10\n\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    camera_aperture_expression = \"default\"\n\n    _match_maya_render_mask_expression = \"\"\"\n# Match maya render mask (logic from Houdini's own FBX importer)\nnode = hou.pwd()\nresx = node.evalParm('resx')\nresy = node.evalParm('resy')\naspect = node.evalParm('aspect')\naperture *= min(1, (resx / resy * aspect) / 1.5)\nreturn aperture\n\"\"\"\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            EnumDef(\n                \"cameraApertureExpression\",\n                label=\"Camera Aperture Expression\",\n                items=[\n                    {\"label\": \"Houdini Default\", \"value\": \"default\"},\n                    {\"label\": \"Match Maya render mask\", \"value\": \"match_maya\"}\n                ],\n                default=cls.camera_aperture_expression,\n                tooltip=(\n                    \"Set the aperture expression on the camera from the \"\n                    \"Alembic using either:\\n\"\n                    \"- Houdini default expression\\n\"\n                    \"- Match the Maya render mask (which matches Houdini's \"\n                    \"FBX Import camera expression.\"\n                )\n            )\n        ]\n\n    def load(self, context, name=None, namespace=None, options=None):\n        # Format file name, Houdini only wants forward slashes\n        file_path = self.filepath_from_context(context).replace(\"\\\\\", \"/\")\n\n        # Get the root node\n        obj = hou.node(\"/obj\")\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create a archive node\n        node = self.create_and_connect(obj, \"alembicarchive\", node_name)\n\n        # TODO: add FPS of project / folder\n        node.setParms({\"fileName\": file_path, \"channelRef\": True})\n\n        # Apply some magic\n        node.parm(\"buildHierarchy\").pressButton()\n        node.moveToGoodPosition()\n\n        # Create an alembic xform node\n        nodes = [node]\n\n        camera = get_camera_from_container(node)\n\n        if options.get(\"cameraApertureExpression\",\n                       self.camera_aperture_expression) == \"match_maya\":\n            self._match_maya_render_mask(camera)\n\n        set_camera_resolution(camera, entity=context[\"folder\"])\n        self[:] = nodes\n\n        return pipeline.containerise(node_name,\n                                     namespace,\n                                     nodes,\n                                     context,\n                                     self.__class__.__name__,\n                                     suffix=\"\")\n\n    def update(self, container, context):\n        node = container[\"node\"]\n\n        # Update the file path\n        file_path = self.filepath_from_context(context)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # Update attributes\n        node.setParms({\"fileName\": file_path,\n                       \"representation\": context[\"representation\"][\"id\"]})\n\n        # Store the cam temporarily next to the Alembic Archive\n        # so that we can preserve parm values the user set on it\n        # after build hierarchy was triggered.\n        old_camera = get_camera_from_container(node)\n        temp_camera = old_camera.copyTo(node.parent())\n\n        # Rebuild\n        node.parm(\"buildHierarchy\").pressButton()\n\n        # Apply values to the new camera\n        new_camera = get_camera_from_container(node)\n        transfer_non_default_values(temp_camera,\n                                    new_camera,\n                                    # The hidden uniform scale attribute\n                                    # gets a default connection to\n                                    # \"icon_scale\" just skip that completely\n                                    ignore={\"scale\"})\n\n        # Detect whether the camera was loaded with the \"Match Maya render\n        # mask\" before. If so, we want to maintain that expression on update.\n        if (\n                self._match_maya_render_mask_expression\n                in get_expression(temp_camera.parm(\"aperture\"))\n        ):\n            self._match_maya_render_mask(new_camera)\n\n        set_camera_resolution(new_camera)\n\n        temp_camera.destroy()\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def create_and_connect(self, node, node_type, name=None):\n        \"\"\"Create a node within a node which and connect it to the input\n\n        Args:\n            node(hou.Node): parent of the new node\n            node_type(str) name of the type of node, eg: 'alembic'\n            name(str, Optional): name of the node\n\n        Returns:\n            hou.Node\n\n        \"\"\"\n        if name:\n            new_node = node.createNode(node_type, node_name=name)\n        else:\n            new_node = node.createNode(node_type)\n\n        new_node.moveToGoodPosition()\n        return new_node\n\n    def _match_maya_render_mask(self, camera):\n        \"\"\"Workaround to match Maya render mask in Houdini\"\"\"\n        parm = camera.parm(\"aperture\")\n        print(f\"Applying match Maya render mask expression to: {parm.path()}\")\n\n        expression = parm.expression()\n        expression = expression.replace(\"return \", \"aperture = \")\n        expression += self._match_maya_render_mask_expression\n        parm.setExpression(expression, language=hou.exprLanguage.Python)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_camera.html#client.ayon_houdini.plugins.load.load_camera.CameraLoader.create_and_connect","title":"<code>create_and_connect(node, node_type, name=None)</code>","text":"<p>Create a node within a node which and connect it to the input</p> <p>Parameters:</p> Name Type Description Default <code>node(hou.Node)</code> <p>parent of the new node</p> required <code>node_type(str)</code> <code>name of the type of node, eg</code> <p>'alembic'</p> required <code>name(str,</code> <code>Optional</code> <p>name of the node</p> required <p>Returns:</p> Type Description <p>hou.Node</p> Source code in <code>client/ayon_houdini/plugins/load/load_camera.py</code> <pre><code>def create_and_connect(self, node, node_type, name=None):\n    \"\"\"Create a node within a node which and connect it to the input\n\n    Args:\n        node(hou.Node): parent of the new node\n        node_type(str) name of the type of node, eg: 'alembic'\n        name(str, Optional): name of the node\n\n    Returns:\n        hou.Node\n\n    \"\"\"\n    if name:\n        new_node = node.createNode(node_type, node_name=name)\n    else:\n        new_node = node.createNode(node_type)\n\n    new_node.moveToGoodPosition()\n    return new_node\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_camera.html#client.ayon_houdini.plugins.load.load_camera.transfer_non_default_values","title":"<code>transfer_non_default_values(src, dest, ignore=None)</code>","text":"<p>Copy parm from src to dest.</p> <p>Because the Alembic Archive rebuilds the entire node hierarchy on triggering \"Build Hierarchy\" we want to preserve any local tweaks made by the user on the camera for ease of use. That could be a background image, a resolution change or even Redshift camera parameters.</p> <p>We try to do so by finding all Parms that exist on both source and destination node, include only those that both are not at their default value, they must be visible, we exclude those that have the special \"alembic archive\" channel expression and ignore certain Parm types.</p> Source code in <code>client/ayon_houdini/plugins/load/load_camera.py</code> <pre><code>def transfer_non_default_values(src, dest, ignore=None):\n    \"\"\"Copy parm from src to dest.\n\n    Because the Alembic Archive rebuilds the entire node\n    hierarchy on triggering \"Build Hierarchy\" we want to\n    preserve any local tweaks made by the user on the camera\n    for ease of use. That could be a background image, a\n    resolution change or even Redshift camera parameters.\n\n    We try to do so by finding all Parms that exist on both\n    source and destination node, include only those that both\n    are not at their default value, they must be visible,\n    we exclude those that have the special \"alembic archive\"\n    channel expression and ignore certain Parm types.\n\n    \"\"\"\n\n    ignore_types = {\n        hou.parmTemplateType.Toggle,\n        hou.parmTemplateType.Menu,\n        hou.parmTemplateType.Button,\n        hou.parmTemplateType.FolderSet,\n        hou.parmTemplateType.Separator,\n        hou.parmTemplateType.Label,\n    }\n\n    src.updateParmStates()\n\n    for parm in src.allParms():\n\n        if ignore and parm.name() in ignore:\n            continue\n\n        # If destination parm does not exist, ignore..\n        dest_parm = dest.parm(parm.name())\n        if not dest_parm:\n            continue\n\n        # Ignore values that are currently at default\n        if parm.isAtDefault() and dest_parm.isAtDefault():\n            continue\n\n        if not parm.isVisible():\n            # Ignore hidden parameters, assume they\n            # are implementation details\n            continue\n\n        expression = get_expression(parm)\n        if expression is not None and ARCHIVE_EXPRESSION in expression:\n            # Assume it's part of the automated connections that the\n            # Alembic Archive makes on loading of the camera and thus we do\n            # not want to transfer the expression\n            continue\n\n        # Ignore folders, separators, etc.\n        if parm.parmTemplate().type() in ignore_types:\n            continue\n\n        print(\"Preserving attribute: %s\" % parm.name())\n        dest_parm.setFromParm(parm)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_fbx.html","title":"load_fbx","text":"<p>Fbx Loader for houdini.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_fbx.html#client.ayon_houdini.plugins.load.load_fbx.FbxLoader","title":"<code>FbxLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load fbx files.</p> Source code in <code>client/ayon_houdini/plugins/load/load_fbx.py</code> <pre><code>class FbxLoader(plugin.HoudiniLoader):\n    \"\"\"Load fbx files. \"\"\"\n\n    label = \"Load FBX\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    order = -10\n\n    product_types = {\"*\"}\n    representations = {\"*\"}\n    extensions = {\"fbx\"}\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # get file path from context\n        file_path = self.filepath_from_context(context)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # get necessary data\n        namespace, node_name = self.get_node_name(context, name, namespace)\n\n        # create load tree\n        nodes = self.create_load_node_tree(file_path, node_name, name)\n\n        self[:] = nodes\n\n        # Call containerise function which does some automations for you\n        #  like moving created nodes to the AVALON_CONTAINERS subnetwork\n        containerised_nodes = pipeline.containerise(\n            node_name,\n            namespace,\n            nodes,\n            context,\n            self.__class__.__name__,\n            suffix=\"\",\n        )\n\n        return containerised_nodes\n\n    def update(self, container, context):\n        node = container[\"node\"]\n        try:\n            file_node = next(\n                n for n in node.children() if n.type().name() == \"file\"\n            )\n        except StopIteration:\n            self.log.error(\"Could not find node of type `file`\")\n            return\n\n        # Update the file path from representation\n        file_path = self.filepath_from_context(context)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        file_node.setParms({\"file\": file_path})\n\n        # Update attribute\n        node.setParms({\"representation\": context[\"representation\"][\"id\"]})\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def get_node_name(self, context, name=None, namespace=None):\n        \"\"\"Define node name.\"\"\"\n\n        if not namespace:\n            namespace = context[\"folder\"][\"name\"]\n\n        if namespace:\n            node_name = \"{}_{}\".format(namespace, name)\n        else:\n            node_name = name\n\n        return namespace, node_name\n\n    def create_load_node_tree(self, file_path, node_name, product_name):\n        \"\"\"Create Load network.\n\n        you can start building your tree at any obj level.\n        it'll be much easier to build it in the root obj level.\n\n        Afterwards, your tree will be automatically moved to\n        '/obj/AVALON_CONTAINERS' subnetwork.\n        \"\"\"\n        # Get the root obj level\n        obj = hou.node(\"/obj\")\n\n        # Create a new obj geo node\n        parent_node = obj.createNode(\"geo\", node_name=node_name)\n\n        # In older houdini,\n        # when reating a new obj geo node, a default file node will be\n        # automatically created.\n        # so, we will delete it if exists.\n        file_node = parent_node.node(\"file1\")\n        if file_node:\n            file_node.destroy()\n\n        # Create a new file node\n        file_node = parent_node.createNode(\"file\", node_name=node_name)\n        file_node.setParms({\"file\": file_path})\n\n        # Create attribute delete\n        attribdelete_name = \"attribdelete_{}\".format(product_name)\n        attribdelete = parent_node.createNode(\"attribdelete\",\n                                              node_name=attribdelete_name)\n        attribdelete.setParms({\"ptdel\": \"fbx_*\"})\n        attribdelete.setInput(0, file_node)\n\n        # Create a Null node\n        null_name = \"OUT_{}\".format(product_name)\n        null = parent_node.createNode(\"null\", node_name=null_name)\n        null.setInput(0, attribdelete)\n\n        # Ensure display flag is on the file_node input node and not on the OUT\n        # node to optimize \"debug\" displaying in the viewport.\n        file_node.setDisplayFlag(True)\n\n        # Set new position for children nodes\n        parent_node.layoutChildren()\n\n        # Return all the nodes\n        return [parent_node, file_node, attribdelete, null]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_fbx.html#client.ayon_houdini.plugins.load.load_fbx.FbxLoader.create_load_node_tree","title":"<code>create_load_node_tree(file_path, node_name, product_name)</code>","text":"<p>Create Load network.</p> <p>you can start building your tree at any obj level. it'll be much easier to build it in the root obj level.</p> <p>Afterwards, your tree will be automatically moved to '/obj/AVALON_CONTAINERS' subnetwork.</p> Source code in <code>client/ayon_houdini/plugins/load/load_fbx.py</code> <pre><code>def create_load_node_tree(self, file_path, node_name, product_name):\n    \"\"\"Create Load network.\n\n    you can start building your tree at any obj level.\n    it'll be much easier to build it in the root obj level.\n\n    Afterwards, your tree will be automatically moved to\n    '/obj/AVALON_CONTAINERS' subnetwork.\n    \"\"\"\n    # Get the root obj level\n    obj = hou.node(\"/obj\")\n\n    # Create a new obj geo node\n    parent_node = obj.createNode(\"geo\", node_name=node_name)\n\n    # In older houdini,\n    # when reating a new obj geo node, a default file node will be\n    # automatically created.\n    # so, we will delete it if exists.\n    file_node = parent_node.node(\"file1\")\n    if file_node:\n        file_node.destroy()\n\n    # Create a new file node\n    file_node = parent_node.createNode(\"file\", node_name=node_name)\n    file_node.setParms({\"file\": file_path})\n\n    # Create attribute delete\n    attribdelete_name = \"attribdelete_{}\".format(product_name)\n    attribdelete = parent_node.createNode(\"attribdelete\",\n                                          node_name=attribdelete_name)\n    attribdelete.setParms({\"ptdel\": \"fbx_*\"})\n    attribdelete.setInput(0, file_node)\n\n    # Create a Null node\n    null_name = \"OUT_{}\".format(product_name)\n    null = parent_node.createNode(\"null\", node_name=null_name)\n    null.setInput(0, attribdelete)\n\n    # Ensure display flag is on the file_node input node and not on the OUT\n    # node to optimize \"debug\" displaying in the viewport.\n    file_node.setDisplayFlag(True)\n\n    # Set new position for children nodes\n    parent_node.layoutChildren()\n\n    # Return all the nodes\n    return [parent_node, file_node, attribdelete, null]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_fbx.html#client.ayon_houdini.plugins.load.load_fbx.FbxLoader.get_node_name","title":"<code>get_node_name(context, name=None, namespace=None)</code>","text":"<p>Define node name.</p> Source code in <code>client/ayon_houdini/plugins/load/load_fbx.py</code> <pre><code>def get_node_name(self, context, name=None, namespace=None):\n    \"\"\"Define node name.\"\"\"\n\n    if not namespace:\n        namespace = context[\"folder\"][\"name\"]\n\n    if namespace:\n        node_name = \"{}_{}\".format(namespace, name)\n    else:\n        node_name = name\n\n    return namespace, node_name\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_filepath.html","title":"load_filepath","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_filepath.html#client.ayon_houdini.plugins.load.load_filepath.FilePathLoader","title":"<code>FilePathLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load a managed filepath to a null node.</p> <p>This is useful if for a particular workflow there is no existing loader yet. A Houdini artists can load as the generic filepath loader and then reference the relevant Houdini parm to use the exact value. The benefit is that this filepath will be managed and can be updated as usual.</p> Source code in <code>client/ayon_houdini/plugins/load/load_filepath.py</code> <pre><code>class FilePathLoader(plugin.HoudiniLoader):\n    \"\"\"Load a managed filepath to a null node.\n\n    This is useful if for a particular workflow there is no existing loader\n    yet. A Houdini artists can load as the generic filepath loader and then\n    reference the relevant Houdini parm to use the exact value. The benefit\n    is that this filepath will be managed and can be updated as usual.\n\n    \"\"\"\n\n    label = \"Load filepath to node\"\n    order = 9\n    icon = \"link\"\n    color = \"white\"\n    product_types = {\"*\"}\n    representations = {\"*\"}\n\n    def load(self, context, name=None, namespace=None, data=None):\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create node\n        parent_node = get_or_create_avalon_container()\n        node = parent_node.createNode(\"ayon::generic_loader\",\n                                      node_name=node_name)\n        node.moveToGoodPosition()\n\n        hda_utils.set_node_representation_from_context(node, context)\n\n    def update(self, container, context):\n        # First we handle backwards compatibility where this loader still\n        # loaded using a `null` node instead of the `ayon::generic_loader`\n        node = container[\"node\"]\n        if node.type().name() == \"null\":\n            # Update the legacy way\n            self.update_legacy(node, context)\n            return\n\n        hda_utils.set_node_representation_from_context(node, context)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def update_legacy(self, node, context):\n        # Update the file path\n        representation_entity = context[\"representation\"]\n        filepath = hda_utils.get_filepath_from_context(context)\n\n        node.setParms({\n            \"filepath\": filepath,\n            \"representation\": str(representation_entity[\"id\"])\n        })\n\n        # Update the parameter default value (cosmetics)\n        parm_template_group = node.parmTemplateGroup()\n        parm = parm_template_group.find(\"filepath\")\n        parm.setDefaultValue((filepath,))\n        parm_template_group.replace(parm_template_group.find(\"filepath\"),\n                                    parm)\n        node.setParmTemplateGroup(parm_template_group)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_hda.html","title":"load_hda","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_hda.html#client.ayon_houdini.plugins.load.load_hda.HdaLoader","title":"<code>HdaLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load Houdini Digital Asset file.</p> Source code in <code>client/ayon_houdini/plugins/load/load_hda.py</code> <pre><code>class HdaLoader(plugin.HoudiniLoader):\n    \"\"\"Load Houdini Digital Asset file.\"\"\"\n\n    product_types = {\"hda\"}\n    label = \"Load Hda\"\n    representations = {\"hda\"}\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n\n        # Format file name, Houdini only wants forward slashes\n        file_path = self.filepath_from_context(context)\n        file_path = os.path.normpath(file_path)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        namespace = namespace or context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        hou.hda.installFile(file_path)\n\n        hda_defs = hou.hda.definitionsInFile(file_path)\n        if not hda_defs:\n            raise LoadError(f\"No HDA definitions found in file: {file_path}\")\n\n        parent_node = self._create_dedicated_parent_node(hda_defs[-1])\n\n        # Get the type name from the HDA definition.\n        type_name = hda_defs[-1].nodeTypeName()\n        hda_node = parent_node.createNode(type_name, node_name)\n        hda_node.moveToGoodPosition()\n\n        # Imprint it manually\n        data = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": node_name,\n            \"namespace\": namespace,\n            \"loader\": self.__class__.__name__,\n            \"representation\": context[\"representation\"][\"id\"],\n        }\n\n        lib.imprint(hda_node, data)\n\n        return hda_node\n\n    def update(self, container, context):\n\n        repre_entity = context[\"representation\"]\n        hda_node = container[\"node\"]\n        file_path = get_representation_path(repre_entity)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n        hou.hda.installFile(file_path)\n        defs = hda_node.type().allInstalledDefinitions()\n        def_paths = [d.libraryFilePath() for d in defs]\n        new = def_paths.index(file_path)\n        defs[new].setIsPreferred(True)\n        hda_node.setParms({\n            \"representation\": repre_entity[\"id\"]\n        })\n\n        # Move the Extra parameter folder to the back.\n        parm_group = hda_node.parmTemplateGroup()\n        # The name 'Extra' is a hard coded name in AYON.\n        parm_folder = parm_group.findFolder(\"Extra\")\n        # Remove `Extra` AYON parameters\n        parm_group.remove(parm_folder.name())\n        # Add `Extra` AYON parameters back\n        parm_group.append(parm_folder)\n        hda_node.setParmTemplateGroup(parm_group)\n\n    def remove(self, container):\n        node = container[\"node\"]\n        parent = node.parent()\n        node.destroy()\n\n        if parent.path() == pipeline.AVALON_CONTAINERS:\n            return\n\n        # Remove parent if empty.\n        if not parent.children():\n            parent.destroy()\n\n    def _create_dedicated_parent_node(self, hda_def):\n\n        # Get the root node\n        parent_node = pipeline.get_or_create_avalon_container()\n        node = None\n        node_type = None\n        if hda_def.nodeTypeCategory() == hou.objNodeTypeCategory():\n            return parent_node\n        elif hda_def.nodeTypeCategory() == hou.chopNodeTypeCategory():\n            node_type, node_name = \"chopnet\", \"MOTION\"\n        elif hda_def.nodeTypeCategory() == hou.cop2NodeTypeCategory():\n            node_type, node_name = \"cop2net\", \"IMAGES\"\n        elif hda_def.nodeTypeCategory() == hou.dopNodeTypeCategory():\n            node_type, node_name = \"dopnet\", \"DOPS\"\n        elif hda_def.nodeTypeCategory() == hou.ropNodeTypeCategory():\n            node_type, node_name = \"ropnet\", \"ROPS\"\n        elif hda_def.nodeTypeCategory() == hou.lopNodeTypeCategory():\n            node_type, node_name = \"lopnet\", \"LOPS\"\n        elif hda_def.nodeTypeCategory() == hou.sopNodeTypeCategory():\n            node_type, node_name = \"geo\", \"SOPS\"\n        elif hda_def.nodeTypeCategory() == hou.topNodeTypeCategory():\n            node_type, node_name = \"topnet\", \"TOPS\"\n        # TODO: Create a dedicated parent node based on Vop Node vex context.\n        elif hda_def.nodeTypeCategory() == hou.vopNodeTypeCategory():\n            node_type, node_name = \"matnet\", \"MATSandVOPS\"\n\n        node = parent_node.node(node_name)\n        if not node:\n            node = parent_node.createNode(node_type, node_name)\n\n        node.moveToGoodPosition()\n        return node\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_image.html","title":"load_image","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_image.html#client.ayon_houdini.plugins.load.load_image.ImageLoader","title":"<code>ImageLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load images into COP2</p> Source code in <code>client/ayon_houdini/plugins/load/load_image.py</code> <pre><code>class ImageLoader(plugin.HoudiniLoader):\n    \"\"\"Load images into COP2\"\"\"\n\n    product_types = {\n        \"imagesequence\",\n        \"review\",\n        \"render\",\n        \"plate\",\n        \"image\",\n        \"online\",\n    }\n    label = \"Load Image (COP2)\"\n    representations = {\"*\"}\n    order = -10\n\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Format file name, Houdini only wants forward slashes\n        path = self.filepath_from_context(context)\n        path = self.format_path(path, representation=context[\"representation\"])\n\n        # Get the root node\n        parent = get_image_avalon_container()\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        node = parent.createNode(\"file\", node_name=node_name)\n        node.moveToGoodPosition()\n\n        parms = {\"filename1\": path}\n        parms.update(self.get_colorspace_parms(context[\"representation\"]))\n\n        node.setParms(parms)\n\n        # Imprint it manually\n        data = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": node_name,\n            \"namespace\": namespace,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n        }\n\n        # todo: add folder=\"Avalon\"\n        lib.imprint(node, data)\n\n        return node\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        node = container[\"node\"]\n\n        # Update the file path\n        file_path = self.filepath_from_context(context)\n        file_path = self.format_path(file_path, repre_entity)\n\n        parms = {\n            \"filename1\": file_path,\n            \"representation\": repre_entity[\"id\"],\n        }\n\n        parms.update(self.get_colorspace_parms(repre_entity))\n\n        # Update attributes\n        node.setParms(parms)\n\n    def remove(self, container):\n        node = container[\"node\"]\n\n        # Let's clean up the IMAGES COP2 network\n        # if it ends up being empty and we deleted\n        # the last file node. Store the parent\n        # before we delete the node.\n        parent = node.parent()\n\n        node.destroy()\n\n        if not parent.children():\n            parent.destroy()\n\n    @staticmethod\n    def format_path(path, representation):\n        \"\"\"Format file path correctly for single image or sequence.\"\"\"\n        ext = os.path.splitext(path)[-1]\n\n        # The path is either a single file or sequence in a folder.\n        is_sequence = bool(representation[\"context\"].get(\"frame\"))\n        if is_sequence:\n            folder, filename = os.path.split(path)\n            filename = re.sub(r\"(.*)\\.(\\d+){}$\".format(re.escape(ext)),\n                              \"\\\\1.$F4{}\".format(ext),\n                              filename)\n            path = os.path.join(folder, filename)\n\n        path = os.path.normpath(path)\n        path = path.replace(\"\\\\\", \"/\")\n        return path\n\n    def get_colorspace_parms(self, representation: dict) -&gt; dict:\n        \"\"\"Return the color space parameters.\n\n        Returns the values for the colorspace parameters on the node if there\n        is colorspace data on the representation.\n\n        Arguments:\n            representation (dict): The representation entity.\n\n        Returns:\n            dict: Parm to value mapping if colorspace data is defined.\n\n        \"\"\"\n        # Using OCIO colorspace on COP2 File node is only supported in Hou 20+\n        major, _, _ = hou.applicationVersion()\n        if major &lt; 20:\n            return {}\n\n        data = representation.get(\"data\", {}).get(\"colorspaceData\", {})\n        if not data:\n            return {}\n\n        colorspace = data[\"colorspace\"]\n        if colorspace:\n            return {\n                \"colorspace\": 3,  # Use OpenColorIO\n                \"ocio_space\": colorspace\n            }\n\n        return {}\n\n    def switch(self, container, representation):\n        self.update(container, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_image.html#client.ayon_houdini.plugins.load.load_image.ImageLoader.format_path","title":"<code>format_path(path, representation)</code>  <code>staticmethod</code>","text":"<p>Format file path correctly for single image or sequence.</p> Source code in <code>client/ayon_houdini/plugins/load/load_image.py</code> <pre><code>@staticmethod\ndef format_path(path, representation):\n    \"\"\"Format file path correctly for single image or sequence.\"\"\"\n    ext = os.path.splitext(path)[-1]\n\n    # The path is either a single file or sequence in a folder.\n    is_sequence = bool(representation[\"context\"].get(\"frame\"))\n    if is_sequence:\n        folder, filename = os.path.split(path)\n        filename = re.sub(r\"(.*)\\.(\\d+){}$\".format(re.escape(ext)),\n                          \"\\\\1.$F4{}\".format(ext),\n                          filename)\n        path = os.path.join(folder, filename)\n\n    path = os.path.normpath(path)\n    path = path.replace(\"\\\\\", \"/\")\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_image.html#client.ayon_houdini.plugins.load.load_image.ImageLoader.get_colorspace_parms","title":"<code>get_colorspace_parms(representation)</code>","text":"<p>Return the color space parameters.</p> <p>Returns the values for the colorspace parameters on the node if there is colorspace data on the representation.</p> <p>Parameters:</p> Name Type Description Default <code>representation</code> <code>dict</code> <p>The representation entity.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Parm to value mapping if colorspace data is defined.</p> Source code in <code>client/ayon_houdini/plugins/load/load_image.py</code> <pre><code>def get_colorspace_parms(self, representation: dict) -&gt; dict:\n    \"\"\"Return the color space parameters.\n\n    Returns the values for the colorspace parameters on the node if there\n    is colorspace data on the representation.\n\n    Arguments:\n        representation (dict): The representation entity.\n\n    Returns:\n        dict: Parm to value mapping if colorspace data is defined.\n\n    \"\"\"\n    # Using OCIO colorspace on COP2 File node is only supported in Hou 20+\n    major, _, _ = hou.applicationVersion()\n    if major &lt; 20:\n        return {}\n\n    data = representation.get(\"data\", {}).get(\"colorspaceData\", {})\n    if not data:\n        return {}\n\n    colorspace = data[\"colorspace\"]\n    if colorspace:\n        return {\n            \"colorspace\": 3,  # Use OpenColorIO\n            \"ocio_space\": colorspace\n        }\n\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_image.html#client.ayon_houdini.plugins.load.load_image.get_image_avalon_container","title":"<code>get_image_avalon_container()</code>","text":"<p>The COP2 files must be in a COP2 network.</p> <p>So we maintain a single entry point within AVALON_CONTAINERS, just for ease of use.</p> Source code in <code>client/ayon_houdini/plugins/load/load_image.py</code> <pre><code>def get_image_avalon_container():\n    \"\"\"The COP2 files must be in a COP2 network.\n\n    So we maintain a single entry point within AVALON_CONTAINERS,\n    just for ease of use.\n\n    \"\"\"\n\n    path = pipeline.AVALON_CONTAINERS\n    avalon_container = hou.node(path)\n    if not avalon_container:\n        # Let's create avalon container secretly\n        # but make sure the pipeline still is built the\n        # way we anticipate it was built, asserting it.\n        assert path == \"/obj/AVALON_CONTAINERS\"\n\n        parent = hou.node(\"/obj\")\n        avalon_container = parent.createNode(\n            \"subnet\", node_name=\"AVALON_CONTAINERS\"\n        )\n\n    image_container = hou.node(path + \"/IMAGES\")\n    if not image_container:\n        image_container = avalon_container.createNode(\n            \"cop2net\", node_name=\"IMAGES\"\n        )\n        image_container.moveToGoodPosition()\n\n    return image_container\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_redshift_proxy.html","title":"load_redshift_proxy","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_redshift_proxy.html#client.ayon_houdini.plugins.load.load_redshift_proxy.RedshiftProxyLoader","title":"<code>RedshiftProxyLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load Redshift Proxy</p> Source code in <code>client/ayon_houdini/plugins/load/load_redshift_proxy.py</code> <pre><code>class RedshiftProxyLoader(plugin.HoudiniLoader):\n    \"\"\"Load Redshift Proxy\"\"\"\n\n    product_types = {\"redshiftproxy\"}\n    label = \"Load Redshift Proxy\"\n    representations = {\"rs\"}\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Get the root node\n        obj = hou.node(\"/obj\")\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create a new geo node\n        container = obj.createNode(\"geo\", node_name=node_name)\n\n        # Check whether the Redshift parameters exist - if not, then likely\n        # redshift is not set up or initialized correctly\n        if not container.parm(\"RS_objprop_proxy_enable\"):\n            container.destroy()\n            raise LoadError(\"Unable to initialize geo node with Redshift \"\n                            \"attributes. Make sure you have the Redshift \"\n                            \"plug-in set up correctly for Houdini.\")\n\n        # Enable by default\n        container.setParms({\n            \"RS_objprop_proxy_enable\": True,\n            \"RS_objprop_proxy_file\": self.format_path(\n                self.filepath_from_context(context),\n                context[\"representation\"])\n        })\n\n        # Remove the file node, it only loads static meshes\n        # Houdini 17 has removed the file node from the geo node\n        file_node = container.node(\"file1\")\n        if file_node:\n            file_node.destroy()\n\n        # Add this stub node inside so it previews ok\n        proxy_sop = container.createNode(\"redshift_proxySOP\",\n                                         node_name=node_name)\n        proxy_sop.setDisplayFlag(True)\n\n        nodes = [container, proxy_sop]\n\n        self[:] = nodes\n\n        return pipeline.containerise(\n            node_name,\n            namespace,\n            nodes,\n            context,\n            self.__class__.__name__,\n            suffix=\"\",\n        )\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        # Update the file path\n        file_path = self.filepath_from_context(context)\n\n        node = container[\"node\"]\n        node.setParms({\n            \"RS_objprop_proxy_file\": self.format_path(\n                file_path, repre_entity)\n        })\n\n        # Update attribute\n        node.setParms({\"representation\": repre_entity[\"id\"]})\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    @staticmethod\n    def format_path(path, representation):\n        \"\"\"Format file path correctly for single redshift proxy\n        or redshift proxy sequence.\"\"\"\n        # The path is either a single file or sequence in a folder.\n        is_sequence = bool(representation[\"context\"].get(\"frame\"))\n        if is_sequence:\n            folder, filename = os.path.split(path)\n            filename = re.sub(r\"(.*)\\.(\\d+)\\.(rs.*)\", \"\\\\1.$F4.\\\\3\", filename)\n            path = os.path.join(folder, filename)\n\n        path = os.path.normpath(path)\n        path = path.replace(\"\\\\\", \"/\")\n        return path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_redshift_proxy.html#client.ayon_houdini.plugins.load.load_redshift_proxy.RedshiftProxyLoader.format_path","title":"<code>format_path(path, representation)</code>  <code>staticmethod</code>","text":"<p>Format file path correctly for single redshift proxy or redshift proxy sequence.</p> Source code in <code>client/ayon_houdini/plugins/load/load_redshift_proxy.py</code> <pre><code>@staticmethod\ndef format_path(path, representation):\n    \"\"\"Format file path correctly for single redshift proxy\n    or redshift proxy sequence.\"\"\"\n    # The path is either a single file or sequence in a folder.\n    is_sequence = bool(representation[\"context\"].get(\"frame\"))\n    if is_sequence:\n        folder, filename = os.path.split(path)\n        filename = re.sub(r\"(.*)\\.(\\d+)\\.(rs.*)\", \"\\\\1.$F4.\\\\3\", filename)\n        path = os.path.join(folder, filename)\n\n    path = os.path.normpath(path)\n    path = path.replace(\"\\\\\", \"/\")\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_shot_lop.html","title":"load_shot_lop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_shot_lop.html#client.ayon_houdini.plugins.load.load_shot_lop.LOPLoadShotLoader","title":"<code>LOPLoadShotLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load sublayer into Solaris using AYON Load Shot LOP</p> Source code in <code>client/ayon_houdini/plugins/load/load_shot_lop.py</code> <pre><code>class LOPLoadShotLoader(load.LoaderPlugin):\n    \"\"\"Load sublayer into Solaris using AYON Load Shot LOP\"\"\"\n\n    product_types = {\"*\"}\n    label = \"Load Shot (LOPs)\"\n    representations = [\"usd\", \"abc\", \"usda\", \"usdc\"]\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create node\n        network = find_active_network(\n            category=hou.lopNodeTypeCategory(),\n            default=\"/stage\"\n        )\n        node = network.createNode(\"ayon::load_shot\", node_name=node_name)\n        node.moveToGoodPosition()\n\n        hda_utils.set_node_representation_from_context(node, context)\n\n        nodes = [node]\n        self[:] = nodes\n\n    def update(self, container, context):\n        node = container[\"node\"]\n        hda_utils.set_node_representation_from_context(node, context)\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_usd_layer.html","title":"load_usd_layer","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_usd_layer.html#client.ayon_houdini.plugins.load.load_usd_layer.USDSublayerLoader","title":"<code>USDSublayerLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Sublayer USD file in Solaris</p> Source code in <code>client/ayon_houdini/plugins/load/load_usd_layer.py</code> <pre><code>class USDSublayerLoader(plugin.HoudiniLoader):\n    \"\"\"Sublayer USD file in Solaris\"\"\"\n\n    product_types = {\n        \"usd\",\n        \"usdCamera\",\n    }\n    label = \"Sublayer USD\"\n    representations = {\"usd\", \"usda\", \"usdlc\", \"usdnc\", \"abc\"}\n    order = 1\n\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    use_ayon_entity_uri = False\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Format file name, Houdini only wants forward slashes\n        file_path = self.filepath_from_context(context)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # Get the root node\n        stage = hou.node(\"/stage\")\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create USD reference\n        container = stage.createNode(\"sublayer\", node_name=node_name)\n        container.setParms({\"filepath1\": file_path})\n        container.moveToGoodPosition()\n\n        # Imprint it manually\n        data = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": node_name,\n            \"namespace\": namespace,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n        }\n\n        # todo: add folder=\"Avalon\"\n        lib.imprint(container, data)\n\n        return container\n\n    def update(self, container, context):\n        node = container[\"node\"]\n\n        # Update the file path\n        file_path = self.filepath_from_context(context)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # Update attributes\n        node.setParms(\n            {\n                \"filepath1\": file_path,\n                \"representation\": context[\"representation\"][\"id\"],\n            }\n        )\n\n        # Reload files\n        node.parm(\"reload\").pressButton()\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_usd_reference.html","title":"load_usd_reference","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_usd_reference.html#client.ayon_houdini.plugins.load.load_usd_reference.USDReferenceLoader","title":"<code>USDReferenceLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Reference USD file in Solaris</p> Source code in <code>client/ayon_houdini/plugins/load/load_usd_reference.py</code> <pre><code>class USDReferenceLoader(plugin.HoudiniLoader):\n    \"\"\"Reference USD file in Solaris\"\"\"\n\n    product_types = {\n        \"usd\",\n        \"usdCamera\",\n    }\n    label = \"Reference USD\"\n    representations = {\"usd\", \"usda\", \"usdlc\", \"usdnc\", \"abc\"}\n    order = -8\n\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    use_ayon_entity_uri = False\n\n    def load(self, context, name=None, namespace=None, data=None):\n\n        # Format file name, Houdini only wants forward slashes\n        file_path = self.filepath_from_context(context)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # Get the root node\n        stage = hou.node(\"/stage\")\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create USD reference\n        container = stage.createNode(\"reference\", node_name=node_name)\n        container.setParms({\"filepath1\": file_path})\n        container.moveToGoodPosition()\n\n        # Imprint it manually\n        data = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": node_name,\n            \"namespace\": namespace,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n        }\n\n        # todo: add folder=\"Avalon\"\n        lib.imprint(container, data)\n\n        return container\n\n    def update(self, container, context):\n        node = container[\"node\"]\n\n        # Update the file path\n        file_path = self.filepath_from_context(context)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # Update attributes\n        node.setParms(\n            {\n                \"filepath1\": file_path,\n                \"representation\": context[\"representation\"][\"id\"],\n            }\n        )\n\n        # Reload files\n        node.parm(\"reload\").pressButton()\n\n    def remove(self, container):\n\n        node = container[\"node\"]\n        node.destroy()\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_usd_sop.html","title":"load_usd_sop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_usd_sop.html#client.ayon_houdini.plugins.load.load_usd_sop.SopUsdImportLoader","title":"<code>SopUsdImportLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load USD to SOPs via <code>usdimport</code></p> Source code in <code>client/ayon_houdini/plugins/load/load_usd_sop.py</code> <pre><code>class SopUsdImportLoader(plugin.HoudiniLoader):\n    \"\"\"Load USD to SOPs via `usdimport`\"\"\"\n\n    label = \"Load USD to SOPs\"\n    product_types = {\"*\"}\n    representations = {\"usd\"}\n    order = -6\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    use_ayon_entity_uri = False\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Format file name, Houdini only wants forward slashes\n        file_path = self.filepath_from_context(context)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # Get the root node\n        obj = hou.node(\"/obj\")\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create a new geo node\n        container = obj.createNode(\"geo\", node_name=node_name)\n\n        # Create a usdimport node\n        usdimport = container.createNode(\"usdimport\", node_name=node_name)\n        usdimport.setParms({\"filepath1\": file_path})\n\n        # Set new position for unpack node else it gets cluttered\n        nodes = [container, usdimport]\n\n        return pipeline.containerise(\n            node_name,\n            namespace,\n            nodes,\n            context,\n            self.__class__.__name__,\n            suffix=\"\",\n        )\n\n    def update(self, container, context):\n        node = container[\"node\"]\n        try:\n            usdimport_node = next(\n                n for n in node.children() if n.type().name() == \"usdimport\"\n            )\n        except StopIteration:\n            self.log.error(\"Could not find node of type `usdimport`\")\n            return\n\n        # Update the file path\n        file_path = self.filepath_from_context(context)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        usdimport_node.setParms({\"filepath1\": file_path})\n\n        # Update attribute\n        node.setParms({\"representation\": context[\"representation\"][\"id\"]})\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def switch(self, container, representation):\n        self.update(container, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_vdb.html","title":"load_vdb","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/load_vdb.html#client.ayon_houdini.plugins.load.load_vdb.VdbLoader","title":"<code>VdbLoader</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Load VDB</p> Source code in <code>client/ayon_houdini/plugins/load/load_vdb.py</code> <pre><code>class VdbLoader(plugin.HoudiniLoader):\n    \"\"\"Load VDB\"\"\"\n\n    product_types = {\"vdbcache\"}\n    label = \"Load VDB\"\n    representations = {\"vdb\"}\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Get the root node\n        obj = hou.node(\"/obj\")\n\n        # Define node name\n        namespace = namespace if namespace else context[\"folder\"][\"name\"]\n        node_name = \"{}_{}\".format(namespace, name) if namespace else name\n\n        # Create a new geo node\n        container = obj.createNode(\"geo\", node_name=node_name)\n\n        # Remove the file node, it only loads static meshes\n        # Houdini 17 has removed the file node from the geo node\n        file_node = container.node(\"file1\")\n        if file_node:\n            file_node.destroy()\n\n        # Explicitly create a file node\n        file_node = container.createNode(\"file\", node_name=node_name)\n        path = self.filepath_from_context(context)\n        file_node.setParms(\n            {\"file\": self.format_path(path, context[\"representation\"])})\n\n        # Set display on last node\n        file_node.setDisplayFlag(True)\n\n        nodes = [container, file_node]\n        self[:] = nodes\n\n        return pipeline.containerise(\n            node_name,\n            namespace,\n            nodes,\n            context,\n            self.__class__.__name__,\n            suffix=\"\",\n        )\n\n    @staticmethod\n    def format_path(path, representation):\n        \"\"\"Format file path correctly for single vdb or vdb sequence.\"\"\"\n        # The path is either a single file or sequence in a folder.\n        is_sequence = bool(representation[\"context\"].get(\"frame\"))\n        if is_sequence:\n            folder, filename = os.path.split(path)\n            filename = re.sub(r\"(.*)\\.(\\d+)\\.vdb$\", \"\\\\1.$F4.vdb\", filename)\n            path = os.path.join(folder, filename)\n\n        path = os.path.normpath(path)\n        path = path.replace(\"\\\\\", \"/\")\n        return path\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        node = container[\"node\"]\n        try:\n            file_node = next(\n                n for n in node.children() if n.type().name() == \"file\"\n            )\n        except StopIteration:\n            self.log.error(\"Could not find node of type `alembic`\")\n            return\n\n        # Update the file path\n        file_path = self.filepath_from_context(context)\n        file_path = self.format_path(file_path, repre_entity)\n\n        file_node.setParms({\"file\": file_path})\n\n        # Update attribute\n        node.setParms({\"representation\": repre_entity[\"id\"]})\n\n    def remove(self, container):\n        node = container[\"node\"]\n        node.destroy()\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/load_vdb.html#client.ayon_houdini.plugins.load.load_vdb.VdbLoader.format_path","title":"<code>format_path(path, representation)</code>  <code>staticmethod</code>","text":"<p>Format file path correctly for single vdb or vdb sequence.</p> Source code in <code>client/ayon_houdini/plugins/load/load_vdb.py</code> <pre><code>@staticmethod\ndef format_path(path, representation):\n    \"\"\"Format file path correctly for single vdb or vdb sequence.\"\"\"\n    # The path is either a single file or sequence in a folder.\n    is_sequence = bool(representation[\"context\"].get(\"frame\"))\n    if is_sequence:\n        folder, filename = os.path.split(path)\n        filename = re.sub(r\"(.*)\\.(\\d+)\\.vdb$\", \"\\\\1.$F4.vdb\", filename)\n        path = os.path.join(folder, filename)\n\n    path = os.path.normpath(path)\n    path = path.replace(\"\\\\\", \"/\")\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/load/show_usdview.html","title":"show_usdview","text":""},{"location":"autoapi/client/ayon_houdini/plugins/load/show_usdview.html#client.ayon_houdini.plugins.load.show_usdview.ShowInUsdview","title":"<code>ShowInUsdview</code>","text":"<p>               Bases: <code>HoudiniLoader</code></p> <p>Open USD file in usdview</p> Source code in <code>client/ayon_houdini/plugins/load/show_usdview.py</code> <pre><code>class ShowInUsdview(plugin.HoudiniLoader):\n    \"\"\"Open USD file in usdview\"\"\"\n\n    label = \"Show in usdview\"\n    representations = {\"*\"}\n    product_types = {\"*\"}\n    extensions = {\"usd\", \"usda\", \"usdlc\", \"usdnc\", \"abc\"}\n    order = 15\n\n    icon = \"code-fork\"\n    color = \"white\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        from pathlib import Path\n\n        if platform.system() == \"Windows\":\n            if hou.applicationVersion()[0] &gt;= 20:\n                executable = \"usdview.cmd\"\n            else:\n                executable = \"usdview.bat\"\n        else:\n            executable = \"usdview\"\n\n        usdview = find_executable(executable)\n        if not usdview:\n            raise RuntimeError(\"Unable to find usdview\")\n\n        # For some reason Windows can return the path like:\n        # C:/PROGRA~1/SIDEEF~1/HOUDIN~1.435/bin/usdview\n        # convert to resolved path so `subprocess` can take it\n        usdview = str(Path(usdview).resolve().as_posix())\n\n        filepath = self.filepath_from_context(context)\n        filepath = os.path.normpath(filepath)\n        filepath = filepath.replace(\"\\\\\", \"/\")\n\n        if not os.path.exists(filepath):\n            self.log.error(\"File does not exist: %s\" % filepath)\n            return\n\n        self.log.info(\"Start houdini variant of usdview...\")\n\n        subprocess.Popen([usdview, filepath, \"--renderer\", \"GL\"])\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_arnold_rop.html","title":"collect_arnold_rop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_arnold_rop.html#client.ayon_houdini.plugins.publish.collect_arnold_rop.CollectArnoldROPRenderProducts","title":"<code>CollectArnoldROPRenderProducts</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect Arnold ROP Render Products</p> <p>Collects the instance.data[\"files\"] for the render products.</p> Provides <p>instance    -&gt; files</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_arnold_rop.py</code> <pre><code>class CollectArnoldROPRenderProducts(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect Arnold ROP Render Products\n\n    Collects the instance.data[\"files\"] for the render products.\n\n    Provides:\n        instance    -&gt; files\n\n    \"\"\"\n\n    label = \"Arnold ROP Render Products\"\n    # This specific order value is used so that\n    # this plugin runs after CollectFrames\n    order = pyblish.api.CollectorOrder + 0.11\n    families = [\"arnold_rop\"]\n\n    def process(self, instance):\n\n        rop = hou.node(instance.data.get(\"instance_node\"))\n\n        default_prefix = evalParmNoFrame(rop, \"ar_picture\")\n        render_products = []\n\n        export_prefix = None\n        export_products = []\n        if instance.data[\"splitRender\"]:\n            export_prefix = evalParmNoFrame(\n                rop, \"ar_ass_file\", pad_character=\"0\"\n            )\n            beauty_export_product = self.get_render_product_name(\n                prefix=export_prefix,\n                suffix=None)\n            export_products.append(beauty_export_product)\n            self.log.debug(\n                \"Found export product: {}\".format(beauty_export_product)\n            )\n            instance.data[\"ifdFile\"] = beauty_export_product\n            instance.data[\"exportFiles\"] = list(export_products)\n\n        # Default beauty AOV\n        beauty_product = self.get_render_product_name(prefix=default_prefix,\n                                                      suffix=None)\n        render_products.append(beauty_product)\n\n        files_by_aov = {\n            \"\": self.generate_expected_files(instance, beauty_product)\n        }\n\n        # Assume it's a multipartExr Render.\n        multipartExr = True\n\n        num_aovs = rop.evalParm(\"ar_aovs\")\n\n        for index in range(1, num_aovs + 1):\n            aov_enabled = rop.evalParm(\"ar_enable_aov{}\".format(index))\n            aov_sep = rop.evalParm(\"ar_aov_separate{}\".format(index))\n            aov_path = rop.evalParm(\"ar_aov_separate_file{}\".format(index))\n\n            # Skip disabled AOVs or AOVs with no separate aov file path\n            if not all((aov_enabled, aov_path, aov_sep)):\n                continue\n\n            if rop.evalParm(\"ar_aov_exr_enable_layer_name{}\".format(index)):\n                label = rop.evalParm(\"ar_aov_exr_layer_name{}\".format(index))\n            else:\n                label = evalParmNoFrame(rop, \"ar_aov_label{}\".format(index))\n\n            # NOTE:\n            #  we don't collect the actual AOV path but rather assume\n            #    the user has used the default beauty path (collected above)\n            #    with the AOV name before the extension.\n            #  Also, Note that Ayon Publishing does not require a specific\n            #    file name, as it will be renamed according to the naming\n            #    conventions set in the publish template.\n            aov_product = self.get_render_product_name(\n                prefix=default_prefix, suffix=label\n            )\n            render_products.append(aov_product)\n            files_by_aov[label] = self.generate_expected_files(\n                instance, aov_product\n            )\n\n            # Set to False as soon as we have a separated aov.\n            multipartExr = False\n\n        # Review Logic expects this key to exist and be True\n        # if render is a multipart Exr.\n        # As long as we have one AOV then multipartExr should be True.\n        instance.data[\"multipartExr\"] = multipartExr\n\n        for product in render_products:\n            self.log.debug(\"Found render product: {}\".format(product))\n\n        instance.data[\"files\"] = list(render_products)\n\n        # For now by default do NOT try to publish the rendered output\n        instance.data[\"publishJobState\"] = \"Suspended\"\n        instance.data[\"attachTo\"] = []      # stub required data\n\n        if \"expectedFiles\" not in instance.data:\n            instance.data[\"expectedFiles\"] = list()\n        instance.data[\"expectedFiles\"].append(files_by_aov)\n\n    def get_render_product_name(self, prefix, suffix):\n        \"\"\"Return the output filename using the AOV prefix and suffix\"\"\"\n\n        # When AOV is explicitly defined in prefix we just swap it out\n        # directly with the AOV suffix to embed it.\n        # Note: ${AOV} seems to be evaluated in the parameter as %AOV%\n        if \"%AOV%\" in prefix:\n            # It seems that when some special separator characters are present\n            # before the %AOV% token that Redshift will secretly remove it if\n            # there is no suffix for the current product, for example:\n            # foo_%AOV% -&gt; foo.exr\n            pattern = \"%AOV%\" if suffix else \"[._-]?%AOV%\"\n            product_name = re.sub(pattern,\n                                  suffix,\n                                  prefix,\n                                  flags=re.IGNORECASE)\n        else:\n            if suffix:\n                # Add \".{suffix}\" before the extension\n                prefix_base, ext = os.path.splitext(prefix)\n                product_name = prefix_base + \".\" + suffix + ext\n            else:\n                product_name = prefix\n\n        return product_name\n\n    def generate_expected_files(self, instance, path):\n        \"\"\"Create expected files in instance data\"\"\"\n\n        dir = os.path.dirname(path)\n        file = os.path.basename(path)\n\n        if \"#\" in file:\n            def replace(match):\n                return \"%0{}d\".format(len(match.group()))\n\n            file = re.sub(\"#+\", replace, file)\n\n        if \"%\" not in file:\n            return path\n\n        expected_files = []\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n\n        for i in range(int(start), (int(end) + 1)):\n            expected_files.append(\n                os.path.join(dir, (file % i)).replace(\"\\\\\", \"/\"))\n\n        return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_arnold_rop.html#client.ayon_houdini.plugins.publish.collect_arnold_rop.CollectArnoldROPRenderProducts.generate_expected_files","title":"<code>generate_expected_files(instance, path)</code>","text":"<p>Create expected files in instance data</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_arnold_rop.py</code> <pre><code>def generate_expected_files(self, instance, path):\n    \"\"\"Create expected files in instance data\"\"\"\n\n    dir = os.path.dirname(path)\n    file = os.path.basename(path)\n\n    if \"#\" in file:\n        def replace(match):\n            return \"%0{}d\".format(len(match.group()))\n\n        file = re.sub(\"#+\", replace, file)\n\n    if \"%\" not in file:\n        return path\n\n    expected_files = []\n    start = instance.data[\"frameStartHandle\"]\n    end = instance.data[\"frameEndHandle\"]\n\n    for i in range(int(start), (int(end) + 1)):\n        expected_files.append(\n            os.path.join(dir, (file % i)).replace(\"\\\\\", \"/\"))\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_arnold_rop.html#client.ayon_houdini.plugins.publish.collect_arnold_rop.CollectArnoldROPRenderProducts.get_render_product_name","title":"<code>get_render_product_name(prefix, suffix)</code>","text":"<p>Return the output filename using the AOV prefix and suffix</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_arnold_rop.py</code> <pre><code>def get_render_product_name(self, prefix, suffix):\n    \"\"\"Return the output filename using the AOV prefix and suffix\"\"\"\n\n    # When AOV is explicitly defined in prefix we just swap it out\n    # directly with the AOV suffix to embed it.\n    # Note: ${AOV} seems to be evaluated in the parameter as %AOV%\n    if \"%AOV%\" in prefix:\n        # It seems that when some special separator characters are present\n        # before the %AOV% token that Redshift will secretly remove it if\n        # there is no suffix for the current product, for example:\n        # foo_%AOV% -&gt; foo.exr\n        pattern = \"%AOV%\" if suffix else \"[._-]?%AOV%\"\n        product_name = re.sub(pattern,\n                              suffix,\n                              prefix,\n                              flags=re.IGNORECASE)\n    else:\n        if suffix:\n            # Add \".{suffix}\" before the extension\n            prefix_base, ext = os.path.splitext(prefix)\n            product_name = prefix_base + \".\" + suffix + ext\n        else:\n            product_name = prefix\n\n    return product_name\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_cache_farm.html","title":"collect_cache_farm","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_cache_farm.html#client.ayon_houdini.plugins.publish.collect_cache_farm.CollectDataforCache","title":"<code>CollectDataforCache</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect data for caching to Deadline.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_cache_farm.py</code> <pre><code>class CollectDataforCache(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect data for caching to Deadline.\"\"\"\n\n    # Run after Collect Frames\n    order = pyblish.api.CollectorOrder + 0.11\n    families = [\"publish.hou\"]\n    targets = [\"local\", \"remote\"]\n    label = \"Collect Data for Cache\"\n\n    def process(self, instance):\n        # Why do we need this particular collector to collect the expected\n        # output files from a ROP node. Don't we have a dedicated collector\n        # for that yet?\n        # Answer: No, we don't have a generic expected file collector.\n        #         Because different product types needs different logic.\n        #         e.g. check CollectMantraROPRenderProducts\n        #               and CollectKarmaROPRenderProducts\n        # Collect expected files\n        ropnode = hou.node(instance.data[\"instance_node\"])\n        output_parm = lib.get_output_parameter(ropnode)\n        expected_filepath = output_parm.eval()\n\n        files = instance.data.setdefault(\"files\", list())\n        frames = instance.data.get(\"frames\", \"\")\n        if isinstance(frames, str):\n            # single file\n            files.append(expected_filepath)\n        else:\n            # list of files\n            staging_dir, _ = os.path.split(expected_filepath)\n            files.extend(\"{}/{}\".format(staging_dir, f) for f in frames)\n\n        expected_files = instance.data.setdefault(\"expectedFiles\", list())\n        expected_files.append({\"cache\": files})\n        self.log.debug(f\"Caching on farm expected files: {expected_files}\")\n\n        instance.data.update({\n             # used in HoudiniCacheSubmitDeadline in ayon-deadline\n            \"plugin\": \"Houdini\",\n            \"publish\": True\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_cache_farm.html#client.ayon_houdini.plugins.publish.collect_cache_farm.CollectFarmCacheFamily","title":"<code>CollectFarmCacheFamily</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect publish.hou family for caching on farm as early as possible.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_cache_farm.py</code> <pre><code>class CollectFarmCacheFamily(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect publish.hou family for caching on farm as early as possible.\"\"\"\n    order = pyblish.api.CollectorOrder - 0.45\n    families = [\"ass\", \"pointcache\", \"redshiftproxy\",\n                \"vdbcache\", \"model\", \"staticMesh\",\n                 \"rop.opengl\", \"usdrop\", \"camera\"]\n    targets = [\"local\", \"remote\"]\n    label = \"Collect Data for Cache\"\n\n    def process(self, instance):\n\n        if not instance.data[\"farm\"]:\n            self.log.debug(\"Caching on farm is disabled. \"\n                           \"Skipping farm collecting.\")\n            return\n        instance.data[\"families\"].append(\"publish.hou\")\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_componentbuilder_lop.html","title":"collect_componentbuilder_lop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_componentbuilder_lop.html#client.ayon_houdini.plugins.publish.collect_componentbuilder_lop.compute_all_dependencies","title":"<code>compute_all_dependencies(filepath)</code>","text":"<p>Compute all dependencies for the given USD file.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_componentbuilder_lop.py</code> <pre><code>def compute_all_dependencies(\n        filepath: str) -&gt; Tuple[list[Sdf.Layer], list[str], list[str]]:\n    \"\"\"Compute all dependencies for the given USD file.\"\"\"\n    # Only separated here for better type hints on returned values\n    return UsdUtils.ComputeAllDependencies(filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_current_file.html","title":"collect_current_file","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_current_file.html#client.ayon_houdini.plugins.publish.collect_current_file.CollectHoudiniCurrentFile","title":"<code>CollectHoudiniCurrentFile</code>","text":"<p>               Bases: <code>HoudiniContextPlugin</code></p> <p>Inject the current working file into context</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_current_file.py</code> <pre><code>class CollectHoudiniCurrentFile(plugin.HoudiniContextPlugin):\n    \"\"\"Inject the current working file into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.1\n    label = \"Houdini Current File\"\n\n    def process(self, context):\n        \"\"\"Inject the current working file\"\"\"\n\n        current_file = hou.hipFile.path()\n        if (\n                hou.hipFile.isNewFile()\n                or not os.path.exists(current_file)\n        ):\n            # By default, Houdini will even point a new scene to a path.\n            # However if the file is not saved at all and does not exist,\n            # we assume the user never set it.\n            self.log.warning(\"Houdini workfile is unsaved.\")\n            current_file = \"\"\n\n        context.data[\"currentFile\"] = current_file\n        self.log.info('Current workfile path: {}'.format(current_file))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_current_file.html#client.ayon_houdini.plugins.publish.collect_current_file.CollectHoudiniCurrentFile.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_current_file.py</code> <pre><code>def process(self, context):\n    \"\"\"Inject the current working file\"\"\"\n\n    current_file = hou.hipFile.path()\n    if (\n            hou.hipFile.isNewFile()\n            or not os.path.exists(current_file)\n    ):\n        # By default, Houdini will even point a new scene to a path.\n        # However if the file is not saved at all and does not exist,\n        # we assume the user never set it.\n        self.log.warning(\"Houdini workfile is unsaved.\")\n        current_file = \"\"\n\n    context.data[\"currentFile\"] = current_file\n    self.log.info('Current workfile path: {}'.format(current_file))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_farm_instances.html","title":"collect_farm_instances","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_farm_instances.html#client.ayon_houdini.plugins.publish.collect_farm_instances.CollectFarmInstances","title":"<code>CollectFarmInstances</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect instances for farm render.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_farm_instances.py</code> <pre><code>class CollectFarmInstances(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect instances for farm render.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.49\n    families = [\"mantra_rop\",\n                \"karma_rop\",\n                \"redshift_rop\",\n                \"arnold_rop\",\n                \"vray_rop\",\n                \"usdrender\",\n                \"ass\",\"pointcache\", \"redshiftproxy\",\n                \"vdbcache\", \"model\", \"staticMesh\",\n                \"rop.opengl\", \"usdrop\", \"camera\"]\n\n    targets = [\"local\", \"remote\"]\n    label = \"Collect farm instances\"\n\n    def process(self, instance):\n\n        creator_attribute = instance.data[\"creator_attributes\"]\n\n        # Collect Render Target\n        if creator_attribute.get(\"render_target\") not in {\n            \"farm_split\", \"farm\"\n        }:\n            instance.data[\"farm\"] = False\n            instance.data[\"splitRender\"] = False\n            self.log.debug(\"Render on farm is disabled. \"\n                           \"Skipping farm collecting.\")\n            return\n\n        instance.data[\"farm\"] = True\n        instance.data[\"splitRender\"] = (\n            creator_attribute.get(\"render_target\") == \"farm_split\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_files_for_cleaning_up.html","title":"collect_files_for_cleaning_up","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_files_for_cleaning_up.html#client.ayon_houdini.plugins.publish.collect_files_for_cleaning_up.CollectFilesForCleaningUp","title":"<code>CollectFilesForCleaningUp</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Collect Files For Cleaning Up.</p> <p>This collector collects output files and adds them to file remove list.</p> CAUTION <p>This collector registers exported files and   the parent folder for deletion in <code>ExplicitCleanUp</code> plug-in.   please refer to <code>ExplicitCleanUp</code>'s docstring for further info.</p> Notes <p>Artists are free to change the file path in the ROP node.</p> <p>Farm instances will be processed on farm by other dedicated plugins   that live in core addon e.g. <code>CollectRenderedFiles</code> plugin. These dedicated plugins don't support tracking and removing   intermediate render files.</p> <p>Local Render instances don't track intermediate render files, Therefore, this plugin doesn't support removing   intermediate render files.</p> <p>HDA is not added to this plugin's options in server settings. Cleaning up HDA products will break the scene as Houdini will no longer   be able to find the HDA file. In addition,HDA plugins always save HDAs to external files. Therefore, Cleaning up HDA products will break the ability to go back   to the workfile and continue on the HDA.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_files_for_cleaning_up.py</code> <pre><code>class CollectFilesForCleaningUp(plugin.HoudiniInstancePlugin,\n                                AYONPyblishPluginMixin):\n    \"\"\"Collect Files For Cleaning Up.\n\n    This collector collects output files and adds them to file remove list.\n\n    CAUTION:\n        This collector registers exported files and\n          the parent folder for deletion in `ExplicitCleanUp` plug-in.\n          please refer to `ExplicitCleanUp`'s docstring for further info.\n\n    Notes:\n        Artists are free to change the file path in the ROP node.\n\n        Farm instances will be processed on farm by other dedicated plugins\n          that live in core addon e.g. `CollectRenderedFiles` plugin.\n        These dedicated plugins don't support tracking and removing\n          intermediate render files.\n\n        Local Render instances don't track intermediate render files,\n        Therefore, this plugin doesn't support removing\n          intermediate render files.\n\n        HDA is not added to this plugin's options in server settings.\n        Cleaning up HDA products will break the scene as Houdini will no longer\n          be able to find the HDA file.\n        In addition,HDA plugins always save HDAs to external files.\n        Therefore, Cleaning up HDA products will break the ability to go back\n          to the workfile and continue on the HDA.\n    \"\"\"\n\n    # It should run after CollectFrames and Collect Render plugins,\n    # and before CollectLocalRenderInstances.\n    order = pyblish.api.CollectorOrder + 0.115\n\n    hosts = [\"houdini\"]\n    families = [\"*\"]\n    label = \"Collect Files For Cleaning Up\"\n\n    def process(self, instance):\n\n        if instance.data.get(\"farm\"):\n            self.log.debug(\"Should be processed on farm, skipping.\")\n            return\n\n        files: List[str] = []\n        staging_dirs: List[str] = []\n        expected_files = instance.data.get(\"expectedFiles\", [])\n\n        # Prefer 'expectedFiles' over 'frames' because it usually contains more\n        # output files than just a single file or single sequence of files.\n        if expected_files:\n            # Products with expected files\n            # This can be Render products or submitted cache to farm.\n            for expected in expected_files:\n                # expected.values() is a list of lists\n                for output_files in expected.values():\n                    staging_dir, _ = os.path.split(output_files[0])\n                    if staging_dir not in staging_dirs:\n                        staging_dirs.append(staging_dir)\n                    files.extend(output_files)\n        else:\n            # Products with frames or single file.\n\n            frames = instance.data.get(\"frames\")\n            if frames is None:\n                self.log.warning(\n                    f\"No frames data found on instance {instance}\"\n                    \". Skipping collection for caching on farm...\"\n                )\n                return\n\n            staging_dir = instance.data.get(\"stagingDir\")\n            staging_dirs.append(staging_dir)\n\n            if isinstance(frames, str):\n                # single file.\n                files.append(f\"{staging_dir}/{frames}\")\n            else:\n                # list of frame.\n                files.extend(\n                    [f\"{staging_dir}/{frame}\" for frame in frames]\n                )\n\n        self.log.debug(\n            f\"Add directories to 'cleanupEmptyDir': {staging_dirs}\")\n        instance.context.data[\"cleanupEmptyDirs\"].extend(staging_dirs)\n\n        self.log.debug(\"Add files to 'cleanupFullPaths': {}\".format(files))\n        instance.context.data[\"cleanupFullPaths\"].extend(files)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_frames.html","title":"collect_frames","text":"<p>Collector plugin for frames data on ROP instances.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_frames.html#client.ayon_houdini.plugins.publish.collect_frames.CollectFrames","title":"<code>CollectFrames</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect all frames which would be saved from the ROP nodes</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_frames.py</code> <pre><code>class CollectFrames(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect all frames which would be saved from the ROP nodes\"\"\"\n\n    # This specific order value is used so that\n    # this plugin runs after CollectRopFrameRange\n    order = pyblish.api.CollectorOrder + 0.1\n    label = \"Collect Frames\"\n    families = [\"camera\", \"vdbcache\", \"imagesequence\", \"ass\",\n                \"redshiftproxy\", \"review\", \"pointcache\", \"fbx\",\n                \"model\", \"bgeo\"]\n\n    def process(self, instance):\n\n        # CollectRopFrameRange computes `start_frame` and `end_frame`\n        #  depending on the trange value.\n        start_frame = instance.data[\"frameStartHandle\"]\n        end_frame = instance.data[\"frameEndHandle\"]\n\n        # Evaluate the file name at the first frame.\n        ropnode = hou.node(instance.data[\"instance_node\"])\n        output_parm = lib.get_output_parameter(ropnode)\n        output = output_parm.evalAtFrame(start_frame)\n        file_name = os.path.basename(output)\n\n        # todo: `frames` currently conflicts with \"explicit frames\" for a\n        #       for a custom frame list. So this should be refactored.\n\n        instance.data.update({\n            \"frames\": file_name,  # Set frames to the file name by default.\n            \"stagingDir\": os.path.dirname(output)\n        })\n\n        # Skip unnecessary logic if start and end frames are equal.\n        if start_frame == end_frame:\n            return\n\n        # Create collection using frame pattern.\n        # e.g. 'pointcacheBgeoCache_AB010.1001.bgeo'\n        # will be &lt;Collection \"pointcacheBgeoCache_AB010.%d.bgeo [1001]\"&gt;\n        frame_collection, _ = clique.assemble(\n            [file_name],\n            patterns=[clique.PATTERNS[\"frames\"]],\n            minimum_items=1\n        )\n\n        # Return as no frame pattern detected.\n        if not frame_collection:\n            return\n\n        # It's always expected to be one collection.\n        frame_collection = frame_collection[0]\n        frame_collection.indexes.clear()\n        frame_collection.indexes.update(\n            list(range(start_frame, end_frame + 1))\n        )\n        instance.data[\"frames\"] = list(frame_collection)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_frames_fix.html","title":"collect_frames_fix","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_frames_fix.html#client.ayon_houdini.plugins.publish.collect_frames_fix.CollectFramesFixDefHou","title":"<code>CollectFramesFixDefHou</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Provides text field to insert frame(s) to be re-rendered.</p> <p>Published files of last version of an instance product are collected into <code>instance.data[\"last_version_published_files\"]</code>. All these but frames mentioned in text field will be reused for new version.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_frames_fix.py</code> <pre><code>class CollectFramesFixDefHou(\n    plugin.HoudiniInstancePlugin,\n    AYONPyblishPluginMixin\n):\n    \"\"\"Provides text field to insert frame(s) to be re-rendered.\n\n    Published files of last version of an instance product are collected into\n    `instance.data[\"last_version_published_files\"]`. All these but frames\n    mentioned in text field will be reused for new version.\n    \"\"\"\n    order = pyblish.api.CollectorOrder + 0.495\n    label = \"Collect Frames to Fix\"\n    targets = [\"local\"]\n    families = [\"*\"]\n\n    rewrite_version_enable = False\n\n    def process(self, instance):\n        attribute_values = self.get_attr_values_from_data(instance.data)\n        frames_to_fix: str = attribute_values.get(\"frames_to_fix\", \"\")\n        rewrite_version: bool = (\n            self.rewrite_version_enable\n            and attribute_values.get(\"rewrite_version\", False)\n        )\n        if not frames_to_fix:\n            if rewrite_version:\n                self.log.warning(\n                    \"Rewrite version is enabled but no frames to fix are \"\n                    \"specified. Rewriting last version will be skipped.\")\n            return\n\n        self.log.info(f\"Frames to fix: {frames_to_fix}\")\n        instance.data[\"frames_to_fix\"] = frames_to_fix\n\n        # Skip instances that are set to not be integrated so we ignore\n        # the original `render` instance from which local AOV instances are\n        # spawned off.\n        if not instance.data.get(\"integrate\", True):\n            self.log.debug(\"Skipping collecting frames to fix data for \"\n                           \"instance because instance is set to not integrate\")\n            return\n\n        product_name: str = instance.data[\"productName\"]\n        folder_entity: dict = instance.data[\"folderEntity\"]\n        project_entity: dict = instance.data[\"projectEntity\"]\n        project_name: str = project_entity[\"name\"]\n\n        product_entity = ayon_api.get_product_by_name(\n            project_name,\n            product_name,\n            folder_id=folder_entity[\"id\"])\n        if not product_entity:\n            self.log.warning(\n                f\"No existing product found for '{product_name}'. \"\n                \"Re-render not possible.\"\n            )\n            return\n\n        product_type = product_entity[\"productType\"]\n        instance_product_type = instance.data[\"productType\"]\n        if product_type != instance_product_type:\n            self.log.error(\n                f\"Existing product '{product_name}' product type \"\n                f\"'{product_type}' is not the same as instance product type \"\n                f\"'{instance_product_type}'. Re-render may have unintended \"\n                f\"side effects.\")\n\n        version_entity = ayon_api.get_last_version_by_product_id(\n            project_name,\n            product_id=product_entity[\"id\"],\n        )\n        if not version_entity:\n            self.log.warning(\n                f\"No last version found for product '{product_name}', \"\n                \"re-render not possible.\"\n            )\n            return\n\n        representations = ayon_api.get_representations(\n            project_name, version_ids={version_entity[\"id\"]}\n        )\n\n        # Get all published files for the representation\n        published_files: \"list[str]\" = []\n        for repre in representations:\n            for file_info in repre.get(\"files\"):\n                published_files.append(file_info[\"path\"])\n\n        instance.data[\"last_version_published_files\"] = published_files\n        self.log.debug(f\"last_version_published_files: {published_files}\")\n\n        if rewrite_version:\n            instance.data[\"version\"] = version_entity[\"version\"]\n            # limits triggering version validator\n            instance.data.pop(\"latestVersion\")\n\n    @classmethod\n    def get_attribute_defs(cls):\n        attributes = [\n            TextDef(\"frames_to_fix\", label=\"Frames to fix\",\n                    placeholder=\"5,10-15\",\n                    regex=\"[0-9,-]+\",\n                    tooltip=(\n                        \"When specified, only these frames will be rendered.\\n\"\n                        \"The remainder of the frame range for the instance \"\n                        \"will be copied from the previous published version.\\n\"\n                        \"This allows re-rendering only certain frames or \"\n                        \"extending the frame range of the previous version.\\n\"\n                        \"The frames to fix must be inside the instance's \"\n                        \"frame range.\\n\"\n                        \"Example: 5,10-15\"\n                    ))\n        ]\n\n        if cls.rewrite_version_enable:\n            attributes.append(\n                BoolDef(\n                    \"rewrite_version\",\n                    label=\"Rewrite latest version\",\n                    default=False,\n                    tooltip=(\n                        \"When enabled the new version will be published into\"\n                        \"the previous version and apply only the 'fixed \"\n                        \"frames'.\\n\"\n                        \"**Note:** This does nothing if no Frames to Fix are \"\n                        \"specified.\"\n                    )\n                )\n            )\n\n        return attributes\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_inputs.html","title":"collect_inputs","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_inputs.html#client.ayon_houdini.plugins.publish.collect_inputs.CollectUpstreamInputs","title":"<code>CollectUpstreamInputs</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect source input containers used for this publish.</p> <p>This will include <code>inputs</code> data of which loaded publishes were used in the generation of this publish. This leaves an upstream trace to what was used as input.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_inputs.py</code> <pre><code>class CollectUpstreamInputs(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect source input containers used for this publish.\n\n    This will include `inputs` data of which loaded publishes were used in the\n    generation of this publish. This leaves an upstream trace to what was used\n    as input.\n\n    \"\"\"\n\n    label = \"Collect Inputs\"\n    order = pyblish.api.CollectorOrder + 0.4\n\n    def process(self, instance):\n        # We can't get the \"inputAncestors\" directly from the ROP\n        # node, so we find the related output node (set in SOP/COP path)\n        # and include that together with its ancestors\n        output = instance.data.get(\"output_node\")\n\n        if output is None:\n            # If no valid output node is set then ignore it as validation\n            # will be checking those cases.\n            self.log.debug(\n                \"No output node found, skipping collecting of inputs..\"\n            )\n            return\n\n        # For large scenes the querying of \"host.ls()\" can be relatively slow\n        # e.g. up to a second. Many instances calling it easily slows this\n        # down. As such, we cache it so we trigger it only once.\n        # todo: Instead of hidden cache make \"CollectContainers\" plug-in\n        cache_key = \"__cache_containers\"\n        scene_containers = instance.context.data.get(cache_key, None)\n        if scene_containers is None:\n            # Query the scenes' containers if there's no cache yet\n            host = registered_host()\n            scene_containers = list(host.ls())\n            for container in scene_containers:\n                # Embed the members into the container dictionary\n                container_members = set(get_container_members(container))\n                container[\"_members\"] = container_members\n            instance.context.data[cache_key] = scene_containers\n\n        inputs = []\n        if scene_containers:\n            # Collect all upstream parents\n            nodes = list(iter_upstream(output))\n            nodes.append(output)\n\n            # Collect containers for the given set of nodes\n            containers = collect_input_containers(scene_containers, nodes)\n\n            inputs = [c[\"representation\"] for c in containers]\n\n        instance.data[\"inputRepresentations\"] = inputs\n        self.log.debug(\"Collected inputs: %s\" % inputs)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_inputs.html#client.ayon_houdini.plugins.publish.collect_inputs.collect_input_containers","title":"<code>collect_input_containers(containers, nodes)</code>","text":"<p>Collect containers that contain any of the node in <code>nodes</code>.</p> <p>This will return any loaded Avalon container that contains at least one of the nodes. As such, the Avalon container is an input for it. Or in short, there are member nodes of that container.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Loaded containers that contain the <code>nodes</code></p> Source code in <code>client/ayon_houdini/plugins/publish/collect_inputs.py</code> <pre><code>def collect_input_containers(containers, nodes):\n    \"\"\"Collect containers that contain any of the node in `nodes`.\n\n    This will return any loaded Avalon container that contains at least one of\n    the nodes. As such, the Avalon container is an input for it. Or in short,\n    there are member nodes of that container.\n\n    Returns:\n        list: Loaded containers that contain the `nodes`\n\n    \"\"\"\n    # Assume the containers have collected their cached '_members' data\n    # in the collector.\n    return [container for container in containers\n            if any(node in container[\"_members\"] for node in nodes)]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_inputs.html#client.ayon_houdini.plugins.publish.collect_inputs.iter_upstream","title":"<code>iter_upstream(node)</code>","text":"<p>Yields all upstream inputs for the current node.</p> <p>This includes all <code>node.inputAncestors()</code> but also traverses through all <code>node.references()</code> for the node itself and for any of the upstream nodes. This method has no max-depth and will collect all upstream inputs.</p> <p>Yields:</p> Type Description <p>hou.Node: The upstream nodes, including references.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_inputs.py</code> <pre><code>def iter_upstream(node):\n    \"\"\"Yields all upstream inputs for the current node.\n\n    This includes all `node.inputAncestors()` but also traverses through all\n    `node.references()` for the node itself and for any of the upstream nodes.\n    This method has no max-depth and will collect all upstream inputs.\n\n    Yields:\n        hou.Node: The upstream nodes, including references.\n\n    \"\"\"\n\n    upstream = node.inputAncestors(\n        include_ref_inputs=True, follow_subnets=True\n    )\n\n    # Initialize process queue with the node's ancestors itself\n    queue = deque(upstream)\n    collected = set(upstream)\n\n    # Traverse upstream references for all nodes and yield them as we\n    # process the queue.\n    while queue:\n        upstream_node = queue.pop()\n        yield upstream_node\n\n        # Find its references that are not collected yet.\n        references = upstream_node.references()\n        references = [n for n in references if n not in collected]\n\n        queue.extend(references)\n        collected.update(references)\n\n        # Include the references' ancestors that have not been collected yet.\n        for reference in references:\n            if reference in collected:\n                # Might have been collected in previous iteration\n                continue\n\n            ancestors = reference.inputAncestors(\n                include_ref_inputs=True, follow_subnets=True\n            )\n            ancestors = [n for n in ancestors if n not in collected]\n\n            queue.extend(ancestors)\n            collected.update(ancestors)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_karma_rop.html","title":"collect_karma_rop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_karma_rop.html#client.ayon_houdini.plugins.publish.collect_karma_rop.CollectKarmaROPRenderProducts","title":"<code>CollectKarmaROPRenderProducts</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect Karma Render Products</p> <p>Collects the instance.data[\"files\"] for the multipart render product.</p> Provides <p>instance    -&gt; files</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_karma_rop.py</code> <pre><code>class CollectKarmaROPRenderProducts(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect Karma Render Products\n\n    Collects the instance.data[\"files\"] for the multipart render product.\n\n    Provides:\n        instance    -&gt; files\n\n    \"\"\"\n\n    label = \"Karma ROP Render Products\"\n    # This specific order value is used so that\n    # this plugin runs after CollectFrames\n    order = pyblish.api.CollectorOrder + 0.11\n    families = [\"karma_rop\"]\n\n    def process(self, instance):\n\n        rop = hou.node(instance.data.get(\"instance_node\"))\n\n        default_prefix = evalParmNoFrame(rop, \"picture\")\n        render_products = []\n\n        # Default beauty AOV\n        beauty_product = self.get_render_product_name(\n            prefix=default_prefix, suffix=None\n        )\n        render_products.append(beauty_product)\n\n        files_by_aov = {\n            \"beauty\": self.generate_expected_files(instance,\n                                                   beauty_product)\n        }\n\n        # Review Logic expects this key to exist and be True\n        # if render is a multipart Exr.\n        # As long as we have one AOV then multipartExr should be True.\n        # By default karma render is a multipart Exr.\n        instance.data[\"multipartExr\"] = True\n\n        filenames = list(render_products)\n        instance.data[\"files\"] = filenames\n\n        for product in render_products:\n            self.log.debug(\"Found render product: %s\" % product)\n\n        if \"expectedFiles\" not in instance.data:\n            instance.data[\"expectedFiles\"] = list()\n        instance.data[\"expectedFiles\"].append(files_by_aov)\n\n    def get_render_product_name(self, prefix, suffix):\n        product_name = prefix\n        if suffix:\n            # Add \".{suffix}\" before the extension\n            prefix_base, ext = os.path.splitext(prefix)\n            product_name = \"{}.{}{}\".format(prefix_base, suffix, ext)\n\n        return product_name\n\n    def generate_expected_files(self, instance, path):\n        \"\"\"Create expected files in instance data\"\"\"\n\n        dir = os.path.dirname(path)\n        file = os.path.basename(path)\n\n        if \"#\" in file:\n            def replace(match):\n                return \"%0{}d\".format(len(match.group()))\n\n            file = re.sub(\"#+\", replace, file)\n\n        if \"%\" not in file:\n            return path\n\n        expected_files = []\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n\n        for i in range(int(start), (int(end) + 1)):\n            expected_files.append(\n                os.path.join(dir, (file % i)).replace(\"\\\\\", \"/\"))\n\n        return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_karma_rop.html#client.ayon_houdini.plugins.publish.collect_karma_rop.CollectKarmaROPRenderProducts.generate_expected_files","title":"<code>generate_expected_files(instance, path)</code>","text":"<p>Create expected files in instance data</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_karma_rop.py</code> <pre><code>def generate_expected_files(self, instance, path):\n    \"\"\"Create expected files in instance data\"\"\"\n\n    dir = os.path.dirname(path)\n    file = os.path.basename(path)\n\n    if \"#\" in file:\n        def replace(match):\n            return \"%0{}d\".format(len(match.group()))\n\n        file = re.sub(\"#+\", replace, file)\n\n    if \"%\" not in file:\n        return path\n\n    expected_files = []\n    start = instance.data[\"frameStartHandle\"]\n    end = instance.data[\"frameEndHandle\"]\n\n    for i in range(int(start), (int(end) + 1)):\n        expected_files.append(\n            os.path.join(dir, (file % i)).replace(\"\\\\\", \"/\"))\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_local_render_instances.html","title":"collect_local_render_instances","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_local_render_instances.html#client.ayon_houdini.plugins.publish.collect_local_render_instances.CollectLocalRenderInstances","title":"<code>CollectLocalRenderInstances</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>ColormanagedPyblishPluginMixin</code></p> <p>Collect instances for local render.</p> <p>Agnostic Local Render Collector.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_local_render_instances.py</code> <pre><code>class CollectLocalRenderInstances(plugin.HoudiniInstancePlugin,\n                                  ColormanagedPyblishPluginMixin):\n    \"\"\"Collect instances for local render.\n\n    Agnostic Local Render Collector.\n    \"\"\"\n\n    # this plugin runs after Collect Render Products\n    order = pyblish.api.CollectorOrder + 0.12\n    families = [\"mantra_rop\",\n                \"karma_rop\",\n                \"redshift_rop\",\n                \"arnold_rop\",\n                \"vray_rop\",\n                \"usdrender\"]\n\n    label = \"Collect local render instances\"\n\n    use_deadline_aov_filter = False\n    aov_filter = {\"host_name\": \"houdini\",\n                  \"value\": [\".*([Bb]eauty).*\"]}\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Preserve automatic settings applying logic\n        settings = get_plugin_settings(plugin=cls,\n                                       project_settings=project_settings,\n                                       log=cls.log,\n                                       category=\"houdini\")\n        apply_plugin_settings_automatically(cls, settings, logger=cls.log)\n\n        if not cls.use_deadline_aov_filter:\n            # get aov_filter from collector settings\n            # and restructure it as match_aov_pattern requires.\n            cls.aov_filter = {\n                cls.aov_filter[\"host_name\"]: cls.aov_filter[\"value\"]\n            }\n        else:\n            # get aov_filter from deadline settings\n            cls.aov_filter = (\n                project_settings\n                [\"deadline\"]\n                [\"publish\"]\n                [\"ProcessSubmittedJobOnFarm\"]\n                [\"aov_filter\"]\n            )\n            cls.aov_filter = {\n                item[\"name\"]: item[\"value\"]\n                for item in cls.aov_filter\n            }\n\n    def process(self, instance):\n\n        if instance.data[\"farm\"]:\n            self.log.debug(\"Render on farm is enabled. \"\n                           \"Skipping local render collecting.\")\n            return\n\n        if not instance.data.get(\"expectedFiles\"):\n            self.log.warning(\n                \"Missing collected expected files. \"\n                \"This may be due to misconfiguration of the ROP node, \"\n                \"like pointing to an invalid LOP or SOP path\")\n            return\n\n        # Create Instance for each AOV.\n        context = instance.context\n        expected_files = next(iter(instance.data[\"expectedFiles\"]), {})\n\n        product_type = \"render\"  # is always render\n\n        # NOTE: The assumption that the output image's colorspace is the\n        #   scene linear role may be incorrect. Certain renderers, like\n        #   Karma allow overriding explicitly the output colorspace of the\n        #   image. Such override are currently not considered since these\n        #   would need to be detected in a renderer-specific way and the\n        #   majority of production scenarios these would not be overridden.\n        # TODO: Support renderer-specific explicit colorspace overrides\n        colorspace = get_scene_linear_colorspace()\n\n        for aov_name, aov_filepaths in expected_files.items():\n            dynamic_data = {}\n            if aov_name:\n                dynamic_data[\"aov\"] = aov_name\n\n            if instance.data.get(\"renderlayer\"):\n                dynamic_data[\"renderlayer\"] = instance.data[\"renderlayer\"]\n\n            product_name, product_group = self._get_product_name_and_group(\n                instance,\n                product_type,\n                dynamic_data\n            )\n\n            # Create instance for each AOV\n            aov_instance = context.create_instance(product_name)\n\n            # Prepare Representation for each AOV\n            aov_filenames = [os.path.basename(path) for path in aov_filepaths]\n            staging_dir = os.path.dirname(aov_filepaths[0])\n            ext = aov_filepaths[0].split(\".\")[-1]\n\n            # Decide if instance is reviewable\n            if instance.data.get(\"multipartExr\", False):\n                # Add preview tag because its multipartExr.\n                preview = True\n            else:\n                # Add Preview tag if the AOV matches the filter.\n                preview = match_aov_pattern(\n                    \"houdini\", self.aov_filter, aov_filenames[0]\n                )\n\n            preview = preview and instance.data.get(\"review\", False)\n\n            # Support Single frame.\n            # The integrator wants single files to be a single\n            #  filename instead of a list.\n            # More info: https://github.com/ynput/ayon-core/issues/238\n            if len(aov_filenames) == 1:\n                aov_filenames = aov_filenames[0]\n\n            representation = {\n                \"stagingDir\": staging_dir,\n                \"ext\": ext,\n                \"name\": ext,\n                \"tags\": [\"review\"] if preview else [],\n                \"files\": aov_filenames,\n                \"frameStart\": instance.data[\"frameStartHandle\"],\n                \"frameEnd\": instance.data[\"frameEndHandle\"]\n            }\n\n            # Set the colorspace for the representation\n            self.set_representation_colorspace(representation,\n                                               context,\n                                               colorspace=colorspace)\n\n            aov_instance.data.update({\n                # 'label': label,\n                \"task\": instance.data[\"task\"],\n                \"folderPath\": instance.data[\"folderPath\"],\n                \"frameStartHandle\": instance.data[\"frameStartHandle\"],\n                \"frameEndHandle\": instance.data[\"frameEndHandle\"],\n                \"productType\": product_type,\n                \"family\": product_type,\n                \"productName\": product_name,\n                \"productGroup\": product_group,\n                \"families\": [\"render.local.hou\", \"review\"],\n                \"instance_node\": instance.data[\"instance_node\"],\n                # The following three items are necessary for\n                # `ExtractLastPublished`\n                \"publish_attributes\": instance.data[\"publish_attributes\"],\n                \"stagingDir\": staging_dir,\n                \"frames\": aov_filenames,\n                \"representations\": [representation]\n            })\n\n        # Skip integrating original render instance.\n        # We are not removing it because it's used to trigger the render.\n        instance.data[\"integrate\"] = False\n\n    def _get_product_name_and_group(\n        self, instance, product_type, dynamic_data\n    ):\n        \"\"\"Get product name and group\n\n        This method matches the logic in farm that gets\n         `product_name` and `group_name` respecting\n         `use_legacy_product_names_for_renders` logic in core settings.\n\n        Args:\n            instance (pyblish.api.Instance): The instance to publish.\n            product_type (str): Product type.\n            dynamic_data (dict): Dynamic data (camera, aov, ...)\n\n        Returns:\n            tuple (str, str): product name and group name\n\n        \"\"\"\n        project_settings = instance.context.data.get(\"project_settings\")\n\n        use_legacy_product_name = True\n        try:\n            use_legacy_product_name = (\n                project_settings\n                [\"core\"]\n                [\"tools\"]\n                [\"creator\"]\n                [\"use_legacy_product_names_for_renders\"]\n            )\n        except KeyError:\n            warnings.warn(\n                (\"use_legacy_for_renders not found in project settings. \"\n                 \"Using legacy product name for renders. Please update \"\n                 \"your ayon-core version.\"), DeprecationWarning)\n\n        if use_legacy_product_name:\n            return _get_legacy_product_name_and_group(\n                product_type=product_type,\n                source_product_name=instance.data[\"productName\"],\n                task_name=instance.data[\"task\"],\n                dynamic_data=dynamic_data\n            )\n\n        return get_product_name_and_group_from_template(\n            project_name=instance.context.data[\"projectName\"],\n            task_entity=instance.context.data[\"taskEntity\"],\n            host_name=instance.context.data[\"hostName\"],\n            product_type=product_type,\n            variant=instance.data[\"productName\"],\n            dynamic_data=dynamic_data\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_mantra_rop.html","title":"collect_mantra_rop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_mantra_rop.html#client.ayon_houdini.plugins.publish.collect_mantra_rop.CollectMantraROPRenderProducts","title":"<code>CollectMantraROPRenderProducts</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect Mantra Render Products</p> <p>Collects the instance.data[\"files\"] for the render products.</p> Provides <p>instance    -&gt; files</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_mantra_rop.py</code> <pre><code>class CollectMantraROPRenderProducts(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect Mantra Render Products\n\n    Collects the instance.data[\"files\"] for the render products.\n\n    Provides:\n        instance    -&gt; files\n\n    \"\"\"\n\n    label = \"Mantra ROP Render Products\"\n    # This specific order value is used so that\n    # this plugin runs after CollectFrames\n    order = pyblish.api.CollectorOrder + 0.11\n    families = [\"mantra_rop\"]\n\n    def process(self, instance):\n\n        rop = hou.node(instance.data.get(\"instance_node\"))\n\n        default_prefix = evalParmNoFrame(rop, \"vm_picture\")\n        render_products = []\n\n        export_prefix = None\n        export_products = []\n        if instance.data[\"splitRender\"]:\n            export_prefix = evalParmNoFrame(\n                rop, \"soho_diskfile\", pad_character=\"0\"\n            )\n            beauty_export_product = self.get_render_product_name(\n                prefix=export_prefix,\n                suffix=None)\n            export_products.append(beauty_export_product)\n            self.log.debug(\n                \"Found export product: {}\".format(beauty_export_product)\n            )\n            instance.data[\"ifdFile\"] = beauty_export_product\n            instance.data[\"exportFiles\"] = list(export_products)\n\n        # Default beauty AOV\n        beauty_product = self.get_render_product_name(\n            prefix=default_prefix, suffix=None\n        )\n        render_products.append(beauty_product)\n\n        files_by_aov = {\n            \"beauty\": self.generate_expected_files(instance,\n                                                   beauty_product)\n        }\n\n        # Assume it's a multipartExr Render.\n        multipartExr = True\n\n        # TODO: This logic doesn't take into considerations\n        #       cryptomatte defined in 'Images &gt; Cryptomatte'\n        aov_numbers = rop.evalParm(\"vm_numaux\")\n        if aov_numbers &gt; 0:\n            # get the filenames of the AOVs\n            for i in range(1, aov_numbers + 1):\n                var = rop.evalParm(\"vm_variable_plane%d\" % i)\n                if var:\n                    aov_name = \"vm_filename_plane%d\" % i\n                    aov_boolean = \"vm_usefile_plane%d\" % i\n                    aov_enabled = rop.evalParm(aov_boolean)\n                    has_aov_path = rop.evalParm(aov_name)\n                    if has_aov_path and aov_enabled == 1:\n                        aov_prefix = evalParmNoFrame(rop, aov_name)\n                        aov_product = self.get_render_product_name(\n                            prefix=aov_prefix, suffix=None\n                        )\n                        render_products.append(aov_product)\n\n                        files_by_aov[var] = self.generate_expected_files(instance, aov_product)     # noqa\n\n                        # Set to False as soon as we have a separated aov.\n                        multipartExr = False\n\n        # Review Logic expects this key to exist and be True\n        # if render is a multipart Exr.\n        # As long as we have one AOV then multipartExr should be True.\n        instance.data[\"multipartExr\"] = multipartExr\n\n        for product in render_products:\n            self.log.debug(\"Found render product: %s\" % product)\n\n        filenames = list(render_products)\n        instance.data[\"files\"] = filenames\n\n        # For now by default do NOT try to publish the rendered output\n        instance.data[\"publishJobState\"] = \"Suspended\"\n        instance.data[\"attachTo\"] = []      # stub required data\n\n        if \"expectedFiles\" not in instance.data:\n            instance.data[\"expectedFiles\"] = list()\n        instance.data[\"expectedFiles\"].append(files_by_aov)\n\n    def get_render_product_name(self, prefix, suffix):\n        product_name = prefix\n        if suffix:\n            # Add \".{suffix}\" before the extension\n            prefix_base, ext = os.path.splitext(prefix)\n            product_name = prefix_base + \".\" + suffix + ext\n\n        return product_name\n\n    def generate_expected_files(self, instance, path):\n        \"\"\"Create expected files in instance data\"\"\"\n\n        dir = os.path.dirname(path)\n        file = os.path.basename(path)\n\n        if \"#\" in file:\n            def replace(match):\n                return \"%0{}d\".format(len(match.group()))\n\n            file = re.sub(\"#+\", replace, file)\n\n        if \"%\" not in file:\n            return path\n\n        expected_files = []\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n\n        for i in range(int(start), (int(end) + 1)):\n            expected_files.append(\n                os.path.join(dir, (file % i)).replace(\"\\\\\", \"/\"))\n\n        return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_mantra_rop.html#client.ayon_houdini.plugins.publish.collect_mantra_rop.CollectMantraROPRenderProducts.generate_expected_files","title":"<code>generate_expected_files(instance, path)</code>","text":"<p>Create expected files in instance data</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_mantra_rop.py</code> <pre><code>def generate_expected_files(self, instance, path):\n    \"\"\"Create expected files in instance data\"\"\"\n\n    dir = os.path.dirname(path)\n    file = os.path.basename(path)\n\n    if \"#\" in file:\n        def replace(match):\n            return \"%0{}d\".format(len(match.group()))\n\n        file = re.sub(\"#+\", replace, file)\n\n    if \"%\" not in file:\n        return path\n\n    expected_files = []\n    start = instance.data[\"frameStartHandle\"]\n    end = instance.data[\"frameEndHandle\"]\n\n    for i in range(int(start), (int(end) + 1)):\n        expected_files.append(\n            os.path.join(dir, (file % i)).replace(\"\\\\\", \"/\"))\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_output_node.html","title":"collect_output_node","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_output_node.html#client.ayon_houdini.plugins.publish.collect_output_node.CollectOutputSOPPath","title":"<code>CollectOutputSOPPath</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect the out node's SOP/COP Path value.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_output_node.py</code> <pre><code>class CollectOutputSOPPath(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect the out node's SOP/COP Path value.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.45\n    families = [\n        \"pointcache\",\n        \"camera\",\n        \"vdbcache\",\n        \"imagesequence\",\n        \"redshiftproxy\",\n        \"staticMesh\",\n        \"model\",\n        \"usdrender\",\n        \"usdrop\"\n    ]\n\n    label = \"Collect Output Node Path\"\n\n    def process(self, instance):\n\n        import hou\n\n        node = hou.node(instance.data[\"instance_node\"])\n\n        # Get sop path\n        node_type = node.type().name()\n        if node_type == \"geometry\":\n            out_node = node.parm(\"soppath\").evalAsNode()\n\n        elif node_type == \"alembic\":\n\n            # Alembic can switch between using SOP Path or object\n            if node.parm(\"use_sop_path\").eval():\n                out_node = node.parm(\"sop_path\").evalAsNode()\n            else:\n                root = node.parm(\"root\").eval()\n                objects = node.parm(\"objects\").eval()\n                path = root + \"/\" + objects\n                out_node = hou.node(path)\n\n        elif node_type == \"comp\":\n            out_node = node.parm(\"coppath\").evalAsNode()\n\n        elif node_type == \"usd\" or node_type == \"usdrender\":\n            out_node = node.parm(\"loppath\").evalAsNode()\n\n        elif node_type == \"usd_rop\" or node_type == \"usdrender_rop\":\n            # Inside Solaris e.g. /stage (not in ROP context)\n            # When incoming connection is present it takes it directly\n            inputs = node.inputs()\n            if inputs:\n                out_node = inputs[0]\n            else:\n                out_node = node.parm(\"loppath\").evalAsNode()\n\n        elif node_type == \"Redshift_Proxy_Output\":\n            out_node = node.parm(\"RS_archive_sopPath\").evalAsNode()\n\n        elif node_type == \"filmboxfbx\":\n            out_node = node.parm(\"startnode\").evalAsNode()\n\n        else:\n            raise KnownPublishError(\n                f\"ROP node type '{node_type}' is not supported\"\n                f\" for product type '{instance.data['product_type']}'\"\n            )\n\n        if not out_node:\n            self.log.warning(\"No output node collected.\")\n            return\n\n        self.log.debug(\"Output node: %s\" % out_node.path())\n        instance.data[\"output_node\"] = out_node\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_redshift_rop.html","title":"collect_redshift_rop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_redshift_rop.html#client.ayon_houdini.plugins.publish.collect_redshift_rop.CollectRedshiftROPRenderProducts","title":"<code>CollectRedshiftROPRenderProducts</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect USD Render Products</p> <p>Collects the instance.data[\"files\"] for the render products.</p> Provides <p>instance    -&gt; files</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_redshift_rop.py</code> <pre><code>class CollectRedshiftROPRenderProducts(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect USD Render Products\n\n    Collects the instance.data[\"files\"] for the render products.\n\n    Provides:\n        instance    -&gt; files\n\n    \"\"\"\n\n    label = \"Redshift ROP Render Products\"\n    # This specific order value is used so that\n    # this plugin runs after CollectFrames\n    order = pyblish.api.CollectorOrder + 0.11\n    families = [\"redshift_rop\"]\n\n    def process(self, instance):\n        rop = hou.node(instance.data.get(\"instance_node\"))\n\n        default_prefix = evalParmNoFrame(rop, \"RS_outputFileNamePrefix\")\n        beauty_suffix = rop.evalParm(\"RS_outputBeautyAOVSuffix\")\n\n        export_products = []\n        if instance.data[\"splitRender\"]:\n            export_prefix = evalParmNoFrame(\n                rop, \"RS_archive_file\", pad_character=\"0\"\n            )\n            beauty_export_product = self.get_render_product_name(\n                prefix=export_prefix,\n                suffix=None)\n            export_products.append(beauty_export_product)\n            self.log.debug(\n                \"Found export product: {}\".format(beauty_export_product)\n            )\n            instance.data[\"ifdFile\"] = beauty_export_product\n            instance.data[\"exportFiles\"] = list(export_products)\n\n        full_exr_mode = (rop.evalParm(\"RS_outputMultilayerMode\") == \"2\")\n        if full_exr_mode:\n            # Ignore beauty suffix if full mode is enabled\n            # As this is what the rop does.\n            beauty_suffix = \"\"\n\n        # Assume it's a multipartExr Render.\n        multipartExr = True\n\n        # Default beauty/main layer AOV\n        beauty_product = self.get_render_product_name(\n            prefix=default_prefix, suffix=beauty_suffix\n        )\n        render_products = [beauty_product]\n        files_by_aov = {\n            beauty_suffix: self.generate_expected_files(\n                instance,\n                beauty_product\n            )\n        }\n\n        aovs_rop = rop.parm(\"RS_aovGetFromNode\").evalAsNode()\n        if aovs_rop:\n            rop = aovs_rop\n\n        num_aovs = 0\n        if not rop.evalParm('RS_aovAllAOVsDisabled'):\n            num_aovs = rop.evalParm(\"RS_aov\")\n\n        for index in range(num_aovs):\n            i = index + 1\n\n            # Skip disabled AOVs\n            if not rop.evalParm(f\"RS_aovEnable_{i}\"):\n                continue\n\n            aov_suffix = rop.evalParm(f\"RS_aovSuffix_{i}\")\n            aov_prefix = evalParmNoFrame(rop, f\"RS_aovCustomPrefix_{i}\")\n            if not aov_prefix:\n                aov_prefix = default_prefix\n\n            if rop.parm(f\"RS_aovID_{i}\").evalAsString() == \"CRYPTOMATTE\" or \\\n                  not full_exr_mode:\n\n                aov_product = self.get_render_product_name(\n                    aov_prefix, aov_suffix\n                )\n                render_products.append(aov_product)\n\n                files_by_aov[aov_suffix] = self.generate_expected_files(\n                    instance,\n                    aov_product\n                )\n\n                # Set to False as soon as we have a separated aov.\n                multipartExr = False\n\n        # Review Logic expects this key to exist and be True\n        # if render is a multipart Exr.\n        # As long as we have one AOV then multipartExr should be True.\n        instance.data[\"multipartExr\"] = multipartExr\n\n        for product in render_products:\n            self.log.debug(\"Found render product: %s\" % product)\n\n        filenames = list(render_products)\n        instance.data[\"files\"] = filenames\n\n        # For now by default do NOT try to publish the rendered output\n        instance.data[\"publishJobState\"] = \"Suspended\"\n        instance.data[\"attachTo\"] = []      # stub required data\n\n        if \"expectedFiles\" not in instance.data:\n            instance.data[\"expectedFiles\"] = []\n        instance.data[\"expectedFiles\"].append(files_by_aov)\n\n    def get_render_product_name(self, prefix, suffix):\n        \"\"\"Return the output filename using the AOV prefix and suffix\"\"\"\n\n        # When AOV is explicitly defined in prefix we just swap it out\n        # directly with the AOV suffix to embed it.\n        # Note: '$AOV' seems to be evaluated in the parameter as '%AOV%'\n        has_aov_in_prefix = \"%AOV%\" in prefix\n        if has_aov_in_prefix:\n            # It seems that when some special separator characters are present\n            # before the %AOV% token that Redshift will secretly remove it if\n            # there is no suffix for the current product, for example:\n            # foo_%AOV% -&gt; foo.exr\n            pattern = \"%AOV%\" if suffix else \"[._-]?%AOV%\"\n            product_name = re.sub(pattern, suffix, prefix, flags=re.IGNORECASE)\n        else:\n            if suffix:\n                # Add \".{suffix}\" before the extension\n                prefix_base, ext = os.path.splitext(prefix)\n                product_name = prefix_base + \".\" + suffix + ext\n            else:\n                product_name = prefix\n\n        return product_name\n\n    def generate_expected_files(self, instance, path):\n        \"\"\"Create expected files in instance data\"\"\"\n\n        dir = os.path.dirname(path)\n        file = os.path.basename(path)\n\n        if \"#\" in file:\n            def replace(match):\n                return \"%0{}d\".format(len(match.group()))\n\n            file = re.sub(\"#+\", replace, file)\n\n        if \"%\" not in file:\n            return path\n\n        expected_files = []\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n\n        for i in range(int(start), (int(end) + 1)):\n            expected_files.append(\n                os.path.join(dir, (file % i)).replace(\"\\\\\", \"/\"))\n\n        return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_redshift_rop.html#client.ayon_houdini.plugins.publish.collect_redshift_rop.CollectRedshiftROPRenderProducts.generate_expected_files","title":"<code>generate_expected_files(instance, path)</code>","text":"<p>Create expected files in instance data</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_redshift_rop.py</code> <pre><code>def generate_expected_files(self, instance, path):\n    \"\"\"Create expected files in instance data\"\"\"\n\n    dir = os.path.dirname(path)\n    file = os.path.basename(path)\n\n    if \"#\" in file:\n        def replace(match):\n            return \"%0{}d\".format(len(match.group()))\n\n        file = re.sub(\"#+\", replace, file)\n\n    if \"%\" not in file:\n        return path\n\n    expected_files = []\n    start = instance.data[\"frameStartHandle\"]\n    end = instance.data[\"frameEndHandle\"]\n\n    for i in range(int(start), (int(end) + 1)):\n        expected_files.append(\n            os.path.join(dir, (file % i)).replace(\"\\\\\", \"/\"))\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_redshift_rop.html#client.ayon_houdini.plugins.publish.collect_redshift_rop.CollectRedshiftROPRenderProducts.get_render_product_name","title":"<code>get_render_product_name(prefix, suffix)</code>","text":"<p>Return the output filename using the AOV prefix and suffix</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_redshift_rop.py</code> <pre><code>def get_render_product_name(self, prefix, suffix):\n    \"\"\"Return the output filename using the AOV prefix and suffix\"\"\"\n\n    # When AOV is explicitly defined in prefix we just swap it out\n    # directly with the AOV suffix to embed it.\n    # Note: '$AOV' seems to be evaluated in the parameter as '%AOV%'\n    has_aov_in_prefix = \"%AOV%\" in prefix\n    if has_aov_in_prefix:\n        # It seems that when some special separator characters are present\n        # before the %AOV% token that Redshift will secretly remove it if\n        # there is no suffix for the current product, for example:\n        # foo_%AOV% -&gt; foo.exr\n        pattern = \"%AOV%\" if suffix else \"[._-]?%AOV%\"\n        product_name = re.sub(pattern, suffix, prefix, flags=re.IGNORECASE)\n    else:\n        if suffix:\n            # Add \".{suffix}\" before the extension\n            prefix_base, ext = os.path.splitext(prefix)\n            product_name = prefix_base + \".\" + suffix + ext\n        else:\n            product_name = prefix\n\n    return product_name\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_render_colorspace.html","title":"collect_render_colorspace","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_render_colorspace.html#client.ayon_houdini.plugins.publish.collect_render_colorspace.CollectHoudiniRenderColorspace","title":"<code>CollectHoudiniRenderColorspace</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect Colorspace data for render output images.</p> <p>This currently assumes that all render products are in 'scene_linear' colorspace role - which is the default behavior for renderers in Houdini.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_render_colorspace.py</code> <pre><code>class CollectHoudiniRenderColorspace(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect Colorspace data for render output images.\n\n    This currently assumes that all render products are in 'scene_linear'\n    colorspace role - which is the default behavior for renderers in Houdini.\n    \"\"\"\n\n    label = \"Collect Render Colorspace\"\n    order = pyblish.api.CollectorOrder + 0.15\n    families = [\"mantra_rop\",\n                \"karma_rop\",\n                \"redshift_rop\",\n                \"arnold_rop\",\n                \"vray_rop\",\n                \"usdrender\"]\n\n    def process(self, instance):\n        # Set the required data for `ayon_core.pipeline.farm.pyblish_functions`\n        # functions used for farm publish job processing.\n\n        # Define render products for `create_instances_for_aov`\n        # which uses it in `_create_instances_for_aov()` to match the render\n        # product's name to aovs to define the colorspace.\n        expected_files = instance.data.get(\"expectedFiles\")\n        if not expected_files:\n            self.log.debug(\"No expected files found. \"\n                           \"Skipping collecting of render colorspace.\")\n            return\n        aov_name = list(expected_files[0].keys())\n        render_products_data = colorspace.ARenderProduct(aov_name)\n        instance.data[\"renderProducts\"] = render_products_data\n\n        # Required data for `create_instances_for_aov`\n        colorspace_data = colorspace.get_color_management_preferences()\n        instance.data[\"colorspaceConfig\"] = colorspace_data[\"config\"]\n        instance.data[\"colorspaceDisplay\"] = colorspace_data[\"display\"]\n        instance.data[\"colorspaceView\"] = colorspace_data[\"view\"]\n\n        # Used in `create_skeleton_instance()`\n        instance.data[\"colorspace\"] = colorspace.get_scene_linear_colorspace()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_render_products.html","title":"collect_render_products","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_render_products.html#client.ayon_houdini.plugins.publish.collect_render_products.CollectRenderProducts","title":"<code>CollectRenderProducts</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect USD Render Products.</p> <p>The render products are collected from the USD Render ROP node by detecting what the selected Render Settings prim path is, then finding those Render Settings in the USD Stage and collecting the targeted Render Products and their expected filenames.</p> <p>Note: Product refers USD Render Product, not to an AYON Product</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_render_products.py</code> <pre><code>class CollectRenderProducts(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect USD Render Products.\n\n    The render products are collected from the USD Render ROP node by detecting\n    what the selected Render Settings prim path is, then finding those\n    Render Settings in the USD Stage and collecting the targeted Render\n    Products and their expected filenames.\n\n    Note: Product refers USD Render Product, not to an AYON Product\n\n    \"\"\"\n\n    label = \"Collect Render Products\"\n    # This plugin should run after CollectUsdRender\n    #   and, before CollectLocalRenderInstances\n    order = pyblish.api.CollectorOrder + 0.04\n    families = [\"usdrender\"]\n\n    def process(self, instance):\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        node = instance.data.get(\"output_node\")\n        if not node:\n            rop_path = rop_node.path()\n            self.log.error(\n                \"No output node found. Make sure to connect a valid \"\n                \"input to the USD ROP: %s\" % rop_path\n            )\n            return\n\n        override_output_image = rop_node.evalParm(\"outputimage\")\n\n        filenames = []\n        files_by_product = {}\n        stage = instance.data[\"stage\"]\n        for prim_path in self.get_render_products(rop_node, stage):\n            prim = stage.GetPrimAtPath(prim_path)\n            if not prim or not prim.IsA(pxr.UsdRender.Product):\n                self.log.warning(\"Found invalid render product path \"\n                                 \"configured in render settings that is not a \"\n                                 \"Render Product prim: %s\", prim_path)\n                continue\n\n            render_product = pxr.UsdRender.Product(prim)\n            # Get Render Product Name\n            if override_output_image:\n                name = override_output_image\n            else:\n                # We force taking it from any random time sample as opposed to\n                # \"default\" that the USD Api falls back to since that won't\n                # return time sampled values if they were set per time sample.\n                name = render_product.GetProductNameAttr().Get(time=0)\n\n            dirname = os.path.dirname(name)\n            basename = os.path.basename(name)\n\n            dollarf_regex = r\"(\\$F([0-9]?))\"\n            if re.match(dollarf_regex, basename):\n                # TODO: Confirm this actually is allowed USD stages and HUSK\n                # Substitute $F\n                def replace(match):\n                    \"\"\"Replace $F4 with padded #.\"\"\"\n                    padding = int(match.group(2)) if match.group(2) else 1\n                    return \"#\" * padding\n\n                filename_base = re.sub(dollarf_regex, replace, basename)\n                filename = os.path.join(dirname, filename_base)\n            else:\n                # Last group of digits in the filename before the extension\n                # The frame number must always be prefixed by underscore or dot\n                # Allow product names like:\n                #   - filename.1001.exr\n                #   - filename.1001.aov.exr\n                #   - filename.aov.1001.exr\n                #   - filename_1001.exr\n                frame_regex = r\"(.*[._])(\\d+)(?!.*\\d)(.*\\.[A-Za-z0-9]+$)\"\n\n                # It may be the case that the current USD stage has stored\n                # product name samples (e.g. when loading a USD file with\n                # time samples) where it does not refer to e.g. $F4. And thus\n                # it refers to the actual path like /path/to/frame.1001.exr\n                # TODO: It would be better to maybe sample product name\n                #  attribute `ValueMightBeTimeVarying` and if so get it per\n                #  frame using `attr.Get(time=frame)` to ensure we get the\n                #  actual product name set at that point in time?\n                # Substitute basename.0001.ext\n                def replace(match):\n                    head, frame, tail = match.groups()\n                    padding = \"#\" * len(frame)\n                    return head + padding + tail\n\n                filename_base = re.sub(frame_regex, replace, basename)\n                filename = os.path.join(dirname, filename_base)\n                filename = filename.replace(\"\\\\\", \"/\")\n\n                if \"#\" not in filename:\n                    raise PublishError(\n                        \"Couldn't resolve render product output file\"\n                        f\" '{name}' with frame number.\"\n                    )\n\n            filenames.append(filename)\n\n            # TODO: Improve AOV name detection logic\n            aov_identifier = self.get_aov_identifier(render_product)\n            if aov_identifier in files_by_product:\n                self.log.error(\n                    \"Multiple render products are identified as the same AOV \"\n                    \"which means one of the two will not be ingested during\"\n                    \"publishing. AOV: '%s'\", aov_identifier\n                )\n                self.log.warning(\"Skipping Render Product: %s\", render_product)\n\n            files_by_product[aov_identifier] = self.generate_expected_files(\n                instance,\n                filename\n            )\n\n            aov_label = f\"'{aov_identifier}' aov in \" if aov_identifier else \"\"\n            self.log.debug(\"Render Product %s%s\", aov_label, prim_path)\n            self.log.debug(\"Product name: %s\", filename)\n\n        # Filenames for Deadline\n        instance.data[\"files\"] = filenames\n        instance.data.setdefault(\"expectedFiles\", []).append(files_by_product)\n\n        # Farm Publishing add review logic expects this key to exist and\n        #   be True if render is a multipart Exr.\n        # otherwise it will most probably fail the AOV filter as multipartExr\n        #   files mostly don't include aov name in the file path.\n        # Assume multipartExr is 'True' as long as we have one AOV.\n        instance.data[\"multipartExr\"] = len(files_by_product) &lt;= 1\n\n    def get_aov_identifier(self, render_product):\n        \"\"\"Return the AOV identifier for a Render Product\n\n        A Render Product does not really define what 'AOV' it is, it\n        defines the product name (output path) and the render vars to\n        include.\n\n        So we need to define what in particular of a `UsdRenderProduct`\n        we use to separate the AOV (and thus apply sub-grouping with).\n\n        For now we'll consider any Render Product that only refers\n        to a single rendervar that the rendervars prim name is the AOV\n        otherwise we'll assume renderproduct to be a combined multilayer\n        'main' layer\n\n        Args:\n            render_product (pxr.UsdRender.Product): The Render Product\n\n        Returns:\n            str: The AOV identifier\n\n        \"\"\"\n        # Allow explicit naming through custom attribute on the render product\n        attr = render_product.GetPrim().GetAttribute(\"ayon:aov_identifier\")\n        if attr:\n            aov_identifier = attr.Get(time=Usd.TimeCode.EarliestTime())\n            self.log.debug(\n                \"Using explicit ayon:aov_identifier on render product\"\n                f\" '{render_product.GetPath()}': '{aov_identifier}'\")\n            return str(aov_identifier)\n\n        targets = render_product.GetOrderedVarsRel().GetTargets()\n        if len(targets) &gt; 1:\n            # Cryptomattes usually are combined render vars, for example:\n            # - crypto_asset, crypto_asset01, crypto_asset02, crypto_asset03\n            # - crypto_object, crypto_object01, etc.\n            # These still refer to the same AOV so we take the common prefix\n            # e.g. `crypto_asset` or `crypto` (if multiple are combined)\n            if all(target.name.startswith(\"crypto\") for target in targets):\n                start = os.path.commonpath([target.name for target in targets])\n                return start.rstrip(\"_\")  # remove any trailing _\n\n            # Main layer\n            return \"\"\n        elif len(targets) == 1:\n            # AOV for a single var\n            return targets[0].name\n        else:\n            self.log.warning(\n                f\"Render product has no rendervars set: {render_product}\")\n            return \"\"\n\n    def get_render_products(self, usdrender_rop, stage):\n        \"\"\"\"The render products in the defined render settings\n\n        Args:\n            usdrender_rop (hou.Node): The Houdini USD Render ROP node.\n            stage (pxr.Usd.Stage): The USD stage to find the render settings\n                 in. This is usually the stage from the LOP path the USD Render\n                 ROP node refers to.\n\n        Returns:\n            List[Sdf.Path]: Render Product paths enabled in the render settings\n\n        \"\"\"\n        render_settings = get_usd_render_rop_rendersettings(usdrender_rop,\n                                                            stage,\n                                                            logger=self.log)\n        if not render_settings:\n            return []\n\n        return render_settings.GetProductsRel().GetTargets()\n\n    def generate_expected_files(self, instance, path):\n        \"\"\"Generate full sequence of expected files from a filepath.\n\n        The filepath should have '#' token as placeholder for frame numbers or\n        should have %04d or %d placeholders. The `#` characters indicate frame\n        number and padding, e.g. #### becomes 0001 for frame 1.\n\n        Args:\n            instance (pyblish.api.Instance): The publish instance.\n            path (str): The filepath to generate the list of output files for.\n\n        Returns:\n            list: Filepath per frame.\n\n        \"\"\"\n\n        folder = os.path.dirname(path)\n        filename = os.path.basename(path)\n\n        if \"#\" in filename:\n            def replace(match):\n                return \"%0{}d\".format(len(match.group()))\n\n            filename = re.sub(\"#+\", replace, filename)\n\n        if \"%\" not in filename:\n            # Not a sequence, single file\n            return path\n\n        expected_files = []\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n\n        for frame in range(int(start), (int(end) + 1)):\n            expected_files.append(\n                os.path.join(folder, (filename % frame)).replace(\"\\\\\", \"/\"))\n\n        return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_render_products.html#client.ayon_houdini.plugins.publish.collect_render_products.CollectRenderProducts.generate_expected_files","title":"<code>generate_expected_files(instance, path)</code>","text":"<p>Generate full sequence of expected files from a filepath.</p> <p>The filepath should have '#' token as placeholder for frame numbers or should have %04d or %d placeholders. The <code>#</code> characters indicate frame number and padding, e.g. #### becomes 0001 for frame 1.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The publish instance.</p> required <code>path</code> <code>str</code> <p>The filepath to generate the list of output files for.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Filepath per frame.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_render_products.py</code> <pre><code>def generate_expected_files(self, instance, path):\n    \"\"\"Generate full sequence of expected files from a filepath.\n\n    The filepath should have '#' token as placeholder for frame numbers or\n    should have %04d or %d placeholders. The `#` characters indicate frame\n    number and padding, e.g. #### becomes 0001 for frame 1.\n\n    Args:\n        instance (pyblish.api.Instance): The publish instance.\n        path (str): The filepath to generate the list of output files for.\n\n    Returns:\n        list: Filepath per frame.\n\n    \"\"\"\n\n    folder = os.path.dirname(path)\n    filename = os.path.basename(path)\n\n    if \"#\" in filename:\n        def replace(match):\n            return \"%0{}d\".format(len(match.group()))\n\n        filename = re.sub(\"#+\", replace, filename)\n\n    if \"%\" not in filename:\n        # Not a sequence, single file\n        return path\n\n    expected_files = []\n    start = instance.data[\"frameStartHandle\"]\n    end = instance.data[\"frameEndHandle\"]\n\n    for frame in range(int(start), (int(end) + 1)):\n        expected_files.append(\n            os.path.join(folder, (filename % frame)).replace(\"\\\\\", \"/\"))\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_render_products.html#client.ayon_houdini.plugins.publish.collect_render_products.CollectRenderProducts.get_aov_identifier","title":"<code>get_aov_identifier(render_product)</code>","text":"<p>Return the AOV identifier for a Render Product</p> <p>A Render Product does not really define what 'AOV' it is, it defines the product name (output path) and the render vars to include.</p> <p>So we need to define what in particular of a <code>UsdRenderProduct</code> we use to separate the AOV (and thus apply sub-grouping with).</p> <p>For now we'll consider any Render Product that only refers to a single rendervar that the rendervars prim name is the AOV otherwise we'll assume renderproduct to be a combined multilayer 'main' layer</p> <p>Parameters:</p> Name Type Description Default <code>render_product</code> <code>Product</code> <p>The Render Product</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The AOV identifier</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_render_products.py</code> <pre><code>def get_aov_identifier(self, render_product):\n    \"\"\"Return the AOV identifier for a Render Product\n\n    A Render Product does not really define what 'AOV' it is, it\n    defines the product name (output path) and the render vars to\n    include.\n\n    So we need to define what in particular of a `UsdRenderProduct`\n    we use to separate the AOV (and thus apply sub-grouping with).\n\n    For now we'll consider any Render Product that only refers\n    to a single rendervar that the rendervars prim name is the AOV\n    otherwise we'll assume renderproduct to be a combined multilayer\n    'main' layer\n\n    Args:\n        render_product (pxr.UsdRender.Product): The Render Product\n\n    Returns:\n        str: The AOV identifier\n\n    \"\"\"\n    # Allow explicit naming through custom attribute on the render product\n    attr = render_product.GetPrim().GetAttribute(\"ayon:aov_identifier\")\n    if attr:\n        aov_identifier = attr.Get(time=Usd.TimeCode.EarliestTime())\n        self.log.debug(\n            \"Using explicit ayon:aov_identifier on render product\"\n            f\" '{render_product.GetPath()}': '{aov_identifier}'\")\n        return str(aov_identifier)\n\n    targets = render_product.GetOrderedVarsRel().GetTargets()\n    if len(targets) &gt; 1:\n        # Cryptomattes usually are combined render vars, for example:\n        # - crypto_asset, crypto_asset01, crypto_asset02, crypto_asset03\n        # - crypto_object, crypto_object01, etc.\n        # These still refer to the same AOV so we take the common prefix\n        # e.g. `crypto_asset` or `crypto` (if multiple are combined)\n        if all(target.name.startswith(\"crypto\") for target in targets):\n            start = os.path.commonpath([target.name for target in targets])\n            return start.rstrip(\"_\")  # remove any trailing _\n\n        # Main layer\n        return \"\"\n    elif len(targets) == 1:\n        # AOV for a single var\n        return targets[0].name\n    else:\n        self.log.warning(\n            f\"Render product has no rendervars set: {render_product}\")\n        return \"\"\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_render_products.html#client.ayon_houdini.plugins.publish.collect_render_products.CollectRenderProducts.get_render_products","title":"<code>get_render_products(usdrender_rop, stage)</code>","text":"<p>\"The render products in the defined render settings</p> <p>Parameters:</p> Name Type Description Default <code>usdrender_rop</code> <code>Node</code> <p>The Houdini USD Render ROP node.</p> required <code>stage</code> <code>Stage</code> <p>The USD stage to find the render settings  in. This is usually the stage from the LOP path the USD Render  ROP node refers to.</p> required <p>Returns:</p> Type Description <p>List[Sdf.Path]: Render Product paths enabled in the render settings</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_render_products.py</code> <pre><code>def get_render_products(self, usdrender_rop, stage):\n    \"\"\"\"The render products in the defined render settings\n\n    Args:\n        usdrender_rop (hou.Node): The Houdini USD Render ROP node.\n        stage (pxr.Usd.Stage): The USD stage to find the render settings\n             in. This is usually the stage from the LOP path the USD Render\n             ROP node refers to.\n\n    Returns:\n        List[Sdf.Path]: Render Product paths enabled in the render settings\n\n    \"\"\"\n    render_settings = get_usd_render_rop_rendersettings(usdrender_rop,\n                                                        stage,\n                                                        logger=self.log)\n    if not render_settings:\n        return []\n\n    return render_settings.GetProductsRel().GetTargets()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_renderlayer.html","title":"collect_renderlayer","text":"<p>Collect Render layer name from ROP.</p> <p>This simple collector will take name of the ROP node and set it as the render layer name for the instance.</p> <p>This aligns with the behavior of Maya and possibly others, even though there is nothing like render layer explicitly in Houdini.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_review_data.html","title":"collect_review_data","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_review_data.html#client.ayon_houdini.plugins.publish.collect_review_data.CollectHoudiniReviewData","title":"<code>CollectHoudiniReviewData</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect Review Data.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_review_data.py</code> <pre><code>class CollectHoudiniReviewData(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect Review Data.\"\"\"\n\n    label = \"Collect Review Data\"\n    # This specific order value is used so that\n    # this plugin runs after CollectRopFrameRange\n    # Also after CollectLocalRenderInstances\n    order = pyblish.api.CollectorOrder + 0.13\n    families = [\"review\"]\n\n    def process(self, instance):\n\n        # This fixes the burnin having the incorrect start/end timestamps\n        # because without this it would take it from the context instead\n        # which isn't the actual frame range that this instance renders.\n        instance.data[\"handleStart\"] = 0\n        instance.data[\"handleEnd\"] = 0\n        instance.data[\"fps\"] = instance.context.data[\"fps\"]\n\n        # Get the camera from the rop node to collect the focal length\n        ropnode_path = instance.data[\"instance_node\"]\n        ropnode = hou.node(ropnode_path)\n\n        # Get camera based on the instance_node type.\n        camera_path = self._get_camera_path(ropnode)\n        camera_node = hou.node(camera_path)\n        if not camera_node:\n            self.log.warning(\"No valid camera node found on review node: \"\n                             \"{}\".format(camera_path))\n            return\n\n        # Collect focal length.\n        focal_length_parm = camera_node.parm(\"focal\")\n        if not focal_length_parm:\n            self.log.warning(\"No 'focal' (focal length) parameter found on \"\n                             \"camera: {}\".format(camera_path))\n            return\n\n        if focal_length_parm.isTimeDependent():\n            start = instance.data[\"frameStartHandle\"]\n            end = instance.data[\"frameEndHandle\"] + 1\n            focal_length = [\n                focal_length_parm.evalAsFloatAtFrame(t)\n                for t in range(int(start), int(end))\n            ]\n        else:\n            focal_length = focal_length_parm.evalAsFloat()\n\n        # Store focal length in `burninDataMembers`\n        burnin_members = instance.data.setdefault(\"burninDataMembers\", {})\n        burnin_members[\"focalLength\"] = focal_length\n\n    def _get_camera_path(self, ropnode):\n        \"\"\"Get the camera path associated with the given rop node.\n\n        This function evaluates the camera parameter according to the\n        type of the given rop node.\n\n        Returns:\n            Union[str, None]: Camera path or None.\n\n            This function can return empty string if the camera\n            path is empty i.e. no camera path.\n        \"\"\"\n\n        if ropnode.type().name() in {\n            \"opengl\", \"karma\", \"ifd\", \"arnold\", \"flipbook\"\n        }:\n            return ropnode.parm(\"camera\").eval()\n\n        elif ropnode.type().name() == \"Redshift_ROP\":\n            return ropnode.parm(\"RS_renderCamera\").eval()\n\n        elif ropnode.type().name() == \"vray_renderer\":\n            return ropnode.parm(\"render_camera\").eval()\n\n        return None\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_reviewable_instances.html","title":"collect_reviewable_instances","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_reviewable_instances.html#client.ayon_houdini.plugins.publish.collect_reviewable_instances.CollectReviewableInstances","title":"<code>CollectReviewableInstances</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect Reviewable Instances.</p> <p>Basically, all instances of the specified families   with creator_attribure[\"review\"]</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_reviewable_instances.py</code> <pre><code>class CollectReviewableInstances(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect Reviewable Instances.\n\n    Basically, all instances of the specified families\n      with creator_attribure[\"review\"]\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder\n    label = \"Collect Reviewable Instances\"\n    families = [\"mantra_rop\",\n                \"karma_rop\",\n                \"redshift_rop\",\n                \"arnold_rop\",\n                \"vray_rop\",\n                \"usdrender\"]\n\n    def process(self, instance):\n        creator_attribute = instance.data[\"creator_attributes\"]\n\n        instance.data[\"review\"] = creator_attribute.get(\"review\", False)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_rop_frame_range.html","title":"collect_rop_frame_range","text":"<p>Collector plugin for frames data on ROP instances.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_rop_frame_range.html#client.ayon_houdini.plugins.publish.collect_rop_frame_range.CollectRopFrameRange","title":"<code>CollectRopFrameRange</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect all frames which would be saved from the ROP nodes</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_rop_frame_range.py</code> <pre><code>class CollectRopFrameRange(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect all frames which would be saved from the ROP nodes\"\"\"\n\n    order = pyblish.api.CollectorOrder\n    label = \"Collect RopNode Frame Range\"\n\n    def process(self, instance):\n\n        node_path = instance.data.get(\"instance_node\")\n        if node_path is None:\n            # Instance without instance node like a workfile instance\n            self.log.debug(\n                \"No instance node found for instance: {}\".format(instance)\n            )\n            return\n\n        ropnode = hou.node(node_path)\n        frame_data = lib.get_frame_data(\n            ropnode, self.log\n        )\n\n        if not frame_data:\n            return\n\n        # Log debug message about the collected frame range\n        self.log.debug(\n            \"Collected frame_data: {}\".format(frame_data)\n        )\n\n        instance.data.update(frame_data)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_staticmesh_type.html","title":"collect_staticmesh_type","text":"<p>Collector for staticMesh types.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_staticmesh_type.html#client.ayon_houdini.plugins.publish.collect_staticmesh_type.CollectStaticMeshType","title":"<code>CollectStaticMeshType</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect data type for fbx instance.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_staticmesh_type.py</code> <pre><code>class CollectStaticMeshType(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect data type for fbx instance.\"\"\"\n\n    families = [\"staticMesh\"]\n    label = \"Collect type of staticMesh\"\n\n    order = pyblish.api.CollectorOrder\n\n    def process(self, instance):\n\n        if instance.data[\"creator_identifier\"] == \"io.openpype.creators.houdini.staticmesh.fbx\":  # noqa: E501\n            # Marking this instance as FBX triggers the FBX extractor.\n            instance.data[\"families\"] += [\"fbx\"]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_task_handles.html","title":"collect_task_handles","text":"<p>Collector plugin for frames data on ROP instances.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_task_handles.html#client.ayon_houdini.plugins.publish.collect_task_handles.CollectAssetHandles","title":"<code>CollectAssetHandles</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Apply instance's task entity handles.</p> If instance does not have <ul> <li>frameStart</li> <li>frameEnd</li> <li>handleStart</li> <li>handleEnd</li> </ul> <p>But it does have:     - frameStartHandle     - frameEndHandle</p> <p>Then we will retrieve the task's handles to compute the exclusive frame range and actual handle ranges.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_task_handles.py</code> <pre><code>class CollectAssetHandles(plugin.HoudiniInstancePlugin,\n                          AYONPyblishPluginMixin):\n    \"\"\"Apply instance's task entity handles.\n\n    If instance does not have:\n        - frameStart\n        - frameEnd\n        - handleStart\n        - handleEnd\n    But it does have:\n        - frameStartHandle\n        - frameEndHandle\n\n    Then we will retrieve the task's handles to compute\n    the exclusive frame range and actual handle ranges.\n    \"\"\"\n    # TODO: This also validates against model products, even though those\n    #  should export a single frame regardless so maybe it's redundantly\n    #  validating?\n\n    # This specific order value is used so that\n    # this plugin runs after CollectAnatomyInstanceData\n    order = pyblish.api.CollectorOrder + 0.499\n\n    label = \"Collect Task Handles\"\n    use_asset_handles = True\n\n    ignore_product_types: set[str] = {\"rig\"}\n\n    def process(self, instance):\n\n        # Do no check asset handles for products that are essentially not\n        # intended to be time-based\n        if instance.data.get(\"productType\") in self.ignore_product_types:\n            return\n\n        # Only process instances without already existing handles data\n        # but that do have frameStartHandle and frameEndHandle defined\n        # like the data collected from CollectRopFrameRange\n        if \"frameStartHandle\" not in instance.data:\n            return\n        if \"frameEndHandle\" not in instance.data:\n            return\n\n        has_existing_data = {\n            \"handleStart\",\n            \"handleEnd\",\n            \"frameStart\",\n            \"frameEnd\"\n        }.issubset(instance.data)\n        if has_existing_data:\n            return\n\n        attr_values = self.get_attr_values_from_data(instance.data)\n        if attr_values.get(\"use_handles\", self.use_asset_handles):\n            # Get from task (if task is set), otherwise from folder\n            entity = instance.data.get(\"taskEntity\",\n                                       instance.data[\"folderEntity\"])\n            handle_start = entity[\"attrib\"].get(\"handleStart\", 0)\n            handle_end = entity[\"attrib\"].get(\"handleEnd\", 0)\n        else:\n            handle_start = 0\n            handle_end = 0\n\n        frame_start = instance.data[\"frameStartHandle\"] + handle_start\n        frame_end = instance.data[\"frameEndHandle\"] - handle_end\n\n        instance.data.update({\n            \"handleStart\": handle_start,\n            \"handleEnd\": handle_end,\n            \"frameStart\": frame_start,\n            \"frameEnd\": frame_end\n        })\n\n        # Log debug message about the collected frame range\n        if attr_values.get(\"use_handles\", self.use_asset_handles):\n            self.log.debug(\n                \"Full Frame range with Handles \"\n                \"[{frame_start_handle} - {frame_end_handle}]\"\n                .format(\n                    frame_start_handle=instance.data[\"frameStartHandle\"],\n                    frame_end_handle=instance.data[\"frameEndHandle\"]\n                )\n            )\n        else:\n            self.log.debug(\n                \"Use handles is deactivated for this instance, \"\n                \"start and end handles are set to 0.\"\n            )\n\n        # Log collected frame range to the user\n        message = \"Frame range [{frame_start} - {frame_end}]\".format(\n            frame_start=frame_start,\n            frame_end=frame_end\n        )\n        if handle_start or handle_end:\n            message += \" with handles [{handle_start}]-[{handle_end}]\".format(\n                handle_start=handle_start,\n                handle_end=handle_end\n            )\n        self.log.info(message)\n\n        if instance.data.get(\"byFrameStep\", 1.0) != 1.0:\n            self.log.info(\n                \"Frame steps {}\".format(instance.data[\"byFrameStep\"]))\n\n        # Add frame range to label if the instance has a frame range.\n        label = instance.data.get(\"label\", instance.data[\"name\"])\n        instance.data[\"label\"] = (\n            \"{label} [{frame_start_handle} - {frame_end_handle}]\"\n            .format(\n                label=label,\n                frame_start_handle=instance.data[\"frameStartHandle\"],\n                frame_end_handle=instance.data[\"frameEndHandle\"]\n            )\n        )\n\n    @classmethod\n    def get_attr_defs_for_instance(cls, create_context, instance):\n        if not cls.instance_matches_plugin_families(instance):\n            return []\n\n        if instance.data.get(\"productType\") in cls.ignore_product_types:\n            return []\n\n        return [\n            BoolDef(\"use_handles\",\n                    tooltip=\"Disable this if you want the publisher to\"\n                    \" ignore start and end handles specified in the\"\n                    \" task attributes for this publish instance\",\n                    default=cls.use_asset_handles,\n                    label=\"Use task handles\")\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_layers.html","title":"collect_usd_layers","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_layers.html#client.ayon_houdini.plugins.publish.collect_usd_layers.CollectUsdLayers","title":"<code>CollectUsdLayers</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect the USD Layers that have configured save paths.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_usd_layers.py</code> <pre><code>class CollectUsdLayers(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect the USD Layers that have configured save paths.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.25\n    label = \"Collect USD Layers\"\n    families = [\"usdrop\"]\n\n    def process(self, instance):\n        # TODO: Replace this with a Hidden Creator so we collect these BEFORE\n        #   starting the publish so the user sees them before publishing\n        #   - however user should not be able to individually enable/disable\n        #   this from the main ROP its created from?\n\n        output = instance.data.get(\"output_node\")\n        if not output:\n            self.log.debug(\"No output node found..\")\n            return\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n\n        save_layers = []\n        for layer in usdlib.get_configured_save_layers(rop_node):\n\n            info = layer.rootPrims.get(\"HoudiniLayerInfo\")\n            save_path = info.customData.get(\"HoudiniSavePath\")\n            creator = info.customData.get(\"HoudiniCreatorNode\")\n\n            self.log.debug(\"Found configured save path: \"\n                           \"%s -&gt; %s\", layer, save_path)\n\n            # Log node that configured this save path\n            creator_node = hou.nodeBySessionId(creator) if creator else None\n            if creator_node:\n                self.log.debug(\n                    \"Created by: %s\", creator_node.path()\n                )\n\n            save_layers.append((layer, save_path, creator_node))\n\n        # Store on the instance\n        instance.data[\"usdConfiguredSavePaths\"] = save_layers\n\n        # Create configured layer instances so User can disable updating\n        # specific configured layers for publishing.\n        context = instance.context\n        for layer, save_path, creator_node in save_layers:\n            name = os.path.basename(save_path)\n            layer_inst = context.create_instance(name)\n\n            # include same USD ROP\n            layer_inst.append(rop_node)\n\n            staging_dir, fname_with_args = os.path.split(save_path)\n\n            # The save path may include :SDF_FORMAT_ARGS: which will conflict\n            # with how we end up integrating these files because those will\n            # NOT be included in the actual output filename on disk, so we\n            # remove the SDF_FORMAT_ARGS from the filename.\n            fname = Sdf.Layer.SplitIdentifier(fname_with_args)[0]\n            fname_no_ext, ext = os.path.splitext(fname)\n\n            variant = fname_no_ext\n\n            # Strip off any trailing version number in the form of _v[0-9]+\n            variant = re.sub(\"_v[0-9]+$\", \"\", variant)\n\n            layer_inst.data[\"usd_layer\"] = layer\n            layer_inst.data[\"usd_layer_save_path\"] = save_path\n\n            project_name = context.data[\"projectName\"]\n            variant_base = instance.data[\"variant\"]\n            product_name = get_product_name(\n                project_name=project_name,\n                # TODO: This should use task from `instance`\n                task_name=context.data[\"anatomyData\"][\"task\"][\"name\"],\n                task_type=context.data[\"anatomyData\"][\"task\"][\"type\"],\n                host_name=context.data[\"hostName\"],\n                product_type=\"usd\",\n                variant=variant_base + \"_\" + variant,\n                project_settings=context.data[\"project_settings\"]\n            )\n\n            label = \"{0} -&gt; {1}\".format(instance.data[\"name\"], product_name)\n            family = \"usd\"\n            layer_inst.data[\"family\"] = family\n            layer_inst.data[\"families\"] = [family]\n            layer_inst.data[\"productName\"] = product_name\n            layer_inst.data[\"productType\"] = instance.data[\"productType\"]\n            layer_inst.data[\"label\"] = label\n            layer_inst.data[\"folderPath\"] = instance.data[\"folderPath\"]\n            layer_inst.data[\"task\"] = instance.data.get(\"task\")\n            layer_inst.data[\"instance_node\"] = instance.data[\"instance_node\"]\n            layer_inst.data[\"render\"] = False\n            layer_inst.data[\"output_node\"] = creator_node\n\n            # Inherit \"use handles\" from the source instance\n            # TODO: Do we want to maybe copy full `publish_attributes` instead?\n            copy_instance_data(\n                instance, layer_inst,\n                attr=\"publish_attributes.CollectRopFrameRange.use_handles\"\n            )\n\n            # Allow this subset to be grouped into a USD Layer on creation\n            layer_inst.data[\"productGroup\"] = (\n                instance.data.get(\"productGroup\") or \"USD Layer\"\n            )\n            # For now just assume the representation will get published\n            representation = {\n                \"name\": \"usd\",\n                \"ext\": ext.lstrip(\".\"),\n                \"stagingDir\": staging_dir,\n                \"files\": fname,\n\n                # Store an additional key with filenames including the\n                # SDF_FORMAT_ARGS so we can use this to remap paths\n                # accurately later.\n                \"files_raw\": fname_with_args\n            }\n            layer_inst.data.setdefault(\"representations\", []).append(\n                representation)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_layers.html#client.ayon_houdini.plugins.publish.collect_usd_layers.copy_instance_data","title":"<code>copy_instance_data(instance_src, instance_dest, attr)</code>","text":"<p>Copy instance data from <code>src</code> instance to <code>dest</code> instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; copy_instance_data(instance_src, instance_dest,\n&gt;&gt;&gt;                    attr=\"publish_attributes.CollectRopFrameRange\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>instance_src</code> <code>Instance</code> <p>Source instance to copy from</p> required <code>instance_dest</code> <code>Instance</code> <p>Target instance to copy to</p> required <code>attr</code> <code>str</code> <p>Attribute on the source instance to copy. This can be a nested key joined by <code>.</code> to only copy sub entries of dictionaries in the source instance's data.</p> required <p>Raises:</p> Type Description <code>KnownPublishError</code> <p>If a parent key already exists on the destination instance but is not of the correct type (= is not a dict)</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_usd_layers.py</code> <pre><code>def copy_instance_data(instance_src, instance_dest, attr):\n    \"\"\"Copy instance data from `src` instance to `dest` instance.\n\n    Examples:\n        &gt;&gt;&gt; copy_instance_data(instance_src, instance_dest,\n        &gt;&gt;&gt;                    attr=\"publish_attributes.CollectRopFrameRange\")\n\n    Arguments:\n        instance_src (pyblish.api.Instance): Source instance to copy from\n        instance_dest (pyblish.api.Instance): Target instance to copy to\n        attr (str): Attribute on the source instance to copy. This can be\n            a nested key joined by `.` to only copy sub entries of dictionaries\n            in the source instance's data.\n\n    Raises:\n        KnownPublishError: If a parent key already exists on the destination\n            instance but is not of the correct type (= is not a dict)\n\n    \"\"\"\n\n    src_data = instance_src.data\n    dest_data = instance_dest.data\n    keys = attr.split(\".\")\n    for i, key in enumerate(keys):\n        if key not in src_data:\n            break\n\n        src_value = src_data[key]\n        if i != len(key):\n            dest_data = dest_data.setdefault(key, {})\n            if not isinstance(dest_data, dict):\n                raise KnownPublishError(\"Destination must be a dict.\")\n            src_data = src_value\n        else:\n            # Last iteration - assign the value\n            dest_data[key] = copy.deepcopy(src_value)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_look_assets.html","title":"collect_usd_look_assets","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_look_assets.html#client.ayon_houdini.plugins.publish.collect_usd_look_assets.CollectUsdLookAssets","title":"<code>CollectUsdLookAssets</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect all assets introduced by the look.</p> <p>We are looking to collect e.g. all texture resources so we can transfer them with the publish and write then to the publish location.</p> <p>If possible, we'll also try to identify the colorspace of the asset.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_usd_look_assets.py</code> <pre><code>class CollectUsdLookAssets(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect all assets introduced by the look.\n\n    We are looking to collect e.g. all texture resources so we can transfer\n    them with the publish and write then to the publish location.\n\n    If possible, we'll also try to identify the colorspace of the asset.\n\n    \"\"\"\n    # TODO: Implement $F frame support (per frame values)\n    # TODO: If input image is already a published texture or resource than\n    #   preferably we'd keep the link in-tact and NOT update it. We can just\n    #   start ignoring AYON URIs\n\n    label = \"Collect USD Look Assets\"\n    order = pyblish.api.CollectorOrder\n    hosts = [\"houdini\"]\n    families = [\"look\"]\n\n    exclude_suffixes = [\".usd\", \".usda\", \".usdc\", \".usdz\", \".abc\", \".vbd\"]\n\n    def process(self, instance):\n\n        # Get Sdf.Layers from \"Collect ROP Sdf Layers and USD Stage\" plug-in\n        layers = instance.data.get(\"layers\")\n        if layers is None:\n            self.log.warning(f\"No USD layers found on instance: {instance}\")\n            return\n\n        layers: List[Sdf.Layer]\n        instance_resources = self.get_layer_assets(layers)\n\n        # Define a relative asset remapping for the USD Extractor so that\n        # any textures are remapped to their 'relative' publish path.\n        # All textures will be in a relative `./resources/` folder\n        remap = {}\n        for resource in instance_resources:\n            source = resource.source\n            name = os.path.basename(source)\n            remap[os.path.normpath(source)] = f\"./resources/{name}\"\n        instance.data[\"assetRemap\"] = remap\n\n        # Store resources on instance\n        resources = instance.data.setdefault(\"resources\", [])\n        for resource in instance_resources:\n            resources.append(dataclasses.asdict(resource))\n\n        # Log all collected textures\n        # Note: It is fine for a single texture to be included more than once\n        # where even one of them does not have a color space set, but the other\n        # does. For example, there may be a USD UV Texture just for a GL\n        # preview material which does not specify an OCIO color\n        # space.\n        all_files = []\n        for resource in instance_resources:\n            all_files.append(f\"{resource.attribute}:\")\n\n            for filepath in resource.files:\n                if resource.color_space:\n                    file_label = f\"- {filepath} ({resource.color_space})\"\n                else:\n                    file_label = f\"- {filepath}\"\n                all_files.append(file_label)\n\n        self.log.info(\n            \"Collected assets:\\n{}\".format(\n                \"\\n\".join(all_files)\n            )\n        )\n\n    def get_layer_assets(self, layers: List[Sdf.Layer]) -&gt; List[Resource]:\n        # TODO: Correctly resolve paths using Asset Resolver.\n        #       Preferably this would use one cached\n        #       resolver context to optimize the path resolving.\n        # TODO: Fix for timesamples - if timesamples, then `.default` might\n        #       not be authored on the spec\n\n        resources: List[Resource] = list()\n        for layer in layers:\n            for path in get_layer_property_paths(layer):\n\n                spec = layer.GetAttributeAtPath(path)\n                if not spec:\n                    continue\n\n                if spec.typeName != \"asset\":\n                    continue\n\n                asset: Sdf.AssetPath = spec.default\n                base, ext = os.path.splitext(asset.path)\n                if ext in self.exclude_suffixes:\n                    continue\n\n                filepath = asset.path.replace(\"\\\\\", \"/\")\n\n                # Expand &lt;UDIM&gt; to all files of the available files on disk\n                # TODO: Add support for `&lt;TILE&gt;`\n                # TODO: Add support for `&lt;ATTR:name INDEX:name DEFAULT:value&gt;`\n                if \"&lt;UDIM&gt;\" in filepath.upper():\n                    pattern = re.sub(\n                        r\"&lt;UDIM&gt;\",\n                        # UDIM is always four digits\n                        \"[0-9]\" * 4,\n                        filepath,\n                        flags=re.IGNORECASE\n                    )\n                    files = glob.glob(pattern)\n                else:\n                    # Single file\n                    files = [filepath]\n\n                # Detect the colorspace of the input asset property\n                colorspace = self.get_colorspace(spec)\n\n                resource = Resource(\n                    attribute=path.pathString,\n                    source=asset.path,\n                    files=files,\n                    color_space=colorspace\n                )\n                resources.append(resource)\n\n        # Sort by filepath\n        resources.sort(key=lambda r: r.source)\n\n        return resources\n\n    def get_colorspace(self, spec: Sdf.AttributeSpec) -&gt; Optional[str]:\n        \"\"\"Return colorspace for a Asset attribute spec.\n\n        There is currently no USD standard on how colorspaces should be\n        represented for shaders or asset properties - each renderer's material\n        implementations seem to currently use their own way of specifying the\n        colorspace on the shader. As such, this comes with some guesswork.\n\n        Args:\n            spec (Sdf.AttributeSpec): The asset type attribute to retrieve\n                the colorspace for.\n\n        Returns:\n            Optional[str]: The colorspace for the given attribute, if any.\n\n        \"\"\"\n        # TODO: Support Karma, V-Ray, Renderman texture colorspaces\n        # Materialx image defines colorspace as custom info on the attribute\n        if spec.HasInfo(\"colorSpace\"):\n            return spec.GetInfo(\"colorSpace\")\n\n        # Arnold materials define the colorspace as a separate primvar\n        # TODO: Fix for timesamples - if timesamples, then `.default` might\n        #       not be authored on the spec\n        prim_path = spec.path.GetPrimPath()\n        layer = spec.layer\n        for name in COLORSPACE_ATTRS:\n            colorspace_property_path = prim_path.AppendProperty(name)\n            colorspace_spec = layer.GetAttributeAtPath(\n                colorspace_property_path\n            )\n            if colorspace_spec and colorspace_spec.default:\n                return colorspace_spec.default\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_look_assets.html#client.ayon_houdini.plugins.publish.collect_usd_look_assets.CollectUsdLookAssets.get_colorspace","title":"<code>get_colorspace(spec)</code>","text":"<p>Return colorspace for a Asset attribute spec.</p> <p>There is currently no USD standard on how colorspaces should be represented for shaders or asset properties - each renderer's material implementations seem to currently use their own way of specifying the colorspace on the shader. As such, this comes with some guesswork.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>AttributeSpec</code> <p>The asset type attribute to retrieve the colorspace for.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The colorspace for the given attribute, if any.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_usd_look_assets.py</code> <pre><code>def get_colorspace(self, spec: Sdf.AttributeSpec) -&gt; Optional[str]:\n    \"\"\"Return colorspace for a Asset attribute spec.\n\n    There is currently no USD standard on how colorspaces should be\n    represented for shaders or asset properties - each renderer's material\n    implementations seem to currently use their own way of specifying the\n    colorspace on the shader. As such, this comes with some guesswork.\n\n    Args:\n        spec (Sdf.AttributeSpec): The asset type attribute to retrieve\n            the colorspace for.\n\n    Returns:\n        Optional[str]: The colorspace for the given attribute, if any.\n\n    \"\"\"\n    # TODO: Support Karma, V-Ray, Renderman texture colorspaces\n    # Materialx image defines colorspace as custom info on the attribute\n    if spec.HasInfo(\"colorSpace\"):\n        return spec.GetInfo(\"colorSpace\")\n\n    # Arnold materials define the colorspace as a separate primvar\n    # TODO: Fix for timesamples - if timesamples, then `.default` might\n    #       not be authored on the spec\n    prim_path = spec.path.GetPrimPath()\n    layer = spec.layer\n    for name in COLORSPACE_ATTRS:\n        colorspace_property_path = prim_path.AppendProperty(name)\n        colorspace_spec = layer.GetAttributeAtPath(\n            colorspace_property_path\n        )\n        if colorspace_spec and colorspace_spec.default:\n            return colorspace_spec.default\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_look_assets.html#client.ayon_houdini.plugins.publish.collect_usd_look_assets.CollectUsdLookResourceTransfers","title":"<code>CollectUsdLookResourceTransfers</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Define the publish direct file transfers for any found resources.</p> <p>This ensures that any source texture will end up in the published look in the <code>resourcesDir</code>.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_usd_look_assets.py</code> <pre><code>class CollectUsdLookResourceTransfers(plugin.HoudiniInstancePlugin):\n    \"\"\"Define the publish direct file transfers for any found resources.\n\n    This ensures that any source texture will end up in the published look\n    in the `resourcesDir`.\n\n    \"\"\"\n    label = \"Collect USD Look Transfers\"\n    order = pyblish.api.CollectorOrder + 0.496\n    hosts = [\"houdini\"]\n    families = [\"look\"]\n\n    def process(self, instance):\n\n        resources_dir = instance.data[\"resourcesDir\"]\n        transfers = instance.data.setdefault(\"transfers\", [])\n        for resource in instance.data.get(\"resources\", []):\n            for src in resource[\"files\"]:\n                dest = os.path.join(resources_dir, os.path.basename(src))\n                transfers.append((src, dest))\n                self.log.debug(\"Registering transfer: %s -&gt; %s\", src, dest)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_look_assets.html#client.ayon_houdini.plugins.publish.collect_usd_look_assets.get_layer_property_paths","title":"<code>get_layer_property_paths(layer)</code>","text":"<p>Return all property paths from a layer</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_usd_look_assets.py</code> <pre><code>def get_layer_property_paths(layer: Sdf.Layer) -&gt; List[Sdf.Path]:\n    \"\"\"Return all property paths from a layer\"\"\"\n    paths = []\n\n    def collect_paths(path):\n        if not path.IsPropertyPath():\n            return\n        paths.append(path)\n\n    layer.Traverse(\"/\", collect_paths)\n\n    return paths\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_render.html","title":"collect_usd_render","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_render.html#client.ayon_houdini.plugins.publish.collect_usd_render.CollectUsdRender","title":"<code>CollectUsdRender</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect publishing data for USD Render ROP.</p> <p>If <code>rendercommand</code> parm is disabled (and thus no rendering triggers by the usd render rop) it is assumed to be a \"Split Render\" job where the farm will get an additional render job after the USD file is extracted.</p> Provides <p>instance    -&gt; ifdFile</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_usd_render.py</code> <pre><code>class CollectUsdRender(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect publishing data for USD Render ROP.\n\n    If `rendercommand` parm is disabled (and thus no rendering triggers by the\n    usd render rop) it is assumed to be a \"Split Render\" job where the farm\n    will get an additional render job after the USD file is extracted.\n\n    Provides:\n        instance    -&gt; ifdFile\n\n    \"\"\"\n\n    label = \"Collect USD Render Rop\"\n    order = pyblish.api.CollectorOrder\n    hosts = [\"houdini\"]\n    families = [\"usdrender\"]\n\n    def process(self, instance):\n\n        rop = hou.node(instance.data.get(\"instance_node\"))\n\n        if instance.data[\"splitRender\"]:\n            # USD file output\n            lop_output = evalParmNoFrame(\n                rop, \"lopoutput\", pad_character=\"#\"\n            )\n\n            # The file is usually relative to the Output Processor's 'Save to\n            # Directory' which forces all USD files to end up in that directory\n            # TODO: It is possible for a user to disable this\n            # TODO: When enabled I think only the basename of the `lopoutput`\n            #  parm is preserved, any parent folders defined are likely ignored\n            folder = evalParmNoFrame(\n                rop, \"savetodirectory_directory\", pad_character=\"#\"\n            )\n\n            export_file = os.path.join(folder, lop_output)\n\n            # Substitute any # characters in the name back to their $F4\n            # equivalent\n            def replace_to_f(match):\n                number = len(match.group(0))\n                if number &lt;= 1:\n                    number = \"\"  # make it just $F not $F1 or $F0\n                return \"$F{}\".format(number)\n\n            export_file = re.sub(\"#+\", replace_to_f, export_file)\n            self.log.debug(\n                \"Found export file: {}\".format(export_file)\n            )\n            instance.data[\"ifdFile\"] = export_file\n\n            # The render job is not frame dependent but fully dependent on\n            # the job having been completed, since the extracted file is a\n            # single file.\n            if \"$F\" not in export_file:\n                instance.data[\"splitRenderFrameDependent\"] = False\n\n        # stub required data for Submit Publish Job publish plug-in\n        instance.data[\"attachTo\"] = []\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_rop_layer_and_stage.html","title":"collect_usd_rop_layer_and_stage","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_rop_layer_and_stage.html#client.ayon_houdini.plugins.publish.collect_usd_rop_layer_and_stage.CollectUsdRenderLayerAndStage","title":"<code>CollectUsdRenderLayerAndStage</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect USD stage and layers below layer break for USD ROPs.</p> <p>This collects an in-memory copy of the Usd.Stage that can be used in other collectors and validations. It also collects the Sdf.Layer objects up to the layer break (ignoring any above).</p> <p>It only creates an in-memory copy of anonymous layers and assumes that any intended to live on disk are already static written to disk files or at least the loaded Sdf.Layer to not be updated during publishing.</p> <p>It collects the stage and layers from the LOP node connected to the USD ROP with the context options set on the ROP node. This ensures the graph is evaluated similar to how the ROP node would process it on export.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_usd_rop_layer_and_stage.py</code> <pre><code>class CollectUsdRenderLayerAndStage(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect USD stage and layers below layer break for USD ROPs.\n\n    This collects an in-memory copy of the Usd.Stage that can be used in other\n    collectors and validations. It also collects the Sdf.Layer objects up to\n    the layer break (ignoring any above).\n\n    It only creates an in-memory copy of anonymous layers and assumes that any\n    intended to live on disk are already static written to disk files or at\n    least the loaded Sdf.Layer to not be updated during publishing.\n\n    It collects the stage and layers from the LOP node connected to the USD ROP\n    with the context options set on the ROP node. This ensures the graph is\n    evaluated similar to how the ROP node would process it on export.\n\n    \"\"\"\n\n    label = \"Collect ROP Sdf Layers and USD Stage\"\n    # Run after Collect Output Node\n    # Run just before regular CollectorOrder to have stage accessible\n    # to default collector orders\n    order = pyblish.api.CollectorOrder - 0.01\n    hosts = [\"houdini\"]\n    families = [\"usdrender\", \"usdrop\"]\n\n    def process(self, instance):\n\n        lop_node = instance.data.get(\"output_node\")\n        if not lop_node:\n            return\n\n        lop_node: hou.LopNode\n        rop: hou.RopNode = hou.node(instance.data[\"instance_node\"])\n        options = get_lops_rop_context_options(rop)\n\n        # Log the context options\n        self.log.debug(\n            \"Collecting USD stage with context options:\\n\"\n            f\"{json.dumps(options, indent=4)}\")\n\n        supports_cook_context_options = is_cook_context_options_supported()\n        with contextlib.ExitStack() as stack:\n            # Force cooking the lop node does not seem to work, so we\n            # must set the cook mode to \"Update\" for this to work\n            stack.enter_context(update_mode_context(hou.updateMode.AutoUpdate))\n\n            context_options_kwargs = {}\n            if supports_cook_context_options:\n                # Allow `LopNode.stage()` to cook with the context options\n                context_options_kwargs[\"context_options\"] = options\n            else:\n                # Backwards compatibility: Force cook it manually\n                # Set the context options of the ROP node.\n                stack.enter_context(context_options(options))\n\n                # Force cook. There have been some cases where the LOP node\n                # just would not return the USD stage without force cooking it.\n                lop_node.cook(force=True)\n\n            # Get stage and layers from the LOP node.\n            stage = lop_node.stage(use_last_cook_context_options=False,\n                                   apply_viewport_overrides=False,\n                                   apply_post_layers=False,\n                                   **context_options_kwargs)\n            if stage is None:\n                self.log.error(\n                    \"Unable to get USD stage from LOP node: \"\n                    f\"{lop_node.path()}. It may have failed to cook due to \"\n                    \"errors in the node graph.\")\n                return\n\n            above_break_layers = set(\n                lop_node.layersAboveLayerBreak(\n                    use_last_cook_context_options=False,\n                    **context_options_kwargs,\n                )\n            )\n            layers = [\n                layer for layer\n                in stage.GetLayerStack(includeSessionLayers=False)\n                if layer.identifier not in above_break_layers\n            ]\n\n            # The returned stage and layer in memory is shared across cooks\n            # so it is the exact same stage and layer object each time if\n            # multiple ROPs point to the same LOP node (or its layer's graph).\n            # As such, we must explicitly copy the stage and layers to ensure\n            # the next 'cook' does not affect the stage and layers of the\n            # previous instance or by any other process down the line.\n            # Get a copy of the stage and layers so that any in houdini edit\n            # or another recook from another instance of the same LOP layers\n            # does not influence this collected stage and layers.\n            copied_layer_mapping = copy_stage_layers(stage)\n            copied_stage = Usd.Stage.Open(\n                copied_layer_mapping[stage.GetRootLayer()])\n            copied_layers = [\n                # Remap layers only that were remapped (anonymous layers\n                # only). If the layer was not remapped, then use the\n                # original\n                copied_layer_mapping.get(layer, layer) for layer in layers\n            ]\n\n            instance.data[\"layers\"] = copied_layers\n            instance.data[\"stage\"] = copied_stage\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_rop_layer_and_stage.html#client.ayon_houdini.plugins.publish.collect_usd_rop_layer_and_stage.copy_stage_layers","title":"<code>copy_stage_layers(stage)</code>","text":"<p>Copy a stage's anonymous layers to new in-memory layers.</p> <p>The layers will be remapped to use the copied layers instead of the original layers if e.g. the root layer uses one of the other layers.</p> <p>Returns:</p> Type Description <code>Dict[Layer, Layer]</code> <p>Dict[Sdf.Layer, Sdf.Layer]: Mapping from original layers to copied layers.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_usd_rop_layer_and_stage.py</code> <pre><code>def copy_stage_layers(stage) -&gt; Dict[Sdf.Layer, Sdf.Layer]:\n    \"\"\"Copy a stage's anonymous layers to new in-memory layers.\n\n    The layers will be remapped to use the copied layers instead of the\n    original layers if e.g. the root layer uses one of the other layers.\n\n    Returns:\n        Dict[Sdf.Layer, Sdf.Layer]: Mapping from original layers to\n            copied layers.\n    \"\"\"\n    # Create a mapping from original layers to their copies\n    layer_mapping: Dict[Sdf.Layer, Sdf.Layer] = {}\n\n    # Copy each layer\n    for layer in stage.GetLayerStack(includeSessionLayers=False):\n        if not layer.anonymous:\n            # We disregard non-anonymous layers for replacing and assume\n            # they are static enough for our use case.\n            continue\n\n        copied_layer = Sdf.Layer.CreateAnonymous()\n        copied_layer.TransferContent(layer)\n        layer_mapping[layer] = copied_layer\n\n    # Remap all used layers in the root layer\n    copied_root_layer = layer_mapping[stage.GetRootLayer()]\n    for old_layer, new_layer in layer_mapping.items():\n        copied_root_layer.UpdateCompositionAssetDependency(\n            old_layer.identifier,\n            new_layer.identifier\n        )\n\n    return layer_mapping\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_usd_rop_layer_and_stage.html#client.ayon_houdini.plugins.publish.collect_usd_rop_layer_and_stage.is_cook_context_options_supported","title":"<code>is_cook_context_options_supported()</code>","text":"<p>Return whether current Houdini version supports cook context options. With this feature e.g. <code>LopNode.stage()</code> can now take a <code>context_options</code> argument to override the result, instead of having to force it with certain global context options set in the scene file.</p> <p>This was added on December 11th, 2024 to: - Houdini 20.5.455</p> <p>With backports to: - Houdini 20.0.918 - Houdini 19.5.1190</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_usd_rop_layer_and_stage.py</code> <pre><code>def is_cook_context_options_supported() -&gt; bool:\n    \"\"\"Return whether current Houdini version supports cook context options.\n    With this feature e.g. `LopNode.stage()` can now take a `context_options`\n    argument to override the result, instead of having to force it with certain\n    global context options set in the scene file.\n\n    This was added on December 11th, 2024 to:\n    - Houdini 20.5.455\n\n    With backports to:\n    - Houdini 20.0.918\n    - Houdini 19.5.1190\n    \"\"\"\n    major, minor, patch = hou.applicationVersion()\n    if (major, minor, patch) &gt;= (20, 5, 455):\n        return True\n    elif (major, minor) == (20, 0) and patch &gt;= 918:\n        return True\n    elif (major, minor) == (19, 5) and patch &gt;= 1190:\n        return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_vray_rop.html","title":"collect_vray_rop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_vray_rop.html#client.ayon_houdini.plugins.publish.collect_vray_rop.CollectVrayROPRenderProducts","title":"<code>CollectVrayROPRenderProducts</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Collect Vray Render Products</p> <p>Collects the instance.data[\"files\"] for the render products.</p> Provides <p>instance    -&gt; files</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_vray_rop.py</code> <pre><code>class CollectVrayROPRenderProducts(plugin.HoudiniInstancePlugin):\n    \"\"\"Collect Vray Render Products\n\n    Collects the instance.data[\"files\"] for the render products.\n\n    Provides:\n        instance    -&gt; files\n\n    \"\"\"\n\n    label = \"VRay ROP Render Products\"\n    # This specific order value is used so that\n    # this plugin runs after CollectFrames\n    order = pyblish.api.CollectorOrder + 0.11\n    families = [\"vray_rop\"]\n\n    def process(self, instance):\n\n        rop = hou.node(instance.data.get(\"instance_node\"))\n\n        default_prefix = evalParmNoFrame(rop, \"SettingsOutput_img_file_path\")\n        render_products = []\n        # TODO: add render elements if render element\n\n        export_prefix = None\n        export_products = []\n        if instance.data[\"splitRender\"]:\n            export_prefix = evalParmNoFrame(\n                rop, \"render_export_filepath\", pad_character=\"0\"\n            )\n            beauty_export_product = self.get_render_product_name(\n                prefix=export_prefix,\n                suffix=None)\n            export_products.append(beauty_export_product)\n            self.log.debug(\n                \"Found export product: {}\".format(beauty_export_product)\n            )\n            instance.data[\"ifdFile\"] = beauty_export_product\n            instance.data[\"exportFiles\"] = list(export_products)\n\n        beauty_product = self.get_render_product_name(default_prefix)\n        render_products.append(beauty_product)\n        files_by_aov = {\n            \"\": self.generate_expected_files(instance,\n                                                      beauty_product)}\n\n        # Assume it's a multipartExr Render.\n        multipartExr = True\n\n        if instance.data.get(\"RenderElement\", True):\n            render_element = self.get_render_element_name(rop, default_prefix)\n            if render_element:\n                for aov, renderpass in render_element.items():\n                    render_products.append(renderpass)\n                    files_by_aov[aov] = self.generate_expected_files(\n                        instance, renderpass)\n                    # Set to False as soon as we have a separated aov.\n                    multipartExr = False\n\n        # Review Logic expects this key to exist and be True\n        # if render is a multipart Exr.\n        # As long as we have one AOV then multipartExr should be True.\n        instance.data[\"multipartExr\"] = multipartExr\n\n        for product in render_products:\n            self.log.debug(\"Found render product: %s\" % product)\n        filenames = list(render_products)\n        instance.data[\"files\"] = filenames\n\n        # For now by default do NOT try to publish the rendered output\n        instance.data[\"publishJobState\"] = \"Suspended\"\n        instance.data[\"attachTo\"] = []      # stub required data\n\n        if \"expectedFiles\" not in instance.data:\n            instance.data[\"expectedFiles\"] = list()\n        instance.data[\"expectedFiles\"].append(files_by_aov)\n        self.log.debug(\"expectedFiles:{}\".format(files_by_aov))\n\n    def get_render_product_name(self, prefix, suffix=\"&lt;reName&gt;\"):\n        \"\"\"Return the beauty output filename if render element enabled\n        \"\"\"\n        # Remove aov suffix from the product: `prefix.aov_suffix` -&gt; `prefix`\n        aov_parm = \".{}\".format(suffix)\n        return prefix.replace(aov_parm, \"\")\n\n    def get_render_element_name(self, node, prefix, suffix=\"&lt;reName&gt;\"):\n        \"\"\"Return the output filename using the AOV prefix and suffix\n        \"\"\"\n        render_element_dict = {}\n        # need a rewrite\n        re_path = node.evalParm(\"render_network_render_channels\")\n        if re_path:\n            node_children = hou.node(re_path).children()\n            for element in node_children:\n                if element.shaderName() != \"vray:SettingsRenderChannels\":\n                    aov = str(element)\n                    render_product = prefix.replace(suffix, aov)\n                    render_element_dict[aov] = render_product\n        return render_element_dict\n\n    def generate_expected_files(self, instance, path):\n        \"\"\"Create expected files in instance data\"\"\"\n\n        dir = os.path.dirname(path)\n        file = os.path.basename(path)\n\n        if \"#\" in file:\n            def replace(match):\n                return \"%0{}d\".format(len(match.group()))\n\n            file = re.sub(\"#+\", replace, file)\n\n        if \"%\" not in file:\n            return path\n\n        expected_files = []\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n\n        for i in range(int(start), (int(end) + 1)):\n            expected_files.append(\n                os.path.join(dir, (file % i)).replace(\"\\\\\", \"/\"))\n\n        return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_vray_rop.html#client.ayon_houdini.plugins.publish.collect_vray_rop.CollectVrayROPRenderProducts.generate_expected_files","title":"<code>generate_expected_files(instance, path)</code>","text":"<p>Create expected files in instance data</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_vray_rop.py</code> <pre><code>def generate_expected_files(self, instance, path):\n    \"\"\"Create expected files in instance data\"\"\"\n\n    dir = os.path.dirname(path)\n    file = os.path.basename(path)\n\n    if \"#\" in file:\n        def replace(match):\n            return \"%0{}d\".format(len(match.group()))\n\n        file = re.sub(\"#+\", replace, file)\n\n    if \"%\" not in file:\n        return path\n\n    expected_files = []\n    start = instance.data[\"frameStartHandle\"]\n    end = instance.data[\"frameEndHandle\"]\n\n    for i in range(int(start), (int(end) + 1)):\n        expected_files.append(\n            os.path.join(dir, (file % i)).replace(\"\\\\\", \"/\"))\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_vray_rop.html#client.ayon_houdini.plugins.publish.collect_vray_rop.CollectVrayROPRenderProducts.get_render_element_name","title":"<code>get_render_element_name(node, prefix, suffix='&lt;reName&gt;')</code>","text":"<p>Return the output filename using the AOV prefix and suffix</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_vray_rop.py</code> <pre><code>def get_render_element_name(self, node, prefix, suffix=\"&lt;reName&gt;\"):\n    \"\"\"Return the output filename using the AOV prefix and suffix\n    \"\"\"\n    render_element_dict = {}\n    # need a rewrite\n    re_path = node.evalParm(\"render_network_render_channels\")\n    if re_path:\n        node_children = hou.node(re_path).children()\n        for element in node_children:\n            if element.shaderName() != \"vray:SettingsRenderChannels\":\n                aov = str(element)\n                render_product = prefix.replace(suffix, aov)\n                render_element_dict[aov] = render_product\n    return render_element_dict\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_vray_rop.html#client.ayon_houdini.plugins.publish.collect_vray_rop.CollectVrayROPRenderProducts.get_render_product_name","title":"<code>get_render_product_name(prefix, suffix='&lt;reName&gt;')</code>","text":"<p>Return the beauty output filename if render element enabled</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_vray_rop.py</code> <pre><code>def get_render_product_name(self, prefix, suffix=\"&lt;reName&gt;\"):\n    \"\"\"Return the beauty output filename if render element enabled\n    \"\"\"\n    # Remove aov suffix from the product: `prefix.aov_suffix` -&gt; `prefix`\n    aov_parm = \".{}\".format(suffix)\n    return prefix.replace(aov_parm, \"\")\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_workfile.html#client.ayon_houdini.plugins.publish.collect_workfile.CollectWorkfile","title":"<code>CollectWorkfile</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Inject workfile representation into instance</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfile(plugin.HoudiniInstancePlugin):\n    \"\"\"Inject workfile representation into instance\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.01\n    label = \"Houdini Workfile Data\"\n    families = [\"workfile\"]\n\n    def process(self, instance):\n\n        current_file = instance.context.data[\"currentFile\"]\n        folder, file = os.path.split(current_file)\n        filename, ext = os.path.splitext(file)\n\n        instance.data.update({\n            \"setMembers\": [current_file],\n            \"frameStart\": instance.context.data['frameStart'],\n            \"frameEnd\": instance.context.data['frameEnd'],\n            \"handleStart\": instance.context.data['handleStart'],\n            \"handleEnd\": instance.context.data['handleEnd']\n        })\n\n        instance.data['representations'] = [{\n            'name': ext.lstrip(\".\"),\n            'ext': ext.lstrip(\".\"),\n            'files': file,\n            \"stagingDir\": folder,\n        }]\n\n        self.log.debug('Collected workfile instance: {}'.format(file))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_workscene_fps.html","title":"collect_workscene_fps","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/collect_workscene_fps.html#client.ayon_houdini.plugins.publish.collect_workscene_fps.CollectWorksceneFPS","title":"<code>CollectWorksceneFPS</code>","text":"<p>               Bases: <code>HoudiniContextPlugin</code></p> <p>Get the FPS of the work scene.</p> Source code in <code>client/ayon_houdini/plugins/publish/collect_workscene_fps.py</code> <pre><code>class CollectWorksceneFPS(plugin.HoudiniContextPlugin):\n    \"\"\"Get the FPS of the work scene.\"\"\"\n\n    label = \"Workscene FPS\"\n    order = pyblish.api.CollectorOrder\n\n    def process(self, context):\n        fps = hou.fps()\n        self.log.info(\"Workscene FPS: %s\" % fps)\n        context.data.update({\"fps\": fps})\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_active_view_thumbnail.html","title":"extract_active_view_thumbnail","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_active_view_thumbnail.html#client.ayon_houdini.plugins.publish.extract_active_view_thumbnail.ExtractActiveViewThumbnail","title":"<code>ExtractActiveViewThumbnail</code>","text":"<p>               Bases: <code>HoudiniExtractorPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Set instance thumbnail to a screengrab of current active viewport.</p> <p>This makes it so that if an instance does not have a thumbnail set yet that it will get a thumbnail of the currently active view at the time of publishing as a fallback.</p> Source code in <code>client/ayon_houdini/plugins/publish/extract_active_view_thumbnail.py</code> <pre><code>class ExtractActiveViewThumbnail(plugin.HoudiniExtractorPlugin,\n                                 OptionalPyblishPluginMixin):\n    \"\"\"Set instance thumbnail to a screengrab of current active viewport.\n\n    This makes it so that if an instance does not have a thumbnail set yet that\n    it will get a thumbnail of the currently active view at the time of\n    publishing as a fallback.\n\n    \"\"\"\n    order = pyblish.api.ExtractorOrder + 0.49\n    label = \"Extract Active View Thumbnail\"\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if IS_HEADLESS:\n            self.log.debug(\n                \"Skip extraction of active view thumbnail, due to being in\"\n                \"headless mode.\"\n            )\n            return\n\n        thumbnail = instance.data.get(\"thumbnailPath\")\n        if thumbnail:\n            # A thumbnail was already set for this instance\n            return\n\n        view_thumbnail = self.get_view_thumbnail(instance)\n        if not view_thumbnail:\n            return\n        self.log.debug(\"Setting instance thumbnail path to: {}\"\n                       .format(view_thumbnail)\n        )\n        instance.data[\"thumbnailPath\"] = view_thumbnail\n\n    def get_view_thumbnail(self, instance):\n\n        sceneview = lib.get_scene_viewer()\n        if sceneview is None:\n            self.log.debug(\"Skipping Extract Active View Thumbnail\"\n                           \" because no scene view was detected.\")\n            return\n\n        with tempfile.NamedTemporaryFile(\n            \"w\", suffix=\".jpg\", delete=False\n        ) as tmp:\n            thumbnail_path = tmp.name\n        lib.sceneview_snapshot(sceneview, thumbnail_path)\n\n        instance.context.data[\"cleanupFullPaths\"].append(thumbnail_path)\n        return thumbnail_path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_hda.html","title":"extract_hda","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_hda.html#client.ayon_houdini.plugins.publish.extract_hda.revert_original_parm_template_group","title":"<code>revert_original_parm_template_group(node)</code>","text":"<p>Restore parm template group after the context</p> Source code in <code>client/ayon_houdini/plugins/publish/extract_hda.py</code> <pre><code>@contextlib.contextmanager\ndef revert_original_parm_template_group(node: \"hou.OpNode\"):\n    \"\"\"Restore parm template group after the context\"\"\"\n    parm_group = node.parmTemplateGroup()\n    try:\n        yield\n    finally:\n        # Set the original\n        node.setParmTemplateGroup(parm_group)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_last_published.html","title":"extract_last_published","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_last_published.html#client.ayon_houdini.plugins.publish.extract_last_published.ExtractLastPublished","title":"<code>ExtractLastPublished</code>","text":"<p>               Bases: <code>HoudiniExtractorPlugin</code></p> <p>Extractor copying files from last published to staging directory.</p> <p>It works only if instance data includes \"last_version_published_files\" and there are frames to fix.</p> <p>The files from last published are based on files which will be extended/fixed for specific frames.</p> NOTE <p>This plugin is closely taken from ayon-nuke. It contains some Houdini addon specific logic as various addons may   have unique methods for managing <code>staging_dir</code>, <code>expectedFiles</code>   and <code>frames</code>.</p> <p>TODO:     It's preferable to to generalize this plugin for broader use and       integrate it into ayon-core.</p> Source code in <code>client/ayon_houdini/plugins/publish/extract_last_published.py</code> <pre><code>class ExtractLastPublished(plugin.HoudiniExtractorPlugin):\n    \"\"\"Extractor copying files from last published to staging directory.\n\n    It works only if instance data includes \"last_version_published_files\"\n    and there are frames to fix.\n\n    The files from last published are based on files which will be\n    extended/fixed for specific frames.\n\n    NOTE:\n        This plugin is closely taken from ayon-nuke.\n        It contains some Houdini addon specific logic as various addons may\n          have unique methods for managing `staging_dir`, `expectedFiles`\n          and `frames`.\n    TODO:\n        It's preferable to to generalize this plugin for broader use and\n          integrate it into ayon-core.\n    \"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.1\n    label = \"Extract Last Published\"\n    targets = [\"local\"]  # Same target as `CollectFramesFixDef`\n    families = [\"*\"]\n\n    def process(self, instance):\n        frames_to_fix = instance.data.get(\"frames_to_fix\")\n        if not frames_to_fix:\n            self.log.debug(\"Skipping, No frames to fix.\")\n            return\n\n        if not instance.data.get(\"integrate\", True):\n            self.log.debug(\"Skipping collecting frames to fix data for \"\n                           \"instance because instance is set to not integrate\")\n            return\n\n        last_published = instance.data.get(\"last_version_published_files\")\n        if not last_published:\n            self.log.debug(\"Skipping, No last publish found.\")\n            return\n\n        last_published_and_frames = collect_frames(last_published)\n        if not all(last_published_and_frames.values()):\n            self.log.debug(\"Skipping, No file sequence found in the \"\n                           \"last version published files.\")\n            return\n\n        staging_dir, expected_filenames = (\n            self.get_expected_files_and_staging_dir(instance)\n        )\n\n        os.makedirs(staging_dir, exist_ok=True)\n\n        expected_and_frames = collect_frames(expected_filenames)\n        frames_and_expected = {v: k for k, v in expected_and_frames.items()}\n        frames_to_fix = clique.parse(frames_to_fix, \"{ranges}\")\n\n        anatomy = instance.context.data[\"anatomy\"]\n\n        # TODO: This currently copies ALL frames from the last version instead\n        #  of only those within the frame range we're currently looking to\n        #  publish. It should instead, iterate over all expected frames for\n        #  current instance, exclude all \"to fix\" frames and copy the\n        #  other existing ones.\n        for file_path, frame in last_published_and_frames.items():\n            if frame is None:\n                continue\n            file_path = anatomy.fill_root(file_path)\n            if not os.path.exists(file_path):\n                continue\n            target_file_name = frames_and_expected.get(frame)\n            if not target_file_name:\n                continue\n\n            out_path = os.path.join(staging_dir, target_file_name)\n\n            # Copy only the frames that we won't render.\n            if frame and frame not in frames_to_fix:\n                self.log.debug(f\"Copying '{file_path}' -&gt; '{out_path}'\")\n                shutil.copy(file_path, out_path)\n\n    def get_expected_files_and_staging_dir(self, instance):\n        \"\"\"Get expected file names or frames.\n\n        This method includes Houdini specific code.\n\n        Args:\n            instance (pyblish.api.Instance): The instance to publish.\n\n        Returns:\n            tuple[str, list[str]]: A 2-tuple of staging dir and the list of\n                expected frames for the current publish instance.\n        \"\"\"\n        expected_filenames = []\n        staging_dir = instance.data.get(\"stagingDir\")\n        expected_files = instance.data.get(\"expectedFiles\", [])\n\n        # 'expectedFiles' are preferred over 'frames'\n        if expected_files:\n            # Products with expected files\n            # This can be Render products or submitted cache to farm.\n            for expected in expected_files:\n                # expected.values() is a list of lists\n                expected_filenames.extend(sum(expected.values(), []))\n        else:\n            # Products with frames or single file.\n            frames = instance.data.get(\"frames\", \"\")\n            if isinstance(frames, str):\n                # single file.\n                expected_filenames.append(\"{}/{}\".format(staging_dir, frames))\n            else:\n                # list of frame.\n                expected_filenames.extend(\n                    [\"{}/{}\".format(staging_dir, f) for f in frames]\n                )\n\n        return staging_dir, expected_filenames\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_last_published.html#client.ayon_houdini.plugins.publish.extract_last_published.ExtractLastPublished.get_expected_files_and_staging_dir","title":"<code>get_expected_files_and_staging_dir(instance)</code>","text":"<p>Get expected file names or frames.</p> <p>This method includes Houdini specific code.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The instance to publish.</p> required <p>Returns:</p> Type Description <p>tuple[str, list[str]]: A 2-tuple of staging dir and the list of expected frames for the current publish instance.</p> Source code in <code>client/ayon_houdini/plugins/publish/extract_last_published.py</code> <pre><code>def get_expected_files_and_staging_dir(self, instance):\n    \"\"\"Get expected file names or frames.\n\n    This method includes Houdini specific code.\n\n    Args:\n        instance (pyblish.api.Instance): The instance to publish.\n\n    Returns:\n        tuple[str, list[str]]: A 2-tuple of staging dir and the list of\n            expected frames for the current publish instance.\n    \"\"\"\n    expected_filenames = []\n    staging_dir = instance.data.get(\"stagingDir\")\n    expected_files = instance.data.get(\"expectedFiles\", [])\n\n    # 'expectedFiles' are preferred over 'frames'\n    if expected_files:\n        # Products with expected files\n        # This can be Render products or submitted cache to farm.\n        for expected in expected_files:\n            # expected.values() is a list of lists\n            expected_filenames.extend(sum(expected.values(), []))\n    else:\n        # Products with frames or single file.\n        frames = instance.data.get(\"frames\", \"\")\n        if isinstance(frames, str):\n            # single file.\n            expected_filenames.append(\"{}/{}\".format(staging_dir, frames))\n        else:\n            # list of frame.\n            expected_filenames.extend(\n                [\"{}/{}\".format(staging_dir, f) for f in frames]\n            )\n\n    return staging_dir, expected_filenames\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_render.html","title":"extract_render","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_rop.html","title":"extract_rop","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_rop.html#client.ayon_houdini.plugins.publish.extract_rop.ExtractROP","title":"<code>ExtractROP</code>","text":"<p>               Bases: <code>HoudiniExtractorPlugin</code></p> <p>Generic Extractor for any ROP node.</p> Source code in <code>client/ayon_houdini/plugins/publish/extract_rop.py</code> <pre><code>class ExtractROP(plugin.HoudiniExtractorPlugin):\n    \"\"\"Generic Extractor for any ROP node.\"\"\"\n    label = \"Extract ROP\"\n    order = pyblish.api.ExtractorOrder\n\n    families = [\"abc\", \"camera\", \"bgeo\", \"pointcache\", \"fbx\",\n                \"vdbcache\", \"ass\", \"redshiftproxy\", \"mantraifd\"]\n    targets = [\"local\", \"remote\"]\n\n    def process(self, instance: pyblish.api.Instance):\n        if instance.data.get(\"farm\"):\n            self.log.debug(\"Should be processed on farm, skipping.\")\n            return\n        creator_attribute = instance.data[\"creator_attributes\"]\n\n        files = instance.data[\"frames\"]\n        first_file = files[0] if isinstance(files, (list, tuple)) else files\n        _, ext = splitext(\n            first_file, allowed_multidot_extensions=[\n                \".ass.gz\", \".bgeo.sc\", \".bgeo.gz\",\n                \".bgeo.lzma\", \".bgeo.bz2\"]\n        )\n        ext = ext.lstrip(\".\")\n\n        # Value `local` is used as a fallback if the `render_target`\n        #   key is missing.\n        # This key might be absent because render targets are not\n        #   yet implemented for all product types that use this plugin.\n        if creator_attribute.get(\"render_target\", \"local\") == \"local\":\n            self.render_rop(instance)\n        self.validate_expected_frames(instance)\n\n        # In some cases representation name is not the the extension\n        # TODO: Preferably we remove this very specific naming\n        product_type = instance.data[\"productType\"]\n        name = {\n            \"bgeo\": \"bgeo\",\n            \"rs\": \"rs\",\n            \"ass\": \"ass\"\n        }.get(product_type, ext)\n\n        representation = {\n            \"name\": name,\n            \"ext\": ext,\n            \"files\": instance.data[\"frames\"],\n            \"stagingDir\": instance.data[\"stagingDir\"],\n            \"frameStart\": instance.data[\"frameStartHandle\"],\n            \"frameEnd\": instance.data[\"frameEndHandle\"],\n        }\n        self.update_representation_data(instance, representation)\n        instance.data.setdefault(\"representations\", []).append(representation)\n\n    def validate_expected_frames(self, instance: pyblish.api.Instance):\n        \"\"\"\n        Validate all expected files in `instance.data[\"frames\"]` exist in\n        the staging directory.\n        \"\"\"\n        filenames = instance.data[\"frames\"]\n        staging_dir = instance.data[\"stagingDir\"]\n        if isinstance(filenames, str):\n            # Single frame\n            filenames = [filenames]\n\n        missing_frames = []\n        for filename in filenames:\n            filename = os.path.join(staging_dir, filename)\n            if not os.path.isfile(filename):\n                missing_frames.append(filename)\n\n        if missing_frames:\n            # Combine collections for simpler logs of missing files\n            missing_frames  = format_as_collections(missing_frames)\n            missing_frames = \"\\n \".join(\n                f\"- {sequence}\" for sequence in missing_frames\n            )\n            raise PublishError(\n                \"Failed to complete render extraction.\\n\"\n                \"Please render any missing output files.\",\n                detail=f\"Missing output files: \\n {missing_frames}\"\n            )\n\n    def update_representation_data(self,\n                                   instance: pyblish.api.Instance,\n                                   representation: dict):\n        \"\"\"Allow subclass to override the representation data in-place\"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_rop.html#client.ayon_houdini.plugins.publish.extract_rop.ExtractROP.update_representation_data","title":"<code>update_representation_data(instance, representation)</code>","text":"<p>Allow subclass to override the representation data in-place</p> Source code in <code>client/ayon_houdini/plugins/publish/extract_rop.py</code> <pre><code>def update_representation_data(self,\n                               instance: pyblish.api.Instance,\n                               representation: dict):\n    \"\"\"Allow subclass to override the representation data in-place\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_rop.html#client.ayon_houdini.plugins.publish.extract_rop.ExtractROP.validate_expected_frames","title":"<code>validate_expected_frames(instance)</code>","text":"<p>Validate all expected files in <code>instance.data[\"frames\"]</code> exist in the staging directory.</p> Source code in <code>client/ayon_houdini/plugins/publish/extract_rop.py</code> <pre><code>def validate_expected_frames(self, instance: pyblish.api.Instance):\n    \"\"\"\n    Validate all expected files in `instance.data[\"frames\"]` exist in\n    the staging directory.\n    \"\"\"\n    filenames = instance.data[\"frames\"]\n    staging_dir = instance.data[\"stagingDir\"]\n    if isinstance(filenames, str):\n        # Single frame\n        filenames = [filenames]\n\n    missing_frames = []\n    for filename in filenames:\n        filename = os.path.join(staging_dir, filename)\n        if not os.path.isfile(filename):\n            missing_frames.append(filename)\n\n    if missing_frames:\n        # Combine collections for simpler logs of missing files\n        missing_frames  = format_as_collections(missing_frames)\n        missing_frames = \"\\n \".join(\n            f\"- {sequence}\" for sequence in missing_frames\n        )\n        raise PublishError(\n            \"Failed to complete render extraction.\\n\"\n            \"Please render any missing output files.\",\n            detail=f\"Missing output files: \\n {missing_frames}\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_usd.html","title":"extract_usd","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_usd.html#client.ayon_houdini.plugins.publish.extract_usd.ExtractUSD","title":"<code>ExtractUSD</code>","text":"<p>               Bases: <code>HoudiniExtractorPlugin</code></p> Source code in <code>client/ayon_houdini/plugins/publish/extract_usd.py</code> <pre><code>class ExtractUSD(plugin.HoudiniExtractorPlugin):\n\n    order = pyblish.api.ExtractorOrder\n    label = \"Extract USD\"\n    families = [\"usdrop\"]\n\n    use_ayon_entity_uri = False\n\n    def process(self, instance):\n\n        ropnode = hou.node(instance.data.get(\"instance_node\"))\n\n        # Get the filename from the filename parameter\n        output = ropnode.evalParm(\"lopoutput\")\n        staging_dir = os.path.dirname(output)\n        instance.data[\"stagingDir\"] = staging_dir\n        file_name = os.path.basename(output)\n\n        self.log.info(\"Writing USD '%s' to '%s'\" % (file_name, staging_dir))\n\n        mapping = self.get_source_to_publish_paths(instance.context)\n        if mapping:\n            self.log.debug(f\"Remapping paths: {mapping}\")\n\n        # Allow instance-specific path remapping overrides, e.g. changing\n        # paths on used resources/textures for looks\n        instance_mapping = instance.data.get(\"assetRemap\", {})\n        if instance_mapping:\n            self.log.debug(\"Instance-specific asset path remapping:\\n\"\n                           f\"{instance_mapping}\")\n        mapping.update(instance_mapping)\n\n        with remap_paths(ropnode, mapping):\n            render_rop(ropnode)\n\n        if not os.path.exists(output):\n            PublishError(f\"Output does not exist: {output}\")\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'usd',\n            'ext': 'usd',\n            'files': file_name,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n    def get_source_to_publish_paths(self,\n                                    context):\n        \"\"\"Define a mapping of all current instances in context from source\n        file to publish file so this can be used on the USD save to remap\n        asset layer paths on publish via AyonRemapPaths output processor\n\n        Arguments:\n            context (pyblish.api.Context): Publish context.\n\n        Returns:\n            dict[str, str]: Mapping from source path to remapped path.\n\n        \"\"\"\n\n        mapping = {}\n        for instance in context:\n            if not instance.data.get(\"active\", True):\n                continue\n\n            if not instance.data.get(\"publish\", True):\n                continue\n\n            for repre in instance.data.get(\"representations\", []):\n                name = repre.get(\"name\")\n                ext = repre.get(\"ext\")\n\n                # TODO: The remapping might need to get more involved if the\n                #   asset paths that are set use e.g. $F\n                # TODO: If the representation has multiple files we might need\n                #   to define the path remapping per file of the sequence\n                if self.use_ayon_entity_uri:\n                    # Construct AYON entity URI\n                    # Note: entity does not exist yet\n                    path = construct_ayon_entity_uri(\n                        project_name=context.data[\"projectName\"],\n                        folder_path=instance.data[\"folderPath\"],\n                        product=instance.data[\"productName\"],\n                        version=instance.data[\"version\"],\n                        representation_name=name\n                    )\n                else:\n                    # Resolved publish filepath\n                    path = get_instance_expected_output_path(\n                        instance, representation_name=name, ext=ext\n                    )\n\n                for source_path in get_source_paths(instance, repre):\n                    source_path = os.path.normpath(source_path)\n                    mapping[source_path] = path\n\n        return mapping\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_usd.html#client.ayon_houdini.plugins.publish.extract_usd.ExtractUSD.get_source_to_publish_paths","title":"<code>get_source_to_publish_paths(context)</code>","text":"<p>Define a mapping of all current instances in context from source file to publish file so this can be used on the USD save to remap asset layer paths on publish via AyonRemapPaths output processor</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>Publish context.</p> required <p>Returns:</p> Type Description <p>dict[str, str]: Mapping from source path to remapped path.</p> Source code in <code>client/ayon_houdini/plugins/publish/extract_usd.py</code> <pre><code>def get_source_to_publish_paths(self,\n                                context):\n    \"\"\"Define a mapping of all current instances in context from source\n    file to publish file so this can be used on the USD save to remap\n    asset layer paths on publish via AyonRemapPaths output processor\n\n    Arguments:\n        context (pyblish.api.Context): Publish context.\n\n    Returns:\n        dict[str, str]: Mapping from source path to remapped path.\n\n    \"\"\"\n\n    mapping = {}\n    for instance in context:\n        if not instance.data.get(\"active\", True):\n            continue\n\n        if not instance.data.get(\"publish\", True):\n            continue\n\n        for repre in instance.data.get(\"representations\", []):\n            name = repre.get(\"name\")\n            ext = repre.get(\"ext\")\n\n            # TODO: The remapping might need to get more involved if the\n            #   asset paths that are set use e.g. $F\n            # TODO: If the representation has multiple files we might need\n            #   to define the path remapping per file of the sequence\n            if self.use_ayon_entity_uri:\n                # Construct AYON entity URI\n                # Note: entity does not exist yet\n                path = construct_ayon_entity_uri(\n                    project_name=context.data[\"projectName\"],\n                    folder_path=instance.data[\"folderPath\"],\n                    product=instance.data[\"productName\"],\n                    version=instance.data[\"version\"],\n                    representation_name=name\n                )\n            else:\n                # Resolved publish filepath\n                path = get_instance_expected_output_path(\n                    instance, representation_name=name, ext=ext\n                )\n\n            for source_path in get_source_paths(instance, repre):\n                source_path = os.path.normpath(source_path)\n                mapping[source_path] = path\n\n    return mapping\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/extract_usd.html#client.ayon_houdini.plugins.publish.extract_usd.get_source_paths","title":"<code>get_source_paths(instance, repre)</code>","text":"<p>Return the full source filepaths for an instance's representations</p> Source code in <code>client/ayon_houdini/plugins/publish/extract_usd.py</code> <pre><code>def get_source_paths(\n        instance: pyblish.api.Instance,\n        repre: dict\n) -&gt; List[AnyStr]:\n    \"\"\"Return the full source filepaths for an instance's representations\"\"\"\n\n    staging = repre.get(\"stagingDir\", instance.data.get(\"stagingDir\"))\n\n    # Support special `files_raw` key for representations that may originate\n    # from a path in the USD file including `:SDF_FORMAT_ARGS:` which we will\n    # also want to match against.\n    if \"files_raw\" in repre:\n        files = repre[\"files_raw\"]\n    else:\n        files = repre.get(\"files\", [])\n\n    if isinstance(files, list):\n        return [os.path.join(staging, fname) for fname in files]\n    elif isinstance(files, str):\n        # Single file\n        return [os.path.join(staging, files)]\n\n    raise KnownPublishError(\n        \"Unsupported type for representation files:\"\n        f\" {files} (supports list or str)\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/increment_current_file.html","title":"increment_current_file","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/increment_current_file.html#client.ayon_houdini.plugins.publish.increment_current_file.IncrementCurrentFile","title":"<code>IncrementCurrentFile</code>","text":"<p>               Bases: <code>HoudiniContextPlugin</code></p> <p>Increment the current file.</p> <p>Saves the current scene with an increased version number.</p> Source code in <code>client/ayon_houdini/plugins/publish/increment_current_file.py</code> <pre><code>class IncrementCurrentFile(plugin.HoudiniContextPlugin):\n    \"\"\"Increment the current file.\n\n    Saves the current scene with an increased version number.\n\n    \"\"\"\n\n    label = \"Increment current file\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    families = [\"workfile\",\n                \"usdrender\",\n                \"mantra_rop\",\n                \"karma_rop\",\n                \"redshift_rop\",\n                \"arnold_rop\",\n                \"vray_rop\",\n                \"render.local.hou\",\n                \"publish.hou\"]\n    optional = True\n\n    def process(self, context):\n\n        errored_plugins = get_errored_plugins_from_context(context)\n        if any(\n            plugin.__name__ == \"HoudiniSubmitPublishDeadline\"\n            for plugin in errored_plugins\n        ):\n            raise KnownPublishError(\n                \"Skipping incrementing current file because \"\n                \"submission to deadline failed.\"\n            )\n\n        # Filename must not have changed since collecting.\n        host = registered_host()\n        current_file = host.current_file()\n        if context.data[\"currentFile\"] != current_file:\n            raise KnownPublishError(\n                f\"Collected filename '{context.data['currentFile']}' differs\"\n                f\" from current scene name '{current_file}'.\"\n            )\n\n        new_filepath = version_up(current_file)\n        host.save_workfile(new_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/save_scene.html","title":"save_scene","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/save_scene.html#client.ayon_houdini.plugins.publish.save_scene.SaveCurrentScene","title":"<code>SaveCurrentScene</code>","text":"<p>               Bases: <code>HoudiniContextPlugin</code></p> <p>Save current scene</p> Source code in <code>client/ayon_houdini/plugins/publish/save_scene.py</code> <pre><code>class SaveCurrentScene(plugin.HoudiniContextPlugin):\n    \"\"\"Save current scene\"\"\"\n\n    label = \"Save current file\"\n    order = pyblish.api.ExtractorOrder - 0.49\n\n    def process(self, context):\n\n        # Filename must not have changed since collecting\n        host = registered_host()\n        current_file = host.get_current_workfile()\n        if context.data['currentFile'] != current_file:\n            raise PublishError(\n                f\"Collected filename '{context.data['currentFile']}' differs\"\n                f\" from current scene name '{current_file}'.\",\n                description=self.get_error_description()\n            )\n        if host.workfile_has_unsaved_changes():\n            self.log.info(\"Saving current file: {}\".format(current_file))\n            host.save_workfile(current_file)\n        else:\n            self.log.debug(\"No unsaved changes, skipping file save..\")\n\n\n    def get_error_description(self):\n        return inspect.cleandoc(\n            \"\"\"### Scene File Name Changed During Publishing\n            This error occurs when you validate the scene and then save it as\n            a new file manually, or if you open a new file and continue\n            publishing.\n\n            Please reset the publisher and publish without changing\n            the scene file midway.\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_abc_primitive_to_detail.html","title":"validate_abc_primitive_to_detail","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_abc_primitive_to_detail.html#client.ayon_houdini.plugins.publish.validate_abc_primitive_to_detail.ValidateAbcPrimitiveToDetail","title":"<code>ValidateAbcPrimitiveToDetail</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate Alembic ROP Primitive to Detail attribute is consistent.</p> <p>The Alembic ROP crashes Houdini whenever an attribute in the \"Primitive to Detail\" parameter exists on only a part of the primitives that belong to the same hierarchy path. Whenever it encounters inconsistent values, specifically where some are empty as opposed to others then Houdini crashes. (Tested in Houdini 17.5.229)</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_abc_primitive_to_detail.py</code> <pre><code>class ValidateAbcPrimitiveToDetail(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate Alembic ROP Primitive to Detail attribute is consistent.\n\n    The Alembic ROP crashes Houdini whenever an attribute in the \"Primitive to\n    Detail\" parameter exists on only a part of the primitives that belong to\n    the same hierarchy path. Whenever it encounters inconsistent values,\n    specifically where some are empty as opposed to others then Houdini\n    crashes. (Tested in Houdini 17.5.229)\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder + 0.1\n    families = [\"abc\"]\n    label = \"Validate Primitive to Detail (Abc)\"\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Primitives found with inconsistent primitive \"\n                \"to detail attributes.\",\n                detail=(\n                    \"See log for more info.\"\n                    f\"Incorrect Rop(s)\\n\\n - {invalid[0].path()}\"\n                )\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        import hou  # noqa\n        output_node = instance.data.get(\"output_node\")\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        if output_node is None:\n            cls.log.error(\n                \"SOP Output node in '%s' does not exist. \"\n                \"Ensure a valid SOP output path is set.\" % rop_node.path()\n            )\n\n            return [rop_node]\n\n        pattern = rop_node.parm(\"prim_to_detail_pattern\").eval().strip()\n        if not pattern:\n            cls.log.debug(\n                \"Alembic ROP has no 'Primitive to Detail' pattern. \"\n                \"Validation is ignored..\"\n            )\n            return\n\n        build_from_path = rop_node.parm(\"build_from_path\").eval()\n        if not build_from_path:\n            cls.log.debug(\n                \"Alembic ROP has 'Build from Path' disabled. \"\n                \"Validation is ignored..\"\n            )\n            return\n\n        path_attr = rop_node.parm(\"path_attrib\").eval()\n        if not path_attr:\n            cls.log.error(\n                \"The Alembic ROP node has no Path Attribute\"\n                \"value set, but 'Build Hierarchy from Attribute'\"\n                \"is enabled.\"\n            )\n            return [rop_node]\n\n        # Let's assume each attribute is explicitly named for now and has no\n        # wildcards for Primitive to Detail. This simplifies the check.\n        cls.log.debug(\"Checking Primitive to Detail pattern: %s\" % pattern)\n        cls.log.debug(\"Checking with path attribute: %s\" % path_attr)\n\n        if not hasattr(output_node, \"geometry\"):\n            # In the case someone has explicitly set an Object\n            # node instead of a SOP node in Geometry context\n            # then for now we ignore - this allows us to also\n            # export object transforms.\n            cls.log.warning(\"No geometry output node found, skipping check..\")\n            return\n\n        # Check if the primitive attribute exists\n        frame = instance.data.get(\"frameStart\", 0)\n        geo = output_node.geometryAtFrame(frame)\n\n        # If there are no primitives on the start frame then it might be\n        # something that is emitted over time. As such we can't actually\n        # validate whether the attributes exist, because they won't exist\n        # yet. In that case, just warn the user and allow it.\n        if len(geo.iterPrims()) == 0:\n            cls.log.warning(\n                \"No primitives found on current frame. Validation\"\n                \" for Primitive to Detail will be skipped.\"\n            )\n            return\n\n        attrib = geo.findPrimAttrib(path_attr)\n        if not attrib:\n            cls.log.info(\n                \"Geometry Primitives are missing \"\n                \"path attribute: `%s`\" % path_attr\n            )\n            return [output_node]\n\n        # Ensure at least a single string value is present\n        if not attrib.strings():\n            cls.log.info(\n                \"Primitive path attribute has no \"\n                \"string values: %s\" % path_attr\n            )\n            return [output_node]\n\n        paths = None\n        for attr in pattern.split(\" \"):\n            if not attr.strip():\n                # Ignore empty values\n                continue\n\n            # Check if the primitive attribute exists\n            attrib = geo.findPrimAttrib(attr)\n            if not attrib:\n                # It is allowed to not have the attribute at all\n                continue\n\n            # The issue can only happen if at least one string attribute is\n            # present. So we ignore cases with no values whatsoever.\n            if not attrib.strings():\n                continue\n\n            check = defaultdict(set)\n            values = geo.primStringAttribValues(attr)\n            if paths is None:\n                paths = geo.primStringAttribValues(path_attr)\n\n            for path, value in zip(paths, values):\n                check[path].add(value)\n\n            for path, values in check.items():\n                # Whenever a single path has multiple values for the\n                # Primitive to Detail attribute then we consider it\n                # inconsistent and invalidate the ROP node's content.\n                if len(values) &gt; 1:\n                    cls.log.warning(\n                        \"Path has multiple values: %s (path: %s)\"\n                        % (list(values), path)\n                    )\n                    return [output_node]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_alembic_face_sets.html","title":"validate_alembic_face_sets","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_alembic_face_sets.html#client.ayon_houdini.plugins.publish.validate_alembic_face_sets.ValidateAlembicROPFaceSets","title":"<code>ValidateAlembicROPFaceSets</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate Face Sets are disabled for extraction to pointcache.</p> <p>When groups are saved as Face Sets with the Alembic these show up as shadingEngine connections in Maya - however, with animated groups these connections in Maya won't work as expected, it won't update per frame. Additionally, it can break shader assignments in some cases where it requires to first break this connection to allow a shader to be assigned.</p> <p>It is allowed to include Face Sets, so only an issue is logged to identify that it could introduce issues down the pipeline.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_alembic_face_sets.py</code> <pre><code>class ValidateAlembicROPFaceSets(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate Face Sets are disabled for extraction to pointcache.\n\n    When groups are saved as Face Sets with the Alembic these show up\n    as shadingEngine connections in Maya - however, with animated groups\n    these connections in Maya won't work as expected, it won't update per\n    frame. Additionally, it can break shader assignments in some cases\n    where it requires to first break this connection to allow a shader to\n    be assigned.\n\n    It is allowed to include Face Sets, so only an issue is logged to\n    identify that it could introduce issues down the pipeline.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder + 0.1\n    families = [\"abc\"]\n    label = \"Validate Alembic ROP Face Sets\"\n\n    def process(self, instance):\n\n        rop = hou.node(instance.data[\"instance_node\"])\n        facesets = rop.parm(\"facesets\").eval()\n\n        # 0 = No Face Sets\n        # 1 = Save Non-Empty Groups as Face Sets\n        # 2 = Save All Groups As Face Sets\n        if facesets != 0:\n            self.log.warning(\n                \"Alembic ROP saves 'Face Sets' for Geometry. \"\n                \"Are you sure you want this?\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_alembic_input_node.html","title":"validate_alembic_input_node","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_alembic_input_node.html#client.ayon_houdini.plugins.publish.validate_alembic_input_node.ValidateAlembicInputNode","title":"<code>ValidateAlembicInputNode</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate that the node connected to the output is correct.</p> The connected node cannot be of the following types for Alembic <ul> <li>VDB</li> <li>Volume</li> </ul> Source code in <code>client/ayon_houdini/plugins/publish/validate_alembic_input_node.py</code> <pre><code>class ValidateAlembicInputNode(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate that the node connected to the output is correct.\n\n    The connected node cannot be of the following types for Alembic:\n        - VDB\n        - Volume\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder + 0.1\n    families = [\"abc\"]\n    label = \"Validate Input Node (Abc)\"\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                (\"Primitive types found that are not supported \"\n                 \"for Alembic output.\"),\n                title=self.label\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        invalid_prim_types = [\"VDB\", \"Volume\"]\n        output_node = instance.data.get(\"output_node\")\n\n        if output_node is None:\n            node = hou.node(instance.data[\"instance_node\"])\n            cls.log.error(\n                \"SOP Output node in '%s' does not exist. \"\n                \"Ensure a valid SOP output path is set.\" % node.path()\n            )\n\n            return [node]\n\n        if not hasattr(output_node, \"geometry\"):\n            # In the case someone has explicitly set an Object\n            # node instead of a SOP node in Geometry context\n            # then for now we ignore - this allows us to also\n            # export object transforms.\n            cls.log.warning(\"No geometry output node found, skipping check..\")\n            return\n\n        frame = instance.data.get(\"frameStart\", 0)\n        geo = output_node.geometryAtFrame(frame)\n\n        invalid = False\n        for prim_type in invalid_prim_types:\n            if geo.countPrimType(prim_type) &gt; 0:\n                cls.log.error(\n                    \"Found a primitive which is of type '%s' !\" % prim_type\n                )\n                invalid = True\n\n        if invalid:\n            return [output_node]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_animation_settings.html","title":"validate_animation_settings","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_animation_settings.html#client.ayon_houdini.plugins.publish.validate_animation_settings.ValidateAnimationSettings","title":"<code>ValidateAnimationSettings</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate if the unexpanded string contains the frame ('$F') token</p> <p>This validator will only check the output parameter of the node if the Valid Frame Range is not set to 'Render Current Frame'</p> Rules <p>If you render out a frame range it is mandatory to have the frame token - '$F4' or similar - to ensure that each frame gets written. If this is not the case you will override the same file every time a frame is written out.</p> <p>Examples:</p> <p>Good: 'my_vbd_cache.$F4.vdb' Bad: 'my_vbd_cache.vdb'</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_animation_settings.py</code> <pre><code>class ValidateAnimationSettings(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate if the unexpanded string contains the frame ('$F') token\n\n    This validator will only check the output parameter of the node if\n    the Valid Frame Range is not set to 'Render Current Frame'\n\n    Rules:\n        If you render out a frame range it is mandatory to have the\n        frame token - '$F4' or similar - to ensure that each frame gets\n        written. If this is not the case you will override the same file\n        every time a frame is written out.\n\n    Examples:\n        Good: 'my_vbd_cache.$F4.vdb'\n        Bad: 'my_vbd_cache.vdb'\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Frame Settings\"\n    families = [\"vdbcache\"]\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                f\"Output settings do no match for '{invalid[0].path()}'\"\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        node = hou.node(instance.data[\"instance_node\"])\n        # Check trange parm, 0 means Render Current Frame\n        frame_range = node.evalParm(\"trange\")\n        if frame_range == 0:\n            return\n\n        output_parm = lib.get_output_parameter(node)\n        unexpanded_str = output_parm.unexpandedString()\n\n        if \"$F\" not in unexpanded_str:\n            cls.log.error(\"No frame token found in '%s'\" % node.path())\n            return [node]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_bypass.html","title":"validate_bypass","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_bypass.html#client.ayon_houdini.plugins.publish.validate_bypass.ValidateBypassed","title":"<code>ValidateBypassed</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate all primitives build hierarchy from attribute when enabled.</p> <p>The name of the attribute must exist on the prims and have the same name as Build Hierarchy from Attribute's <code>Path Attribute</code> value on the Alembic ROP node whenever Build Hierarchy from Attribute is enabled.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_bypass.py</code> <pre><code>class ValidateBypassed(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate all primitives build hierarchy from attribute when enabled.\n\n    The name of the attribute must exist on the prims and have the same name\n    as Build Hierarchy from Attribute's `Path Attribute` value on the Alembic\n    ROP node whenever Build Hierarchy from Attribute is enabled.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder - 0.1\n    families = [\"*\"]\n    label = \"Validate ROP Bypass\"\n\n    def process(self, instance):\n\n        if not instance.data.get(\"instance_node\"):\n            # Ignore instances without an instance node\n            # e.g. in memory bootstrap instances\n            self.log.debug(\n                \"Skipping instance without instance node: {}\".format(instance)\n            )\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            rop = invalid[0]\n            raise PublishValidationError(\n                (\"ROP node {} is set to bypass, publishing cannot \"\n                 \"continue.\".format(rop.path())),\n                title=self.label\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        rop = hou.node(instance.data[\"instance_node\"])\n        if hasattr(rop, \"isBypassed\") and rop.isBypassed():\n            return [rop]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_camera_rop.html","title":"validate_camera_rop","text":"<p>Validator plugin for Houdini Camera ROP settings.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_camera_rop.html#client.ayon_houdini.plugins.publish.validate_camera_rop.ValidateCameraROP","title":"<code>ValidateCameraROP</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate Camera ROP settings.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_camera_rop.py</code> <pre><code>class ValidateCameraROP(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate Camera ROP settings.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"camera\"]\n    label = \"Camera ROP\"\n\n    def process(self, instance):\n\n        import hou\n\n        node = hou.node(instance.data.get(\"instance_node\"))\n        if node.parm(\"use_sop_path\").eval():\n            raise PublishValidationError(\n                (\"Alembic ROP for Camera export should not be \"\n                 \"set to 'Use Sop Path'. Please disable.\"),\n                title=self.label\n            )\n\n        # Get the root and objects parameter of the Alembic ROP node\n        root = node.parm(\"root\").eval()\n        objects = node.parm(\"objects\").eval()\n        errors = []\n        if not root:\n            errors.append(\"Root parameter must be set on Alembic ROP\")\n        if not root.startswith(\"/\"):\n            errors.append(\"Root parameter must start with slash /\")\n        if not objects:\n            errors.append(\"Objects parameter must be set on Alembic ROP\")\n        if len(objects.split(\" \")) != 1:\n            errors.append(\"Must have only a single object.\")\n\n        if errors:\n            for error in errors:\n                self.log.error(error)\n            raise PublishValidationError(\n                \"Some checks failed, see validator log.\",\n                title=self.label)\n\n        # Check if the object exists and is a camera\n        path = root + \"/\" + objects\n        camera = hou.node(path)\n\n        if not camera:\n            raise PublishValidationError(\n                \"Camera path does not exist: %s\" % path,\n                title=self.label)\n\n        if camera.type().name() != \"cam\":\n            raise PublishValidationError(\n                (\"Object set in Alembic ROP is not a camera: \"\n                 \"{} (type: {})\").format(camera, camera.type().name()),\n                title=self.label)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_cop_output_node.html","title":"validate_cop_output_node","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_cop_output_node.html#client.ayon_houdini.plugins.publish.validate_cop_output_node.ValidateCopOutputNode","title":"<code>ValidateCopOutputNode</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate the instance COP Output Node.</p> This will ensure <ul> <li>The COP Path is set.</li> <li>The COP Path refers to an existing object.</li> <li>The COP Path node is a COP node.</li> </ul> Source code in <code>client/ayon_houdini/plugins/publish/validate_cop_output_node.py</code> <pre><code>class ValidateCopOutputNode(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate the instance COP Output Node.\n\n    This will ensure:\n        - The COP Path is set.\n        - The COP Path refers to an existing object.\n        - The COP Path node is a COP node.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"imagesequence\"]\n    label = \"Validate COP Output Node\"\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Output node '{}' is incorrect. \"\n                \"See plug-in log for details.\".format(invalid[0].path()),\n                title=self.label,\n                description=(\n                    \"### Invalid COP output node\\n\\n\"\n                    \"The output node path for the instance must be set to a \"\n                    \"valid COP node path.\\n\\nSee the log for more details.\"\n                )\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        output_node = instance.data.get(\"output_node\")\n\n        if not output_node:\n            node = hou.node(instance.data.get(\"instance_node\"))\n            cls.log.error(\n                \"COP Output node in '%s' does not exist. \"\n                \"Ensure a valid COP output path is set.\" % node.path()\n            )\n\n            return [node]\n\n        # Output node must be a Sop node.\n        if not isinstance(output_node, hou.CopNode):\n            cls.log.error(\n                \"Output node %s is not a COP node. \"\n                \"COP Path must point to a COP node, \"\n                \"instead found category type: %s\",\n                output_node.path(), output_node.type().category().name()\n            )\n            return [output_node]\n\n        # For the sake of completeness also assert the category type\n        # is Cop2 to avoid potential edge case scenarios even though\n        # the isinstance check above should be stricter than this category\n        if output_node.type().category().name() != \"Cop2\":\n            cls.log.error(\n                \"Output node %s is not of category Cop2.\", output_node.path()\n            )\n            return [output_node]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_export_is_a_single_frame.html","title":"validate_export_is_a_single_frame","text":"<p>Validator for checking that export is a single frame.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_export_is_a_single_frame.html#client.ayon_houdini.plugins.publish.validate_export_is_a_single_frame.ValidateSingleFrame","title":"<code>ValidateSingleFrame</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate Export is a Single Frame.</p> <p>It checks if rop node is exporting one frame. This is mainly for Model product type.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_export_is_a_single_frame.py</code> <pre><code>class ValidateSingleFrame(plugin.HoudiniInstancePlugin,\n                           OptionalPyblishPluginMixin):\n    \"\"\"Validate Export is a Single Frame.\n\n    It checks if rop node is exporting one frame.\n    This is mainly for Model product type.\n    \"\"\"\n\n    families = [\"model\"]\n    label = \"Validate Single Frame\"\n    order = ValidateContentsOrder + 0.1\n    actions = [SelectInvalidAction]\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"See log for details. \"\n                \"Invalid ROP node: {0}\".format(invalid[0].path())\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        frame_start = instance.data.get(\"frameStartHandle\")\n        frame_end = instance.data.get(\"frameEndHandle\")\n\n        # This happens if instance node has no 'trange' parameter.\n        if frame_start is None or frame_end is None:\n            cls.log.debug(\n                \"No frame data, skipping check..\"\n            )\n            return\n\n        if frame_start != frame_end:\n            rop = hou.node(instance.data[\"instance_node\"])\n            cls.log.error(\n                \"Invalid frame range on '%s'.\"\n                \"You should use the same frame number for 'f1' \"\n                \"and 'f2' parameters.\",\n                rop.path()\n            )\n            return [rop]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_fbx_output_node.html","title":"validate_fbx_output_node","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_fbx_output_node.html#client.ayon_houdini.plugins.publish.validate_fbx_output_node.ValidateFBXOutputNode","title":"<code>ValidateFBXOutputNode</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate the instance Output Node.</p> This will ensure <ul> <li>The Output Node Path is set.</li> <li>The Output Node Path refers to an existing object.</li> <li>The Output Node is a Sop or Obj node.</li> <li>The Output Node has geometry data.</li> <li>The Output Node doesn't include invalid primitive types.</li> </ul> Source code in <code>client/ayon_houdini/plugins/publish/validate_fbx_output_node.py</code> <pre><code>class ValidateFBXOutputNode(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate the instance Output Node.\n\n    This will ensure:\n        - The Output Node Path is set.\n        - The Output Node Path refers to an existing object.\n        - The Output Node is a Sop or Obj node.\n        - The Output Node has geometry data.\n        - The Output Node doesn't include invalid primitive types.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"fbx\"]\n    label = \"Validate FBX Output Node\"\n    actions = [SelectROPAction, SelectInvalidAction]\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            nodes = [n.path() for n in invalid]\n            raise PublishValidationError(\n                \"See log for details. \"\n                \"Invalid nodes: {0}\".format(nodes),\n                title=\"Invalid output node(s)\"\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        output_node = instance.data.get(\"output_node\")\n\n        # Check if The Output Node Path is set and\n        #  refers to an existing object.\n        if output_node is None:\n            rop_node = hou.node(instance.data[\"instance_node\"])\n            cls.log.error(\n                \"Output node in '%s' does not exist. \"\n                \"Ensure a valid output path is set.\", rop_node.path()\n            )\n\n            return [rop_node]\n\n        # Check if the Output Node is a Sop or an Obj node\n        #  also, list all sop output nodes inside as well as\n        #  invalid empty nodes.\n        all_out_sops = []\n        invalid = []\n\n        # if output_node is an ObjSubnet or an ObjNetwork\n        if output_node.childTypeCategory() == hou.objNodeTypeCategory():\n            for node in output_node.allSubChildren():\n                if node.type().name() == \"geo\":\n                    out = get_obj_node_output(node)\n                    if out:\n                        all_out_sops.append(out)\n                    else:\n                        invalid.append(node)  # empty_objs\n                        cls.log.error(\n                            \"Geo Obj Node '%s' is empty!\",\n                            node.path()\n                        )\n            if not all_out_sops:\n                invalid.append(output_node)  # empty_objs\n                cls.log.error(\n                    \"Output Node '%s' is empty!\",\n                    node.path()\n                )\n\n        # elif output_node is an ObjNode\n        elif output_node.type().name() == \"geo\":\n            out = get_obj_node_output(output_node)\n            if out:\n                all_out_sops.append(out)\n            else:\n                invalid.append(node)  # empty_objs\n                cls.log.error(\n                    \"Output Node '%s' is empty!\",\n                    node.path()\n                )\n\n        # elif output_node is a SopNode\n        elif output_node.type().category().name() == \"Sop\":\n            all_out_sops.append(output_node)\n\n        # Then it's a wrong node type\n        else:\n            cls.log.error(\n                \"Output node %s is not a SOP or OBJ Geo or OBJ SubNet node. \"\n                \"Instead found category type: %s %s\",\n                output_node.path(), output_node.type().category().name(),\n                output_node.type().name()\n            )\n            return [output_node]\n\n        # Check if all output sop nodes have geometry\n        #  and don't contain invalid prims\n        invalid_prim_types = [\"VDB\", \"Volume\"]\n        for sop_node in all_out_sops:\n            # Empty Geometry test\n            if not hasattr(sop_node, \"geometry\"):\n                invalid.append(sop_node)  # empty_geometry\n                cls.log.error(\n                    \"Sop node '%s' doesn't include any prims.\",\n                    sop_node.path()\n                )\n                continue\n\n            frame = instance.data.get(\"frameStart\", 0)\n            geo = sop_node.geometryAtFrame(frame)\n            if len(geo.iterPrims()) == 0:\n                invalid.append(sop_node)  # empty_geometry\n                cls.log.error(\n                    \"Sop node '%s' doesn't include any prims.\",\n                    sop_node.path()\n                )\n                continue\n\n            # Invalid Prims test\n            for prim_type in invalid_prim_types:\n                if geo.countPrimType(prim_type) &gt; 0:\n                    invalid.append(sop_node)  # invalid_prims\n                    cls.log.error(\n                        \"Sop node '%s' includes invalid prims of type '%s'.\",\n                        sop_node.path(), prim_type\n                    )\n\n        if invalid:\n            return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_file_extension.html","title":"validate_file_extension","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_file_extension.html#client.ayon_houdini.plugins.publish.validate_file_extension.ValidateFileExtension","title":"<code>ValidateFileExtension</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate the output file extension fits the output family.</p> File extensions <ul> <li>Pointcache must be .abc</li> <li>Camera must be .abc</li> <li>VDB must be .vdb</li> </ul> Source code in <code>client/ayon_houdini/plugins/publish/validate_file_extension.py</code> <pre><code>class ValidateFileExtension(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate the output file extension fits the output family.\n\n    File extensions:\n        - Pointcache must be .abc\n        - Camera must be .abc\n        - VDB must be .vdb\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"camera\", \"vdbcache\"]\n    label = \"Output File Extension\"\n\n    family_extensions = {\n        \"camera\": \".abc\",\n        \"vdbcache\": \".vdb\",\n    }\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                f\"ROP node has incorrect file extension: {invalid[0].path()}\",\n                title=self.label\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        # Get ROP node from instance\n        node = hou.node(instance.data[\"instance_node\"])\n\n        # Create lookup for current family in instance\n        families = []\n        product_type = instance.data.get(\"productType\")\n        if product_type:\n            families.append(product_type)\n        families = set(families)\n\n        # Perform extension check\n        output = lib.get_output_parameter(node).eval()\n        _, output_extension = os.path.splitext(output)\n\n        for family in families:\n            extension = cls.family_extensions.get(family, None)\n            if extension is None:\n                raise PublishValidationError(\n                    \"Unsupported family: {}\".format(family),\n                    title=cls.label)\n\n            if output_extension != extension:\n                return [node]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_frame_range.html","title":"validate_frame_range","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_frame_range.html#client.ayon_houdini.plugins.publish.validate_frame_range.ValidateFrameRange","title":"<code>ValidateFrameRange</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate Frame Range.</p> <p>Due to the usage of start and end handles, then Frame Range must be &gt;= (start handle + end handle) which results that frameEnd be smaller than frameStart</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_frame_range.py</code> <pre><code>class ValidateFrameRange(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate Frame Range.\n\n    Due to the usage of start and end handles,\n    then Frame Range must be &gt;= (start handle + end handle)\n    which results that frameEnd be smaller than frameStart\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder - 0.1\n    label = \"Validate Frame Range\"\n    actions = [DisableUseTaskHandlesAction, SelectInvalidAction]\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                title=\"Invalid Frame Range\",\n                message=(\n                    \"Invalid frame range because the instance \"\n                    \"start frame ({0[frameStart]}) is higher than \"\n                    \"the end frame ({0[frameEnd]})\"\n                    .format(instance.data)\n                ),\n                description=(\n                    \"## Invalid Frame Range\\n\"\n                    \"The frame range for the instance is invalid because \"\n                    \"the start frame is higher than the end frame.\\n\\nThis \"\n                    \"is likely due to task handles being applied to your \"\n                    \"instance or the ROP node's start frame \"\n                    \"is set higher than the end frame.\\n\\nIf your ROP frame \"\n                    \"range is correct and you do not want to apply task \"\n                    \"handles make sure to disable Use task handles on the \"\n                    \"publish instance.\"\n                )\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        if not instance.data.get(\"instance_node\"):\n            return\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        frame_start = instance.data.get(\"frameStart\")\n        frame_end = instance.data.get(\"frameEnd\")\n\n        if frame_start is None or frame_end is None:\n            cls.log.debug(\n                \"Skipping frame range validation for \"\n                \"instance without frame data: {}\".format(rop_node.path())\n            )\n            return\n\n        if frame_start &gt; frame_end:\n            cls.log.info(\n                \"The ROP node render range is set to \"\n                \"{0[frameStartHandle]} - {0[frameEndHandle]} \"\n                \"The task handles applied to the instance are start handle \"\n                \"{0[handleStart]} and end handle {0[handleEnd]}\"\n                .format(instance.data)\n            )\n            return [rop_node]\n\n    @classmethod\n    def repair(cls, instance):\n\n        if not cls.get_invalid(instance):\n            # Already fixed\n            return\n\n        # Disable use task handles\n        context = instance.context\n        create_context = context.data[\"create_context\"]\n        instance_id = instance.data.get(\"instance_id\")\n        if not instance_id:\n            cls.log.debug(\"'{}' must have instance id\"\n                          .format(instance))\n            return\n\n        created_instance = create_context.get_instance_by_id(instance_id)\n        if not instance_id:\n            cls.log.debug(\"Unable to find instance '{}' by id\"\n                          .format(instance))\n            return\n\n        created_instance.publish_attributes[\"CollectAssetHandles\"][\"use_handles\"] = False  # noqa\n\n        create_context.save_changes()\n        cls.log.debug(\"use task handles is turned off for '{}'\"\n                      .format(instance))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_frame_range_frames_to_fix.html","title":"validate_frame_range_frames_to_fix","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_frame_range_frames_to_fix.html#client.ayon_houdini.plugins.publish.validate_frame_range_frames_to_fix.ValidateFrameRangeFramesToFix","title":"<code>ValidateFrameRangeFramesToFix</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate Frame Range Frames to Fix.</p> <p>This validator checks if the rop node covers the entire frame range, including any frames that require correction. It also verifies the absence of gaps within the specified frames to fix.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_frame_range_frames_to_fix.py</code> <pre><code>class ValidateFrameRangeFramesToFix(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate Frame Range Frames to Fix.\n\n    This validator checks if the rop node covers the entire frame\n    range, including any frames that require correction.\n    It also verifies the absence of gaps within the specified frames to fix.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Frame Range Frames to Fix\"\n    actions = [SelectROPAction]\n\n    def process(self, instance):\n\n        if not instance.data.get(\"instance_node\"):\n            return\n\n        frames_to_fix: str = instance.data.get(\"frames_to_fix\", \"\")\n        if not frames_to_fix:\n            self.log.debug(\"Skipping Validation, no frames to fix.\")\n            return\n\n        # Skip instances that are set to not be integrated so we ignore\n        # the original `render` instance from which local AOV instances are\n        # spawned off.\n        if not instance.data.get(\"integrate\", True):\n            return\n\n        frame_start = instance.data[\"frameStartHandle\"]\n        frame_end = instance.data[\"frameEndHandle\"]\n\n        # Get the frame range from 'frames to fix'\n        try:\n            collection = clique.parse(frames_to_fix, \"{ranges}\")\n        except ValueError:\n            # Invalid frame pattern entered\n            raise PublishValidationError(\n                f\"Invalid frames to fix pattern: '{frames_to_fix}'\",\n                description=(\n                    \"The frames to fix pattern specified is invalid. It must \"\n                    \"be of the form `5,10-15`.\\n\\n\"\n                    \"The pattern must be a comma-separated list of frames or \"\n                    \"frame ranges. A frame is a whole number, like `5`, and a \"\n                    \"frame range is two whole numbers separated by a hyphen, \"\n                    \"like `5-10` indicating the frames `5,6,7,8,9,10`.\"\n                )\n            )\n\n        fix_frames: \"list[int]\" = list(collection)\n        fix_frame_start = int(fix_frames[0])\n        fix_frame_end = int(fix_frames[-1])\n\n        # Check if ROP frame range covers the frames to fix.\n        # Title and message are the same for the next two checks.\n        invalid_range = False\n        if frame_start &gt; fix_frame_start:\n            self.log.error(\n                \"Start frame should be smaller than or equal to the first \"\n                \"frame to fix. Set the start frame to the first frame to fix: \"\n                f\"{fix_frame_start}.\"\n            )\n            invalid_range = True\n\n        if frame_end &lt; fix_frame_end:\n            self.log.error(\n                \"End frame should be greater than or equal to the last frame \"\n                \"to fix. Set the end frame to the last frame to fix: \"\n                f\"{fix_frame_end}.\"\n            )\n            invalid_range = True\n\n        if invalid_range:\n            raise PublishValidationError(\n                \"Invalid Rop Frame Range\",\n                description=(\n                    \"## Invalid Rop Frame Range\\n\"\n                    \"Invalid frame range because the instance frame range \"\n                    \"[{0[frameStart]} - {0[frameEnd]}] doesn't cover \"\n                    \"the frames to fix [{0[frames_to_fix]}].\"\n                    .format(instance.data)\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_frame_token.html","title":"validate_frame_token","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_frame_token.html#client.ayon_houdini.plugins.publish.validate_frame_token.ValidateFrameToken","title":"<code>ValidateFrameToken</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate if the unexpanded string contains the frame ('$F') token.</p> <p>This validator will only check the output parameter of the node if the Valid Frame Range is not set to 'Render Current Frame'</p> Rules <p>If you render out a frame range it is mandatory to have the frame token - '$F4' or similar - to ensure that each frame gets written. If this is not the case you will override the same file every time a frame is written out.</p> <p>Examples:</p> <p>Good: 'my_vbd_cache.$F4.vdb' Bad: 'my_vbd_cache.vdb'</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_frame_token.py</code> <pre><code>class ValidateFrameToken(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate if the unexpanded string contains the frame ('$F') token.\n\n    This validator will *only* check the output parameter of the node if\n    the Valid Frame Range is not set to 'Render Current Frame'\n\n    Rules:\n        If you render out a frame range it is mandatory to have the\n        frame token - '$F4' or similar - to ensure that each frame gets\n        written. If this is not the case you will override the same file\n        every time a frame is written out.\n\n    Examples:\n        Good: 'my_vbd_cache.$F4.vdb'\n        Bad: 'my_vbd_cache.vdb'\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Frame Token\"\n    families = [\"vdbcache\"]\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                f\"Output settings do no match for '{invalid[0].path()}'\"\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        node = hou.node(instance.data[\"instance_node\"])\n        # Check trange parm, 0 means Render Current Frame\n        frame_range = node.evalParm(\"trange\")\n        if frame_range == 0:\n            return\n\n        output_parm = lib.get_output_parameter(node)\n        unexpanded_str = output_parm.unexpandedString()\n\n        if \"$F\" not in unexpanded_str:\n            cls.log.error(\"No frame token found in '%s'\" % node.path())\n            return [node]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_houdini_license_category.html","title":"validate_houdini_license_category","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_houdini_license_category.html#client.ayon_houdini.plugins.publish.validate_houdini_license_category.ValidateHoudiniNotApprenticeLicense","title":"<code>ValidateHoudiniNotApprenticeLicense</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate the Houdini instance runs a non Apprentice license.</p> USD ROPs <p>When extracting USD files from an apprentice Houdini license, the resulting files will get \"scrambled\" with a license protection and get a special .usdnc suffix.</p> <p>This currently breaks the Subset/representation pipeline so we disallow any publish with apprentice license.</p> Alembic ROPs <p>Houdini Apprentice does not export Alembic.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_houdini_license_category.py</code> <pre><code>class ValidateHoudiniNotApprenticeLicense(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate the Houdini instance runs a non Apprentice license.\n\n    USD ROPs:\n        When extracting USD files from an apprentice Houdini license,\n        the resulting files will get \"scrambled\" with a license protection\n        and get a special .usdnc suffix.\n\n        This currently breaks the Subset/representation pipeline so we disallow\n        any publish with apprentice license.\n\n    Alembic ROPs:\n        Houdini Apprentice does not export Alembic.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrop\", \"abc\", \"fbx\", \"camera\"]\n    label = \"Houdini Apprentice License\"\n\n    def process(self, instance):\n\n        if hou.isApprentice():\n            # Find which family was matched with the plug-in\n            families = {instance.data[\"productType\"]}\n            families.update(instance.data.get(\"families\", []))\n            disallowed_families = families.intersection(self.families)\n            families = \" \".join(sorted(disallowed_families)).title()\n\n            raise PublishValidationError(\n                \"{} publishing requires a non apprentice license.\"\n                .format(families),\n                title=self.label)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_instance_in_context.html","title":"validate_instance_in_context","text":"<p>Validate if instance asset is the same as context asset.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_instance_in_context.html#client.ayon_houdini.plugins.publish.validate_instance_in_context.ValidateInstanceInContextHoudini","title":"<code>ValidateInstanceInContextHoudini</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validator to check if instance asset match context asset.</p> <p>When working in per-shot style you always publish data in context of current asset (shot). This validator checks if this is so. It is optional so it can be disabled when needed.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_instance_in_context.py</code> <pre><code>class ValidateInstanceInContextHoudini(plugin.HoudiniInstancePlugin,\n                                       OptionalPyblishPluginMixin):\n    \"\"\"Validator to check if instance asset match context asset.\n\n    When working in per-shot style you always publish data in context of\n    current asset (shot). This validator checks if this is so. It is optional\n    so it can be disabled when needed.\n    \"\"\"\n    # Similar to maya-equivalent `ValidateInstanceInContext`\n\n    order = ValidateContentsOrder\n    label = \"Instance in same Context\"\n    optional = True\n    actions = [SelectROPAction, RepairAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        attr_values = self.get_attr_values_from_data(instance.data)\n        if not attr_values and not instance.data.get(\"instance_node\"):\n            # Skip instances that do not have the attr values because that\n            # hints these are runtime-instances, like e.g. USD layer\n            # contributions. We will confirm that by checking these do not\n            # have an instance node. We do not need to check these because they\n            # 'spawn off' from an original instance that has the check itself.\n            return\n\n        folder_path = instance.data.get(\"folderPath\")\n        task = instance.data.get(\"task\")\n        context = self.get_context(instance)\n        if (folder_path, task) != context:\n            context_label = \"{} &gt; {}\".format(*context)\n            instance_label = \"{} &gt; {}\".format(folder_path, task)\n\n            raise PublishValidationError(\n                message=(\n                    \"Instance '{}' publishes to different asset than current \"\n                    \"context: {}. Current context: {}\".format(\n                        instance.name, instance_label, context_label\n                    )\n                ),\n                description=(\n                    \"## Publishing to a different asset\\n\"\n                    \"There are publish instances present which are publishing \"\n                    \"into a different asset than your current context.\\n\\n\"\n                    \"Usually this is not what you want but there can be cases \"\n                    \"where you might want to publish into another asset or \"\n                    \"shot. If that's the case you can disable the validation \"\n                    \"on the instance to ignore it.\"\n                )\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        context_folder, context_task = cls.get_context(instance)\n\n        create_context = instance.context.data[\"create_context\"]\n        instance_id = instance.data[\"instance_id\"]\n        created_instance = create_context.get_instance_by_id(\n            instance_id\n        )\n        created_instance[\"folderPath\"] = context_folder\n        created_instance[\"task\"] = context_task\n        create_context.save_changes()\n\n    @staticmethod\n    def get_context(instance):\n        \"\"\"Return folderPath, task from publishing context data\"\"\"\n        context = instance.context\n        return context.data[\"folderPath\"], context.data[\"task\"]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_instance_in_context.html#client.ayon_houdini.plugins.publish.validate_instance_in_context.ValidateInstanceInContextHoudini.get_context","title":"<code>get_context(instance)</code>  <code>staticmethod</code>","text":"<p>Return folderPath, task from publishing context data</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_instance_in_context.py</code> <pre><code>@staticmethod\ndef get_context(instance):\n    \"\"\"Return folderPath, task from publishing context data\"\"\"\n    context = instance.context\n    return context.data[\"folderPath\"], context.data[\"task\"]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_mesh_is_static.html","title":"validate_mesh_is_static","text":"<p>Validator for correct naming of Static Meshes.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_mesh_is_static.html#client.ayon_houdini.plugins.publish.validate_mesh_is_static.ValidateMeshIsStatic","title":"<code>ValidateMeshIsStatic</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate mesh is static.</p> <p>It checks if output node is time dependent. this avoids getting different output from ROP node when extracted from a different frame than the first frame. (Might be overly restrictive though)</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_mesh_is_static.py</code> <pre><code>class ValidateMeshIsStatic(plugin.HoudiniInstancePlugin,\n                           OptionalPyblishPluginMixin):\n    \"\"\"Validate mesh is static.\n\n    It checks if output node is time dependent.\n    this avoids getting different output from ROP node when extracted\n    from a different frame than the first frame.\n    (Might be overly restrictive though)\n    \"\"\"\n\n    families = [\"staticMesh\",\n                \"model\"]\n    label = \"Validate Mesh is Static\"\n    order = ValidateContentsOrder + 0.1\n    actions = [SelectInvalidAction]\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            nodes = [n.path() for n in invalid]\n            raise PublishValidationError(\n                \"See log for details. \"\n                \"Invalid nodes: {0}\".format(nodes)\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        invalid = []\n\n        output_node = instance.data.get(\"output_node\")\n        if output_node is None:\n            cls.log.debug(\n                \"No Output Node, skipping check..\"\n            )\n            return\n\n        all_outputs = get_output_children(output_node)\n\n        for output in all_outputs:\n            if output.isTimeDependent():\n                invalid.append(output)\n                cls.log.error(\n                    \"Output node '%s' is time dependent.\",\n                    output.path()\n                )\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_mkpaths_toggled.html","title":"validate_mkpaths_toggled","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_mkpaths_toggled.html#client.ayon_houdini.plugins.publish.validate_mkpaths_toggled.ValidateIntermediateDirectoriesChecked","title":"<code>ValidateIntermediateDirectoriesChecked</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate Create Intermediate Directories is enabled on ROP node.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_mkpaths_toggled.py</code> <pre><code>class ValidateIntermediateDirectoriesChecked(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate Create Intermediate Directories is enabled on ROP node.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"pointcache\", \"camera\", \"vdbcache\", \"model\"]\n    label = \"Create Intermediate Directories Checked\"\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            nodes = \"\\n\".join(f\"- {node.path()}\" for node in invalid)\n            raise PublishValidationError(\n                (\"Found ROP node with Create Intermediate \"\n                 \"Directories turned off:\\n {}\".format(nodes)),\n                title=self.label)\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        result = []\n\n        for node in instance[:]:\n            if node.parm(\"mkpath\").eval() != 1:\n                cls.log.error(\"Invalid settings found on `%s`\" % node.path())\n                result.append(node)\n\n        return result\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_no_errors.html","title":"validate_no_errors","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_no_errors.html#client.ayon_houdini.plugins.publish.validate_no_errors.ValidateNoErrors","title":"<code>ValidateNoErrors</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate the Instance has no current cooking errors.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_no_errors.py</code> <pre><code>class ValidateNoErrors(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate the Instance has no current cooking errors.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate no errors\"\n\n    def process(self, instance):\n\n        if not instance.data.get(\"instance_node\"):\n            self.log.debug(\n                \"Skipping 'Validate no errors' because instance \"\n                \"has no instance node: {}\".format(instance)\n            )\n            return\n\n        validate_nodes = []\n\n        if len(instance) &gt; 0:\n            validate_nodes.append(hou.node(instance.data.get(\"instance_node\")))\n        output_node = instance.data.get(\"output_node\")\n        if output_node:\n            validate_nodes.append(output_node)\n\n        for node in validate_nodes:\n            self.log.debug(\"Validating for errors: %s\" % node.path())\n            errors = get_errors(node)\n\n            if errors:\n                # If there are current errors, then try an unforced cook\n                # to see whether the error will disappear.\n                self.log.debug(\n                    \"Recooking to revalidate error \"\n                    \"is up to date for: %s\" % node.path()\n                )\n                current_frame = hou.intFrame()\n                start = instance.data.get(\"frameStart\", current_frame)\n                end = instance.data.get(\"frameEnd\", current_frame)\n                cook_in_range(node, start=start, end=end)\n\n            # Check for errors again after the forced recook\n            errors = get_errors(node)\n            if errors:\n                self.log.error(errors)\n                raise PublishValidationError(\n                    \"Node has errors: {}\".format(node.path()),\n                    title=self.label)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_no_errors.html#client.ayon_houdini.plugins.publish.validate_no_errors.get_errors","title":"<code>get_errors(node)</code>","text":"<p>Get cooking errors.</p> <p>If node already has errors check whether it needs to recook If so, then recook first to see if that solves it.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_no_errors.py</code> <pre><code>def get_errors(node):\n    \"\"\"Get cooking errors.\n\n    If node already has errors check whether it needs to recook\n    If so, then recook first to see if that solves it.\n\n    \"\"\"\n    if node.errors() and node.needsToCook():\n        node.cook()\n\n    return node.errors()\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_primitive_hierarchy_paths.html","title":"validate_primitive_hierarchy_paths","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_primitive_hierarchy_paths.html#client.ayon_houdini.plugins.publish.validate_primitive_hierarchy_paths.ValidatePrimitiveHierarchyPaths","title":"<code>ValidatePrimitiveHierarchyPaths</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate all primitives build hierarchy from attribute when enabled.</p> <p>The name of the attribute must exist on the prims and have the same name as Build Hierarchy from Attribute's <code>Path Attribute</code> value on the Alembic ROP node whenever Build Hierarchy from Attribute is enabled.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_primitive_hierarchy_paths.py</code> <pre><code>class ValidatePrimitiveHierarchyPaths(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate all primitives build hierarchy from attribute when enabled.\n\n    The name of the attribute must exist on the prims and have the same name\n    as Build Hierarchy from Attribute's `Path Attribute` value on the Alembic\n    ROP node whenever Build Hierarchy from Attribute is enabled.\n\n    \"\"\"\n\n    order = ValidateContentsOrder + 0.1\n    families = [\"abc\"]\n    label = \"Validate Prims Hierarchy Path\"\n    actions = [AddDefaultPathAction]\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            nodes = [n.path() for n in invalid]\n            raise PublishValidationError(\n                \"See log for details. \" \"Invalid nodes: {0}\".format(nodes),\n                title=self.label\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        output_node = instance.data.get(\"output_node\")\n        rop_node = hou.node(instance.data[\"instance_node\"])\n\n        if output_node is None:\n            cls.log.error(\n                \"SOP Output node in '%s' does not exist. \"\n                \"Ensure a valid SOP output path is set.\", rop_node.path()\n            )\n\n            return [rop_node]\n\n        build_from_path = rop_node.parm(\"build_from_path\").eval()\n        if not build_from_path:\n            cls.log.debug(\n                \"Alembic ROP has 'Build from Path' disabled. \"\n                \"Validation is ignored..\"\n            )\n            return\n\n        path_attr = rop_node.parm(\"path_attrib\").eval()\n        if not path_attr:\n            cls.log.error(\n                \"The Alembic ROP node has no Path Attribute\"\n                \"value set, but 'Build Hierarchy from Attribute'\"\n                \"is enabled.\"\n            )\n            return [rop_node]\n\n        cls.log.debug(\"Checking for attribute: %s\", path_attr)\n\n        if not hasattr(output_node, \"geometry\"):\n            # In the case someone has explicitly set an Object\n            # node instead of a SOP node in Geometry context\n            # then for now we ignore - this allows us to also\n            # export object transforms.\n            cls.log.warning(\"No geometry output node found, skipping check..\")\n            return\n\n        # Check if the primitive attribute exists\n        frame = instance.data.get(\"frameStart\", 0)\n        geo = output_node.geometryAtFrame(frame)\n\n        # If there are no primitives on the current frame then we can't\n        # check whether the path names are correct. So we'll just issue a\n        # warning that the check can't be done consistently and skip\n        # validation.\n        if len(geo.iterPrims()) == 0:\n            cls.log.warning(\n                \"No primitives found on current frame. Validation\"\n                \" for primitive hierarchy paths will be skipped,\"\n                \" thus can't be validated.\"\n            )\n            return\n\n        # Check if there are any values for the primitives\n        attrib = geo.findPrimAttrib(path_attr)\n        if not attrib:\n            cls.log.info(\n                \"Geometry Primitives are missing \"\n                \"path attribute: `%s`\", path_attr\n            )\n            return [output_node]\n\n        # Ensure at least a single string value is present\n        if not attrib.strings():\n            cls.log.info(\n                \"Primitive path attribute has no \"\n                \"string values: %s\", path_attr\n            )\n            return [output_node]\n\n        paths = geo.primStringAttribValues(path_attr)\n        # Ensure all primitives are set to a valid path\n        # Collect all invalid primitive numbers\n        invalid_prims = [i for i, path in enumerate(paths) if not path]\n        if invalid_prims:\n            num_prims = len(geo.iterPrims())  # faster than len(geo.prims())\n            cls.log.info(\n                \"Prims have no value for attribute `%s` \"\n                \"(%s of %s prims)\", path_attr, len(invalid_prims), num_prims\n            )\n            return [output_node]\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Add a default path attribute Action.\n\n        It is a helper action more than a repair action,\n        used to add a default single value for the path.\n        \"\"\"\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        output_node = rop_node.parm(\"sop_path\").evalAsNode()\n\n        if not output_node:\n            cls.log.debug(\n                \"Action isn't performed, invalid SOP Path on %s\",\n                rop_node\n            )\n            return\n\n        # This check to prevent the action from running multiple times.\n        # git_invalid only returns [output_node] when\n        #   path attribute is the problem\n        if cls.get_invalid(instance) != [output_node]:\n            return\n\n        path_attr = rop_node.parm(\"path_attrib\").eval()\n\n        path_node = output_node.parent().createNode(\"name\", \"AUTO_PATH\")\n        path_node.parm(\"attribname\").set(path_attr)\n        path_node.parm(\"name1\").set('`opname(\"..\")`/`opname(\"..\")`Shape')\n\n        cls.log.debug(\n            \"'%s' was created. It adds '%s' with a default single value\",\n            path_node, path_attr\n        )\n\n        path_node.setGenericFlag(hou.nodeFlag.DisplayComment, True)\n        path_node.setComment(\n            'Auto path node was created automatically by '\n            '\"Add a default path attribute\"'\n            '\\nFeel free to modify or replace it.'\n        )\n\n        if output_node.type().name() in [\"null\", \"output\"]:\n            # Connect before\n            path_node.setFirstInput(output_node.input(0))\n            path_node.moveToGoodPosition()\n            output_node.setFirstInput(path_node)\n            output_node.moveToGoodPosition()\n        else:\n            # Connect after\n            path_node.setFirstInput(output_node)\n            rop_node.parm(\"sop_path\").set(path_node.path())\n            path_node.moveToGoodPosition()\n\n            cls.log.debug(\n                \"SOP path on '%s' updated to new output node '%s'\",\n                rop_node, path_node\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_primitive_hierarchy_paths.html#client.ayon_houdini.plugins.publish.validate_primitive_hierarchy_paths.ValidatePrimitiveHierarchyPaths.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Add a default path attribute Action.</p> <p>It is a helper action more than a repair action, used to add a default single value for the path.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_primitive_hierarchy_paths.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Add a default path attribute Action.\n\n    It is a helper action more than a repair action,\n    used to add a default single value for the path.\n    \"\"\"\n\n    rop_node = hou.node(instance.data[\"instance_node\"])\n    output_node = rop_node.parm(\"sop_path\").evalAsNode()\n\n    if not output_node:\n        cls.log.debug(\n            \"Action isn't performed, invalid SOP Path on %s\",\n            rop_node\n        )\n        return\n\n    # This check to prevent the action from running multiple times.\n    # git_invalid only returns [output_node] when\n    #   path attribute is the problem\n    if cls.get_invalid(instance) != [output_node]:\n        return\n\n    path_attr = rop_node.parm(\"path_attrib\").eval()\n\n    path_node = output_node.parent().createNode(\"name\", \"AUTO_PATH\")\n    path_node.parm(\"attribname\").set(path_attr)\n    path_node.parm(\"name1\").set('`opname(\"..\")`/`opname(\"..\")`Shape')\n\n    cls.log.debug(\n        \"'%s' was created. It adds '%s' with a default single value\",\n        path_node, path_attr\n    )\n\n    path_node.setGenericFlag(hou.nodeFlag.DisplayComment, True)\n    path_node.setComment(\n        'Auto path node was created automatically by '\n        '\"Add a default path attribute\"'\n        '\\nFeel free to modify or replace it.'\n    )\n\n    if output_node.type().name() in [\"null\", \"output\"]:\n        # Connect before\n        path_node.setFirstInput(output_node.input(0))\n        path_node.moveToGoodPosition()\n        output_node.setFirstInput(path_node)\n        output_node.moveToGoodPosition()\n    else:\n        # Connect after\n        path_node.setFirstInput(output_node)\n        rop_node.parm(\"sop_path\").set(path_node.path())\n        path_node.moveToGoodPosition()\n\n        cls.log.debug(\n            \"SOP path on '%s' updated to new output node '%s'\",\n            rop_node, path_node\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_render_product_paths_unique.html","title":"validate_render_product_paths_unique","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_render_product_paths_unique.html#client.ayon_houdini.plugins.publish.validate_render_product_paths_unique.ValidateRenderProductPathsUnique","title":"<code>ValidateRenderProductPathsUnique</code>","text":"<p>               Bases: <code>HoudiniContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that render product paths are unique.</p> <p>This allows to catch before rendering whether multiple render ROPs would end up writing to the same filepaths. This can be a problem when rendering because each render job would overwrite the files of the other at rendertime.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_render_product_paths_unique.py</code> <pre><code>class ValidateRenderProductPathsUnique(plugin.HoudiniContextPlugin,\n                                       OptionalPyblishPluginMixin):\n    \"\"\"Validate that render product paths are unique.\n\n    This allows to catch before rendering whether multiple render ROPs would\n    end up writing to the same filepaths. This can be a problem when rendering\n    because each render job would overwrite the files of the other at\n    rendertime.\n\n    \"\"\"\n    order = pyblish.api.ValidatorOrder\n    families = [\n        # Render products\n        \"usdrender\", \"karma_rop\", \"redshift_rop\", \"arnold_rop\", \"mantra_rop\",\n\n        # Product families from collect frames plug-in\n        \"camera\", \"vdbcache\", \"imagesequence\", \"ass\", \"redshiftproxy\",\n        \"review\", \"pointcache\", \"fbx\", \"model\"\n    ]\n\n    hosts = [\"houdini\"]\n    label = \"Unique Render Product Paths\"\n    actions = [SelectInvalidAction]\n    optional = True\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        invalid = self.get_invalid(context)\n        if not invalid:\n            return\n\n        node_paths = [node.path() for node in invalid]\n        node_paths.sort()\n        invalid_list = \"\\n\".join(f\"- {path}\" for path in node_paths)\n        raise PublishValidationError(\n            \"Multiple instances render to the same path. \"\n            \"Please make sure each ROP renders to a unique output path:\\n\"\n            f\"{invalid_list}\",\n            title=self.label,\n            description=self.get_description()\n        )\n\n    @classmethod\n    def get_invalid(cls, context) -&gt; \"Optional[List[hou.Node]]\":\n        # Get instances matching this plugin families\n        instances = pyblish.api.instances_by_plugin(list(context), cls)\n        if not instances:\n            return\n\n        # Get expected rendered filepaths\n        paths_to_instance_id = defaultdict(list)\n        for instance in instances:\n            # Skip the original instance when local rendering and those have\n            # created additional runtime instances per AOV. This avoids\n            # validating similar instances multiple times.\n            if not instance.data.get(\"integrate\", True):\n                continue\n\n            for filepath in get_instance_expected_files(instance):\n                paths_to_instance_id[filepath].append(instance.id)\n\n        # Get invalid instances by instance.id\n        invalid_instance_ids = set()\n        invalid_paths = []\n        for path, path_instance_ids in paths_to_instance_id.items():\n            if len(path_instance_ids) &gt; 1:\n                for path_instance_d in path_instance_ids:\n                    invalid_instance_ids.add(path_instance_d)\n                invalid_paths.append(path)\n\n        if not invalid_instance_ids:\n            return\n\n        # Log invalid sequences as single collection\n        collections, remainder = clique.assemble(invalid_paths)\n        for collection in collections:\n            cls.log.warning(f\"Multiple instances output to path: {collection}\")\n        for path in remainder:\n            cls.log.warning(f\"Multiple instances output to path: {path}\")\n\n        # Get the invalid instances so we could also add a select action.\n        invalid = []\n        for instance in [\n            instance for instance in instances\n            if instance.id in invalid_instance_ids\n        ]:\n            node = hou.node(instance.data[\"instance_node\"])\n            invalid.append(node)\n\n        return invalid\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"### Output paths overwrite each other\n\n            Multiple instances output to the same path. This can cause each\n            render to overwrite the other providing unexpected results.\n\n            Update the output paths to be unique across all instances.\n\n            It may be the case that a single instance outputs multiple files\n            that overwrite each other, like separate AOV outputs from one ROP.\n            In that case it may be necessary to update the individual AOV\n            output paths, instead of outputs between separate instances.\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_render_product_paths_unique.html#client.ayon_houdini.plugins.publish.validate_render_product_paths_unique.get_instance_expected_files","title":"<code>get_instance_expected_files(instance)</code>","text":"<p>Get the expected source render files for the instance.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_render_product_paths_unique.py</code> <pre><code>def get_instance_expected_files(instance: pyblish.api.Instance) -&gt; List[str]:\n    \"\"\"Get the expected source render files for the instance.\"\"\"\n    # Prefer 'expectedFiles' over 'frames' because it usually contains more\n    # output files than just a single file or single sequence of files.\n    expected_files: List[Dict[str, List[str]]] = (\n        instance.data.get(\"expectedFiles\", [])\n    )\n    filepaths: List[str] = []\n    if expected_files:\n        # Products with expected files\n        # This can be Render products or submitted cache to farm.\n        for expected in expected_files:\n            for sequence_files in expected.values():\n                filepaths.extend(sequence_files)\n    else:\n        # Products with frames or single file.\n        staging_dir = instance.data.get(\"stagingDir\")\n        frames = instance.data.get(\"frames\")\n        if frames is None or not staging_dir:\n            return []\n\n        if isinstance(frames, str):\n            # single file.\n            filepaths.append(f\"{staging_dir}/{frames}\")\n        else:\n            # list of frames\n            filepaths.extend(f\"{staging_dir}/{frame}\" for frame in frames)\n\n    return filepaths\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_render_products.html","title":"validate_render_products","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_render_products.html#client.ayon_houdini.plugins.publish.validate_render_products.ValidateUsdRenderProducts","title":"<code>ValidateUsdRenderProducts</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate at least one render product is present</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_render_products.py</code> <pre><code>class ValidateUsdRenderProducts(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate at least one render product is present\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrender\"]\n    hosts = [\"houdini\"]\n    label = \"Validate Render Products\"\n    actions = [SelectROPAction]\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"### No Render Products\n\n            The render submission specified no Render Product outputs and\n            as such would not generate any rendered files.\n\n            This is usually the case if no Render Settings or Render\n            Products were created.\n\n            Make sure to create the Render Settings\n            relevant to the renderer you want to use.\n\n            \"\"\"\n        )\n\n    def process(self, instance):\n\n        node_path = instance.data[\"instance_node\"]\n        if not instance.data.get(\"output_node\"):\n\n            # Report LOP path parm for better logs\n            lop_path_parm = hou.node(node_path).parm(\"loppath\")\n            if lop_path_parm:\n                value = lop_path_parm.evalAsString()\n                self.log.warning(\n                    f\"ROP node 'loppath' parm is set to: '{value}'\")\n\n            raise PublishValidationError(\n                f\"No valid LOP path configured on ROP \"\n                f\"'{node_path}'.\",\n                title=\"Invalid LOP path\")\n\n        if not instance.data.get(\"files\", []):\n            node = hou.node(node_path)\n            rendersettings_path = (\n                node.evalParm(\"rendersettings\") or \"/Render/rendersettings\"\n            )\n            raise PublishValidationError(\n                message=(\n                    \"No Render Products found in Render Settings \"\n                    \"for '{}' at '{}'\".format(node_path, rendersettings_path)\n                ),\n                description=self.get_description(),\n                title=self.label\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_resolution.html","title":"validate_resolution","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_resolution.html#client.ayon_houdini.plugins.publish.validate_resolution.JumpToEditorNodeAction","title":"<code>JumpToEditorNodeAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select the editor nodes related to the USD attributes.</p> <p>If a \"Render Settings\" node in the current Houdini scene defined the Render Settings primitive or changed the resolution attribute this would select the LOP node that set that attribute.</p> <p>It does so by using the <code>HoudiniPrimEditorNodes</code> custom data on the USD object that Houdini stores when editing a USD attribute.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_resolution.py</code> <pre><code>class JumpToEditorNodeAction(pyblish.api.Action):\n    \"\"\"Select the editor nodes related to the USD attributes.\n\n    If a \"Render Settings\" node in the current Houdini scene defined the\n    Render Settings primitive or changed the resolution attribute this would\n    select the LOP node that set that attribute.\n\n    It does so by using the `HoudiniPrimEditorNodes` custom data on the USD\n    object that Houdini stores when editing a USD attribute.\n    \"\"\"\n    label = \"Jump to Editor Node\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"search\"  # Icon from Awesome Icon\n\n    get_invalid_objects_fn = \"get_invalid_resolution\"\n\n    def process(self, context, plugin):\n        errored_instances = get_errored_instances_from_context(context,\n                                                               plugin=plugin)\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid nodes..\")\n        objects: \"list[Usd.Object]\" = list()\n        for instance in errored_instances:\n\n            get_invalid = getattr(plugin, self.get_invalid_objects_fn)\n            invalid_objects = get_invalid(instance)\n            if invalid_objects:\n                if isinstance(invalid_objects, (list, tuple)):\n                    objects.extend(invalid_objects)\n                else:\n                    self.log.warning(\"Plug-in returned to be invalid, \"\n                                     \"but has no selectable nodes.\")\n\n        if not objects:\n            self.log.info(\"No invalid objects found.\")\n\n        nodes: \"list[hou.Node]\" = []\n        for obj in objects:\n            lop_editor_nodes = self.get_lop_editor_node(obj)\n            if lop_editor_nodes:\n                # Get the last entry because it is the last node in the graph\n                # that edited attribute or prim. For that node find the first\n                # editable node so that we do not select inside e.g. a locked\n                # HDA.\n                editable_node = self.get_editable_node(lop_editor_nodes[-1])\n                nodes.append(editable_node)\n\n        hou.clearAllSelected()\n        if nodes:\n            self.log.info(\"Selecting invalid nodes: {}\".format(\n                \", \".join(node.path() for node in nodes)\n            ))\n            for node in nodes:\n                node.setSelected(True)\n                node.setCurrent(True)\n        else:\n            self.log.info(\"No invalid nodes found.\")\n\n    def get_lop_editor_node(self, obj: Usd.Object):\n        \"\"\"Return Houdini LOP Editor node from a USD object.\n\n        If the object is a USD attribute but has no editor nodes, it will\n        try to find the editor nodes from the parent prim.\n\n        Arguments:\n            obj (Usd.Object): USD object\n\n        Returns:\n            list[hou.Node]: Houdini LOP Editor nodes, if set in the custom\n                data of the object.\n\n        \"\"\"\n        key = \"HoudiniPrimEditorNodes\"\n        editor_nodes = obj.GetCustomDataByKey(key)\n        if not editor_nodes and isinstance(obj, Usd.Attribute):\n            prim = obj.GetPrim()\n            editor_nodes = prim.GetCustomDataByKey(key)\n\n        if not editor_nodes:\n            return []\n        return [hou.nodeBySessionId(node) for node in editor_nodes]\n\n    def get_editable_node(self, node: hou.Node):\n        \"\"\"Return the node or nearest parent that is editable.\n\n        If the node is inside a locked HDA and it's not editable, then go up\n        to the first parent that is editable.\n\n        Returns:\n            hou.Node: The node itself or the first parent that is editable.\n        \"\"\"\n        while node.isInsideLockedHDA():\n            # Allow editable node inside HDA\n            if node.isEditableInsideLockedHDA():\n                return node\n            node = node.parent()\n        return node\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_resolution.html#client.ayon_houdini.plugins.publish.validate_resolution.JumpToEditorNodeAction.get_editable_node","title":"<code>get_editable_node(node)</code>","text":"<p>Return the node or nearest parent that is editable.</p> <p>If the node is inside a locked HDA and it's not editable, then go up to the first parent that is editable.</p> <p>Returns:</p> Type Description <p>hou.Node: The node itself or the first parent that is editable.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_resolution.py</code> <pre><code>def get_editable_node(self, node: hou.Node):\n    \"\"\"Return the node or nearest parent that is editable.\n\n    If the node is inside a locked HDA and it's not editable, then go up\n    to the first parent that is editable.\n\n    Returns:\n        hou.Node: The node itself or the first parent that is editable.\n    \"\"\"\n    while node.isInsideLockedHDA():\n        # Allow editable node inside HDA\n        if node.isEditableInsideLockedHDA():\n            return node\n        node = node.parent()\n    return node\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_resolution.html#client.ayon_houdini.plugins.publish.validate_resolution.JumpToEditorNodeAction.get_lop_editor_node","title":"<code>get_lop_editor_node(obj)</code>","text":"<p>Return Houdini LOP Editor node from a USD object.</p> <p>If the object is a USD attribute but has no editor nodes, it will try to find the editor nodes from the parent prim.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Object</code> <p>USD object</p> required <p>Returns:</p> Type Description <p>list[hou.Node]: Houdini LOP Editor nodes, if set in the custom data of the object.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_resolution.py</code> <pre><code>def get_lop_editor_node(self, obj: Usd.Object):\n    \"\"\"Return Houdini LOP Editor node from a USD object.\n\n    If the object is a USD attribute but has no editor nodes, it will\n    try to find the editor nodes from the parent prim.\n\n    Arguments:\n        obj (Usd.Object): USD object\n\n    Returns:\n        list[hou.Node]: Houdini LOP Editor nodes, if set in the custom\n            data of the object.\n\n    \"\"\"\n    key = \"HoudiniPrimEditorNodes\"\n    editor_nodes = obj.GetCustomDataByKey(key)\n    if not editor_nodes and isinstance(obj, Usd.Attribute):\n        prim = obj.GetPrim()\n        editor_nodes = prim.GetCustomDataByKey(key)\n\n    if not editor_nodes:\n        return []\n    return [hou.nodeBySessionId(node) for node in editor_nodes]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_resolution.html#client.ayon_houdini.plugins.publish.validate_resolution.ValidateRenderResolution","title":"<code>ValidateRenderResolution</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the render resolution setting aligned with DB</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_resolution.py</code> <pre><code>class ValidateRenderResolution(plugin.HoudiniInstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Validate the render resolution setting aligned with DB\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrender\"]\n    label = \"Validate Render Resolution\"\n    actions = [SelectROPAction, JumpToEditorNodeAction]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid_resolution(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Render resolution does not match the entity's resolution for \"\n                \"the current context. See log for details.\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_invalid_resolution(cls, instance):\n        # Get render resolution and pixel aspect ratio from USD stage\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        lop_node: hou.LopNode = get_usd_rop_loppath(rop_node)\n        if not lop_node:\n            cls.log.debug(\n                f\"No LOP node found for ROP node: {rop_node.path()}\")\n            return\n\n        stage: Usd.Stage = lop_node.stage()\n        render_settings: UsdRender.Settings = (\n            get_usd_render_rop_rendersettings(rop_node, stage, logger=cls.log))\n        if not render_settings:\n            cls.log.debug(\n                f\"No render settings found for LOP node: {lop_node.path()}\")\n            return\n\n        invalid = []\n\n        # Each render product can have different resolution set if explicitly\n        # overridden. If not set, it will use the resolution from the render\n        # settings.\n        sample_time = Usd.TimeCode.EarliestTime()\n\n        # Get all resolution and pixel aspect attributes to validate\n        resolution_attributes = [render_settings.GetResolutionAttr()]\n        pixel_aspect_attributes = [render_settings.GetPixelAspectRatioAttr()]\n        for product in cls.iter_render_products(render_settings, stage):\n            resolution_attr = product.GetResolutionAttr()\n            if resolution_attr.HasAuthoredValue():\n                resolution_attributes.append(resolution_attr)\n\n            pixel_aspect_attr = product.GetPixelAspectRatioAttr()\n            if pixel_aspect_attr.HasAuthoredValue():\n                pixel_aspect_attributes.append(pixel_aspect_attr)\n\n        # Validate resolution and pixel aspect ratio\n        width, height, pixel_aspect = cls.get_expected_resolution(instance)\n        for resolution_attr in resolution_attributes:\n            current_width, current_height = resolution_attr.Get(sample_time)\n            if current_width != width or current_height != height:\n                cls.log.error(\n                    f\"{resolution_attr.GetPath()}: \"\n                    f\"{current_width}x{current_height} \"\n                    f\"does not match context resolution {width}x{height}\"\n                )\n                invalid.append(resolution_attr)\n\n        for pixel_aspect_attr in pixel_aspect_attributes:\n            current_pixel_aspect = pixel_aspect_attr.Get(sample_time)\n            if current_pixel_aspect != pixel_aspect:\n                cls.log.error(\n                    f\"{pixel_aspect_attr.GetPath()}: \"\n                    f\"{current_pixel_aspect} does not \"\n                    f\"match context pixel aspect {pixel_aspect}\")\n                invalid.append(pixel_aspect_attr)\n\n        return invalid\n\n    @classmethod\n    def get_expected_resolution(cls, instance):\n        \"\"\"Return the expected resolution and pixel aspect ratio for the\n        instance based on the task entity or folder entity.\"\"\"\n\n        entity = instance.data.get(\"taskEntity\")\n        if not entity:\n            entity = instance.data[\"folderEntity\"]\n\n        attributes = entity[\"attrib\"]\n        width = attributes[\"resolutionWidth\"]\n        height = attributes[\"resolutionHeight\"]\n        pixel_aspect = attributes[\"pixelAspect\"]\n        return int(width), int(height), float(pixel_aspect)\n\n    @classmethod\n    def iter_render_products(cls, render_settings, stage):\n        \"\"\"Iterate over all render products in the USD render settings\"\"\"\n        for product_path in render_settings.GetProductsRel().GetTargets():\n            prim = stage.GetPrimAtPath(product_path)\n            if not prim.IsValid():\n                cls.log.debug(\n                    f\"Render product path is not a valid prim: {product_path}\")\n                return\n\n            if prim.IsA(UsdRender.Product):\n                yield UsdRender.Product(prim)\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\"\"\"\n            ### Render Resolution does not match context\n\n            The render resolution or pixel aspect ratio does not match the\n            resolution configured in the project database. Please ensure the\n            render resolution is set correctly.\n\n            #### USD Render Settings\n\n            In most cases the render resolution is defined via the Render\n            Settings prim in USD, however each Render Product is capable\n            of authoring its own override. The logs will report the exact\n            attribute path for the mismatching resolution or aspect ratio.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_resolution.html#client.ayon_houdini.plugins.publish.validate_resolution.ValidateRenderResolution.get_expected_resolution","title":"<code>get_expected_resolution(instance)</code>  <code>classmethod</code>","text":"<p>Return the expected resolution and pixel aspect ratio for the instance based on the task entity or folder entity.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_resolution.py</code> <pre><code>@classmethod\ndef get_expected_resolution(cls, instance):\n    \"\"\"Return the expected resolution and pixel aspect ratio for the\n    instance based on the task entity or folder entity.\"\"\"\n\n    entity = instance.data.get(\"taskEntity\")\n    if not entity:\n        entity = instance.data[\"folderEntity\"]\n\n    attributes = entity[\"attrib\"]\n    width = attributes[\"resolutionWidth\"]\n    height = attributes[\"resolutionHeight\"]\n    pixel_aspect = attributes[\"pixelAspect\"]\n    return int(width), int(height), float(pixel_aspect)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_resolution.html#client.ayon_houdini.plugins.publish.validate_resolution.ValidateRenderResolution.iter_render_products","title":"<code>iter_render_products(render_settings, stage)</code>  <code>classmethod</code>","text":"<p>Iterate over all render products in the USD render settings</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_resolution.py</code> <pre><code>@classmethod\ndef iter_render_products(cls, render_settings, stage):\n    \"\"\"Iterate over all render products in the USD render settings\"\"\"\n    for product_path in render_settings.GetProductsRel().GetTargets():\n        prim = stage.GetPrimAtPath(product_path)\n        if not prim.IsValid():\n            cls.log.debug(\n                f\"Render product path is not a valid prim: {product_path}\")\n            return\n\n        if prim.IsA(UsdRender.Product):\n            yield UsdRender.Product(prim)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_review_colorspace.html","title":"validate_review_colorspace","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_review_colorspace.html#client.ayon_houdini.plugins.publish.validate_review_colorspace.ValidateReviewColorspace","title":"<code>ValidateReviewColorspace</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate Review Colorspace parameters.</p> <p>It checks if 'OCIO Colorspace' parameter was set to valid value.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_review_colorspace.py</code> <pre><code>class ValidateReviewColorspace(plugin.HoudiniInstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Validate Review Colorspace parameters.\n\n    It checks if 'OCIO Colorspace' parameter was set to valid value.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder + 0.1\n    families = [\"rop.opengl\"]\n    label = \"Validate Review Colorspace\"\n    actions = [ResetViewSpaceAction, SelectROPAction]\n\n    optional = True\n    review_color_space = \"\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Preserve automatic settings applying logic\n        settings = get_plugin_settings(plugin=cls,\n                                       project_settings=project_settings,\n                                       log=cls.log,\n                                       category=\"houdini\")\n        apply_plugin_settings_automatically(cls, settings, logger=cls.log)\n\n        # workfile settings added in '0.2.13'\n        color_settings = project_settings[\"houdini\"][\"imageio\"].get(\n            \"workfile\", {}\n        )\n        # Add review color settings\n        if color_settings.get(\"enabled\"):\n            cls.review_color_space = color_settings.get(\"review_color_space\")\n\n\n    def process(self, instance):\n\n        if not self.is_active(instance.data):\n            return\n\n        if os.getenv(\"OCIO\") is None:\n            self.log.debug(\n                \"Using Houdini's Default Color Management, \"\n                \" skipping check..\"\n            )\n            return\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        colorcorrect = rop_node.parm(\"colorcorrect\").evalAsString()\n        if not colorcorrect.startswith(\"ocio\"):\n            # any colorspace settings other than default requires\n            # 'Color Correct' parm to be set to 'OpenColorIO'\n            raise PublishValidationError(\n                \"'Color Correction' parm on '{}' ROP must be set to\"\n                \" use 'OpenColorIO'\".format(rop_node.path())\n            )\n\n        if colorcorrect == \"ocio\":\n            # For both opengl and flipbook nodes.\n\n            current_color_space = rop_node.evalParm(\"ociocolorspace\")\n            if current_color_space not in hou.Color.ocio_spaces():\n                raise PublishValidationError(\n                    \"Invalid value: Colorspace name doesn't exist.\\n\"\n                    \"Check 'OCIO Colorspace' parameter on '{}' ROP\"\n                    .format(rop_node.path())\n                )\n\n            # If `ayon+settings://houdini/imageio/workfile` is enabled\n            # and the Review colorspace setting is empty, then this check\n            # should verify if the `current_color_space` setting equals\n            # the default colorspace value.\n            if self.review_color_space and \\\n                    self.review_color_space != current_color_space:\n\n                raise PublishValidationError(\n                    \"Invalid value: Colorspace name doesn't match\"\n                    \" the Colorspace specified in settings.\"\n                )\n\n        # TODO: Check if `ociodisplay` and `ocioview` are the same as the\n        #   default display and view.\n        # Should be the default value specified in settings?\n        # OR Should be the current/default value specified in the hip file?\n        elif colorcorrect == \"ocioview\":\n            # For flipbook nodes only.\n            pass\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Reset view colorspace.\n\n        It is used to set colorspace on opengl node.\n\n        It uses the colorspace value specified in the Houdini addon settings.\n        If the value in the Houdini addon settings is empty,\n            it will fall to the default colorspace.\n\n        Note:\n            This repair action assumes that OCIO is enabled.\n            As if OCIO is disabled the whole validation is skipped\n            and this repair action won't show up.\n        \"\"\"\n        from ayon_houdini.api.lib import set_review_color_space\n\n        # Fall to the default value if cls.review_color_space is empty.\n        if not cls.review_color_space:\n            # cls.review_color_space is an empty string\n            #  when the imageio/workfile setting is disabled or\n            #  when the Review colorspace setting is empty.\n            from ayon_houdini.api.colorspace import get_default_display_view_colorspace  # noqa\n            cls.review_color_space = get_default_display_view_colorspace()\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        set_review_color_space(rop_node,\n                               cls.review_color_space,\n                               cls.log)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_review_colorspace.html#client.ayon_houdini.plugins.publish.validate_review_colorspace.ValidateReviewColorspace.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Reset view colorspace.</p> <p>It is used to set colorspace on opengl node.</p> <p>It uses the colorspace value specified in the Houdini addon settings. If the value in the Houdini addon settings is empty,     it will fall to the default colorspace.</p> Note <p>This repair action assumes that OCIO is enabled. As if OCIO is disabled the whole validation is skipped and this repair action won't show up.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_review_colorspace.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Reset view colorspace.\n\n    It is used to set colorspace on opengl node.\n\n    It uses the colorspace value specified in the Houdini addon settings.\n    If the value in the Houdini addon settings is empty,\n        it will fall to the default colorspace.\n\n    Note:\n        This repair action assumes that OCIO is enabled.\n        As if OCIO is disabled the whole validation is skipped\n        and this repair action won't show up.\n    \"\"\"\n    from ayon_houdini.api.lib import set_review_color_space\n\n    # Fall to the default value if cls.review_color_space is empty.\n    if not cls.review_color_space:\n        # cls.review_color_space is an empty string\n        #  when the imageio/workfile setting is disabled or\n        #  when the Review colorspace setting is empty.\n        from ayon_houdini.api.colorspace import get_default_display_view_colorspace  # noqa\n        cls.review_color_space = get_default_display_view_colorspace()\n\n    rop_node = hou.node(instance.data[\"instance_node\"])\n    set_review_color_space(rop_node,\n                           cls.review_color_space,\n                           cls.log)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_scene_review.html","title":"validate_scene_review","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_scene_review.html#client.ayon_houdini.plugins.publish.validate_scene_review.ValidateSceneReview","title":"<code>ValidateSceneReview</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validator Some Scene Settings before publishing the review 1. Scene Path 2. Resolution</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_scene_review.py</code> <pre><code>class ValidateSceneReview(plugin.HoudiniInstancePlugin):\n    \"\"\"Validator Some Scene Settings before publishing the review\n        1. Scene Path\n        2. Resolution\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"rop.opengl\"]\n    label = \"Scene Setting for review\"\n\n    def process(self, instance):\n\n        report = []\n        instance_node = hou.node(instance.data.get(\"instance_node\"))\n\n        invalid = self.get_invalid_scene_path(instance_node)\n        if invalid:\n            report.append(invalid)\n\n        invalid = self.get_invalid_camera_path(instance_node)\n        if invalid:\n            report.append(invalid)\n\n        invalid = self.get_invalid_resolution(instance_node)\n        if invalid:\n            report.extend(invalid)\n\n        if report:\n            raise PublishValidationError(\n                \"\\n\\n\".join(report),\n                title=self.label)\n\n    def get_invalid_scene_path(self, rop_node):\n        scene_path_parm = rop_node.parm(\"scenepath\")\n        scene_path_node = scene_path_parm.evalAsNode()\n        if not scene_path_node:\n            path = scene_path_parm.evalAsString()\n            return \"Scene path does not exist: '{}'\".format(path)\n\n    def get_invalid_camera_path(self, rop_node):\n        camera_path_parm = rop_node.parm(\"camera\")\n        camera_node = camera_path_parm.evalAsNode()\n        path = camera_path_parm.evalAsString()\n        if not camera_node:\n            return \"Camera path does not exist: '{}'\".format(path)\n        type_name = camera_node.type().name()\n        if type_name not in {\"cam\", \"lopimportcam\"}:\n            return \"Camera path is not a camera: '{}' (type: {})\".format(\n                path, type_name\n            )\n\n    def get_invalid_resolution(self, rop_node):\n\n        # The resolution setting is only used when Override Camera Resolution\n        # is enabled. So we skip validation if it is disabled.\n        override = rop_node.parm(\"tres\").eval()\n        if not override:\n            return\n\n        invalid = []\n        res_width = rop_node.parm(\"res1\").eval()\n        res_height = rop_node.parm(\"res2\").eval()\n        if res_width == 0:\n            invalid.append(\"Override Resolution width is set to zero.\")\n        if res_height == 0:\n            invalid.append(\"Override Resolution height is set to zero\")\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_sop_output_node.html","title":"validate_sop_output_node","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_sop_output_node.html#client.ayon_houdini.plugins.publish.validate_sop_output_node.ValidateSopOutputNode","title":"<code>ValidateSopOutputNode</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate the instance SOP Output Node.</p> This will ensure <ul> <li>The SOP Path is set.</li> <li>The SOP Path refers to an existing object.</li> <li>The SOP Path node is a SOP node.</li> <li>The SOP Path node has at least one input connection (has an input)</li> <li>The SOP Path has geometry data.</li> </ul> Source code in <code>client/ayon_houdini/plugins/publish/validate_sop_output_node.py</code> <pre><code>class ValidateSopOutputNode(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate the instance SOP Output Node.\n\n    This will ensure:\n        - The SOP Path is set.\n        - The SOP Path refers to an existing object.\n        - The SOP Path node is a SOP node.\n        - The SOP Path node has at least one input connection (has an input)\n        - The SOP Path has geometry data.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"pointcache\", \"vdbcache\", \"abc\"]\n    label = \"Validate Output Node (SOP)\"\n    actions = [SelectROPAction, SelectInvalidAction]\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Output node(s) are incorrect.\",\n                detail=(\n                    \"Incorrect output SOP path on Rop(s)\"\n                    f\"\\n\\n - {invalid[0].path()}\"\n                )\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        output_node = instance.data.get(\"output_node\")\n\n        if output_node is None:\n            node = hou.node(instance.data[\"instance_node\"])\n            cls.log.error(\n                \"SOP Output node in '%s' does not exist. \"\n                \"Ensure a valid SOP output path is set.\" % node.path()\n            )\n\n            return [node]\n\n        # Output node must be a Sop node.\n        if not isinstance(output_node, hou.SopNode):\n            cls.log.error(\n                \"Output node %s is not a SOP node. \"\n                \"SOP Path must point to a SOP node, \"\n                \"instead found category type: %s\"\n                % (output_node.path(), output_node.type().category().name())\n            )\n            return [output_node]\n\n        # For the sake of completeness also assert the category type\n        # is Sop to avoid potential edge case scenarios even though\n        # the isinstance check above should be stricter than this category\n        if output_node.type().category().name() != \"Sop\":\n            raise PublishValidationError(\n                f\"Output node {output_node.path()} is not of category Sop.\",\n                title=cls.label\n            )\n\n        # Ensure the node is cooked and succeeds to cook so we can correctly\n        # check for its geometry data.\n        if output_node.needsToCook():\n            cls.log.debug(\"Cooking node: %s\" % output_node.path())\n            try:\n                output_node.cook()\n            except hou.Error as exc:\n                raise PublishValidationError(\n                    f\"Failed to cook node: {output_node.path()}.\",\n                    detail=str(exc)\n                )\n\n        # Ensure the output node has at least Geometry data\n        if not output_node.geometry():\n            cls.log.error(\n                \"Output node `%s` has no geometry data.\" % output_node.path()\n            )\n            return [output_node]\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_subset_name.html","title":"validate_subset_name","text":"<p>Validator for correct naming of Static Meshes.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_subset_name.html#client.ayon_houdini.plugins.publish.validate_subset_name.ValidateSubsetName","title":"<code>ValidateSubsetName</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate Product name.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_subset_name.py</code> <pre><code>class ValidateSubsetName(plugin.HoudiniInstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Validate Product name.\n\n    \"\"\"\n\n    families = [\"staticMesh\", \"hda\"]\n    label = \"Validate Product Name\"\n    order = ValidateContentsOrder + 0.1\n    actions = [FixProductNameAction, SelectInvalidAction]\n\n    optional = True\n\n    def process(self, instance):\n\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"See log for details. \"\n                \"Invalid ROP node: {0}\".format(invalid[0].path())\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n\n        # Check product name\n        folder_entity = instance.data[\"folderEntity\"]\n        task_entity = instance.data[\"taskEntity\"]\n        task_name = task_type = None\n        if task_entity:\n            task_name = task_entity[\"name\"]\n            task_type = task_entity[\"taskType\"]\n        product_name = get_product_name(\n            instance.context.data[\"projectName\"],\n            task_name,\n            task_type,\n            instance.context.data[\"hostName\"],\n            instance.data[\"productType\"],\n            variant=instance.data[\"variant\"],\n            dynamic_data={\n                \"asset\": folder_entity[\"name\"],\n                \"folder\": {\n                            \"label\": folder_entity[\"label\"],\n                            \"name\": folder_entity[\"name\"]\n                            }\n                }\n        )\n\n        if instance.data.get(\"productName\") != product_name:\n            cls.log.error(\n                \"Invalid product name on rop node '%s' should be '%s'.\",\n                rop_node.path(), product_name\n            )\n            return [rop_node]\n\n    @classmethod\n    def repair(cls, instance):\n        rop_node = hou.node(instance.data[\"instance_node\"])\n\n        # Check product name\n        folder_entity = instance.data[\"folderEntity\"]\n        task_entity = instance.data[\"taskEntity\"]\n        task_name = task_type = None\n        if task_entity:\n            task_name = task_entity[\"name\"]\n            task_type = task_entity[\"taskType\"]\n        product_name = get_product_name(\n            instance.context.data[\"projectName\"],\n            task_name,\n            task_type,\n            instance.context.data[\"hostName\"],\n            instance.data[\"productType\"],\n            variant=instance.data[\"variant\"],\n            dynamic_data={\n                \"asset\": folder_entity[\"name\"],\n                \"folder\": {\n                            \"label\": folder_entity[\"label\"],\n                            \"name\": folder_entity[\"name\"]\n                            }\n                }\n        )\n\n        instance.data[\"productName\"] = product_name\n        rop_node.parm(\"AYON_productName\").set(product_name)\n\n        cls.log.debug(\n            \"Product name on rop node '%s' has been set to '%s'.\",\n            rop_node.path(), product_name\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_unreal_staticmesh_naming.html","title":"validate_unreal_staticmesh_naming","text":"<p>Validator for correct naming of Static Meshes.</p>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_unreal_staticmesh_naming.html#client.ayon_houdini.plugins.publish.validate_unreal_staticmesh_naming.ValidateUnrealStaticMeshName","title":"<code>ValidateUnrealStaticMeshName</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate name of Unreal Static Mesh.</p> This validator checks if output node name has a collision prefix <ul> <li>UBX</li> <li>UCP</li> <li>USP</li> <li>UCX</li> </ul> <p>This validator also checks if product name is correct         - {static mesh prefix}_{FolderName}{Variant}.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_unreal_staticmesh_naming.py</code> <pre><code>class ValidateUnrealStaticMeshName(plugin.HoudiniInstancePlugin,\n                                   OptionalPyblishPluginMixin):\n    \"\"\"Validate name of Unreal Static Mesh.\n\n    This validator checks if output node name has a collision prefix:\n            - UBX\n            - UCP\n            - USP\n            - UCX\n\n    This validator also checks if product name is correct\n            - {static mesh prefix}_{FolderName}{Variant}.\n\n    \"\"\"\n\n    families = [\"staticMesh\"]\n    label = \"Unreal Static Mesh Name (FBX)\"\n    order = ValidateContentsOrder + 0.1\n    actions = [SelectInvalidAction]\n\n    optional = True\n    collision_prefixes = []\n    static_mesh_prefix = \"\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n\n        settings = (\n            project_settings[\"houdini\"][\"create\"][\"CreateStaticMesh\"]\n        )\n        cls.collision_prefixes = settings[\"collision_prefixes\"]\n        cls.static_mesh_prefix = settings[\"static_mesh_prefix\"]\n\n    def process(self, instance):\n\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            nodes = [n.path() for n in invalid]\n            raise PublishValidationError(\n                \"See log for details. \"\n                \"Invalid nodes: {0}\".format(nodes)\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        invalid = []\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        output_node = instance.data.get(\"output_node\")\n        if output_node is None:\n            cls.log.debug(\n                \"No Output Node, skipping check..\"\n            )\n            return\n\n        if rop_node.evalParm(\"buildfrompath\"):\n            # This validator doesn't support naming check if\n            # building hierarchy from path' is used\n            cls.log.info(\n                \"Using 'Build Hierarchy from Path Attribute', skipping check..\"\n            )\n            return\n\n        # Check nodes names\n        all_outputs = get_output_children(output_node, include_sops=False)\n        for output in all_outputs:\n            for prefix in cls.collision_prefixes:\n                if output.name().startswith(prefix):\n                    invalid.append(output)\n                    cls.log.error(\n                        \"Invalid node name: Node '%s' \"\n                        \"includes a collision prefix '%s'\",\n                        output.path(), prefix\n                    )\n                    break\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_asset_contribution_default_prim.html","title":"validate_usd_asset_contribution_default_prim","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_asset_contribution_default_prim.html#client.ayon_houdini.plugins.publish.validate_usd_asset_contribution_default_prim.ValidateUSDAssetContributionDefaultPrim","title":"<code>ValidateUSDAssetContributionDefaultPrim</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the default prim is set when USD contribution is set to asset.</p> <p>If the USD asset contributions is enabled and the user has it set to initialize asset as \"asset\" then most likely they are looking to publish into an asset structure - which should have a default prim that matches the folder's name. To ensure that's the case we force require the value to be set on the ROP node.</p> <p>Note that another validator \"Validate USD Rop Default Prim\" enforces the primitive actually exists (or has modifications) if the ROP specifies a default prim - so that does not have to be validated with this validator.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_asset_contribution_default_prim.py</code> <pre><code>class ValidateUSDAssetContributionDefaultPrim(plugin.HoudiniInstancePlugin,\n                                              OptionalPyblishPluginMixin):\n    \"\"\"Validate the default prim is set when USD contribution is set to asset.\n\n    If the USD asset contributions is enabled and the user has it set to\n    initialize asset as \"asset\" then most likely they are looking to publish\n    into an asset structure - which should have a default prim that matches\n    the folder's name. To ensure that's the case we force require the\n    value to be set on the ROP node.\n\n    Note that another validator \"Validate USD Rop Default Prim\" enforces the\n    primitive actually exists (or has modifications) if the ROP specifies\n    a default prim - so that does not have to be validated with this validator.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrop\"]\n    hosts = [\"houdini\"]\n    label = \"Validate USD Asset Contribution Default Prim\"\n    actions = [SelectROPAction, RepairAction]\n\n    # TODO: Unfortunately currently this does not show as optional toggle\n    #   because the product type is `usd` and not `usdrop` - however we do\n    #   not want to run this for ALL `usd` product types?\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Check if instance is set to be an asset contribution\n        settings = self.get_attr_values_from_data_for_plugin_name(\n            \"CollectUSDLayerContributions\", instance.data\n        )\n        if (\n                not settings.get(\"contribution_enabled\", False)\n                or settings.get(\"contribution_target_product_init\") != \"asset\"\n        ):\n            return\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        default_prim = rop_node.evalParm(\"defaultprim\")\n        if not default_prim:\n            raise PublishValidationError(\n                f\"No default prim specified on ROP node: {rop_node.path()}\",\n                description=self.get_description()\n            )\n\n        folder_name = instance.data[\"folderPath\"].rsplit(\"/\", 1)[-1]\n        if not default_prim.lstrip(\"/\") == folder_name:\n            raise PublishValidationError(\n                f\"Default prim specified on ROP node does not match the\"\n                f\" asset's folder name: '{default_prim}'\"\n                f\" (should be: '/{folder_name}')\"\n                ,\n                description=self.get_description()\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        rop_node.parm(\"defaultprim\").set(\n            \"/`strsplit(chs(\\\"folderPath\\\"), \\\"/\\\", -1)`\"\n        )\n\n    @staticmethod\n    def get_attr_values_from_data_for_plugin_name(\n            plugin_name: str, data: dict) -&gt; dict:\n        return (\n            data\n            .get(\"publish_attributes\", {})\n            .get(plugin_name, {})\n        )\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"### Default primitive not set to current asset\n\n            The USD instance has **USD Contribution** enabled and is set to\n            initialize as **asset**. The asset requires a default root\n            primitive with the name of the folder it's related to.\n\n            For example, you're working in `/asset/char_hero` then the\n            folder's name is `char_hero`. For the asset hence all prims should\n            live under `/char_hero` root primitive.\n\n            This validation solely ensures the **default primitive** on the ROP\n            node is set to match the folder name.\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_look_assignments.html","title":"validate_usd_look_assignments","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_look_assignments.html#client.ayon_houdini.plugins.publish.validate_usd_look_assignments.ValidateUsdLookAssignments","title":"<code>ValidateUsdLookAssignments</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate all geometry prims have a material binding.</p> This does not necessarily validate the material binding is authored <p>by the current layers if the input already had material bindings.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_look_assignments.py</code> <pre><code>class ValidateUsdLookAssignments(plugin.HoudiniInstancePlugin,\n                                 OptionalPyblishPluginMixin):\n    \"\"\"Validate all geometry prims have a material binding.\n\n    Note: This does not necessarily validate the material binding is authored\n        by the current layers if the input already had material bindings.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"look\"]\n    hosts = [\"houdini\"]\n    label = \"Validate All Geometry Has Material Assignment\"\n    actions = [SelectROPAction]\n    optional = True\n\n    # The USD documentation mentions that it's okay to have custom material\n    # purposes but the USD standard only supports 2 (technically 3, since\n    # allPurpose is empty)\n    allowed_material_purposes = (\n        UsdShade.Tokens.full,\n        UsdShade.Tokens.preview,\n        UsdShade.Tokens.allPurpose,\n    )\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Get Usd.Stage from \"Collect ROP Sdf Layers and USD Stage\" plug-in\n        stage = instance.data.get(\"stage\")\n        if not stage:\n            self.log.debug(\"No USD stage found.\")\n            return\n        stage: Usd.Stage\n\n        # We iterate the composed stage for code simplicity; however this\n        # means that it does not validate across e.g. multiple model variants\n        # but only checks against the current composed stage. Likely this is\n        # also what you actually want to validate, because your look might not\n        # apply to *all* model variants.\n        invalid: List[Sdf.Path] = []\n        for prim in stage.Traverse():\n            if not prim.IsA(UsdGeom.Gprim):\n                continue\n\n            if not has_material(prim, purposes=self.allowed_material_purposes):\n                invalid.append(prim.GetPath())\n\n        for path in sorted(invalid):\n            self.log.warning(\"No material binding on: %s\", path.pathString)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Found geometry without material bindings.\",\n                title=\"No assigned materials\",\n                description=self.get_description()\n            )\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\n            \"\"\"### Geometry has no material assignments.\n\n            A look publish should usually define a material assignment for all\n            geometry of a model. As such, this validates whether all geometry\n            currently has at least one material binding applied.\n\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_look_assignments.html#client.ayon_houdini.plugins.publish.validate_usd_look_assignments.has_material","title":"<code>has_material(prim, include_subsets=True, purposes=None)</code>","text":"<p>Return whether primitive has any material binding.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_look_assignments.py</code> <pre><code>def has_material(prim: Usd.Prim,\n                 include_subsets: bool = True,\n                 purposes: Optional[Iterable[str]] = None) -&gt; bool:\n    \"\"\"Return whether primitive has any material binding.\"\"\"\n    if purposes is None:\n        purposes = [UsdShade.Tokens.allPurpose]\n\n    search_from = [prim]\n    if include_subsets:\n        subsets = UsdShade.MaterialBindingAPI(prim).GetMaterialBindSubsets()\n        for subset in subsets:\n            search_from.append(subset.GetPrim())\n\n    for purpose in purposes:\n        bounds = UsdShade.MaterialBindingAPI.ComputeBoundMaterials(search_from,\n                                                                   purpose)\n        for (material, relationship) in zip(*bounds):\n            material_prim = material.GetPrim()\n            if material_prim.IsValid():\n                # Has a material binding\n                return True\n\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_look_disallowed_types.html","title":"validate_usd_look_disallowed_types","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_look_disallowed_types.html#client.ayon_houdini.plugins.publish.validate_usd_look_disallowed_types.ValidateUsdLookDisallowedTypes","title":"<code>ValidateUsdLookDisallowedTypes</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate no meshes are defined in the look.</p> <p>Usually, a published look should not contain generated meshes in the output but only the materials, material bindings and render geometry settings.</p> <p>To avoid accidentally including a Mesh definition we ensure none of the generated output layers for the instance is defining any Mesh type.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_look_disallowed_types.py</code> <pre><code>class ValidateUsdLookDisallowedTypes(plugin.HoudiniInstancePlugin,\n                                     OptionalPyblishPluginMixin):\n    \"\"\"Validate no meshes are defined in the look.\n\n    Usually, a published look should not contain generated meshes in the output\n    but only the materials, material bindings and render geometry settings.\n\n    To avoid accidentally including a Mesh definition we ensure none of the\n    generated output layers for the instance is defining any Mesh type.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"look\"]\n    hosts = [\"houdini\"]\n    label = \"Validate Look No Disallowed Types\"\n    actions = [SelectROPAction]\n\n    disallowed_types = [\n        \"UsdGeomBoundable\",       # Meshes/Lights/Procedurals\n        \"UsdRenderSettingsBase\",  # Render Settings\n        \"UsdRenderVar\",           # Render Var\n        \"UsdGeomCamera\"           # Cameras\n    ]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Get Sdf.Layers from \"Collect ROP Sdf Layers and USD Stage\" plug-in\n        layers = instance.data.get(\"layers\")\n        if not layers:\n            return\n        layers: List[Sdf.Layer]\n\n        # The Sdf.PrimSpec type name will not have knowledge about inherited\n        # types for the type, name. So we pre-collect all invalid types\n        # and their child types to ensure we match inherited types as well.\n        disallowed_type_names = set()\n        for type_name in self.disallowed_types:\n            disallowed_type_names.update(get_schema_type_names(type_name))\n\n        # Find invalid prims\n        invalid = []\n\n        def collect_invalid(layer: Sdf.Layer, path: Sdf.Path):\n            \"\"\"Collect invalid paths into the `invalid` list\"\"\"\n            if not path.IsPrimPath():\n                return\n\n            prim = layer.GetPrimAtPath(path)\n            if prim.typeName in disallowed_type_names:\n                self.log.warning(\n                    \"Disallowed prim type '%s' at %s\",\n                    prim.typeName, prim.path.pathString\n                )\n                invalid.append(path)\n                return\n\n            # TODO: We should allow referencing or payloads, but if so - we\n            #   should still check whether the loaded reference or payload\n            #   introduces any geometry. If so, disallow it because that\n            #   opinion would 'define' geometry in the output\n            references= get_applied_items(prim.referenceList)\n            if references:\n                self.log.warning(\n                    \"Disallowed references are added at %s: %s\",\n                    prim.path.pathString,\n                    \", \".join(ref.assetPath for ref in references)\n                )\n                invalid.append(path)\n\n            payloads = get_applied_items(prim.payloadList)\n            if payloads:\n                self.log.warning(\n                    \"Disallowed payloads are added at %s: %s\",\n                    prim.path.pathString,\n                    \", \".join(payload.assetPath for payload in payloads)\n                )\n                invalid.append(path)\n\n        for layer in layers:\n            layer.Traverse(\"/\", partial(collect_invalid, layer))\n\n        if invalid:\n            raise PublishValidationError(\n                \"Invalid look members found.\",\n                title=\"Look Invalid Members\",\n                description=self.get_description()\n            )\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\n            \"\"\"### Look contains invalid members\n\n            A look publish should usually only contain materials, material\n            bindings and render geometry settings.\n\n            This validation invalidates any creation of:\n            - Render Settings,\n            - Lights,\n            - Cameras,\n            - Geometry (Meshes, Curves and other geometry types)\n\n            To avoid writing out loaded geometry into the output make sure to\n            add a Layer Break after loading all the content you do **not** want\n            to save into the output file. Then your materials, material\n            bindings and render geometry settings are overrides applied to the\n            loaded content after the **Layer Break LOP** node.\n\n            If you happen to write out additional data for the meshes via\n            e.g. a SOP Modify make sure to import to LOPs only the relevant\n            attributes, mark them as static attributes, static topology and\n            set the Primitive Definitions to be Overlay instead of Defines.\n\n            Currently, to avoid issues with referencing/payloading geometry\n            from external files any references or payloads are also disallowed\n            for looks.\n\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_look_disallowed_types.html#client.ayon_houdini.plugins.publish.validate_usd_look_disallowed_types.get_applied_items","title":"<code>get_applied_items(list_proxy)</code>","text":"<p>Backwards compatible equivalent of <code>GetAppliedItems()</code></p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_look_disallowed_types.py</code> <pre><code>def get_applied_items(list_proxy) -&gt; List[Union[Sdf.Reference, Sdf.Payload]]:\n    \"\"\"Backwards compatible equivalent of `GetAppliedItems()`\"\"\"\n    return list_proxy.ApplyEditsToList([])\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_look_material_defs.html","title":"validate_usd_look_material_defs","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_look_material_defs.html#client.ayon_houdini.plugins.publish.validate_usd_look_material_defs.ValidateLookShaderDefs","title":"<code>ValidateLookShaderDefs</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate Material primitives are defined types instead of overs</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_look_material_defs.py</code> <pre><code>class ValidateLookShaderDefs(plugin.HoudiniInstancePlugin,\n                             OptionalPyblishPluginMixin):\n    \"\"\"Validate Material primitives are defined types instead of overs\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"look\"]\n    hosts = [\"houdini\"]\n    label = \"Validate Look Shaders Are Defined\"\n    actions = [SelectROPAction]\n    optional = True\n\n    # Types to validate at the low-level Sdf API\n    # For Usd API we validate directly against `UsdShade.Material`\n    validate_types = [\n        \"UsdShadeMaterial\"\n    ]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Get Sdf.Layers from \"Collect ROP Sdf Layers and USD Stage\" plug-in\n        layers = instance.data.get(\"layers\")\n        if not layers:\n            return\n        stage: Usd.Stage = instance.data[\"stage\"]\n        layers: List[Sdf.Layer]\n\n        # The Sdf.PrimSpec type name will not have knowledge about inherited\n        # types for the type, name. So we pre-collect all invalid types\n        # and their child types to ensure we match inherited types as well.\n        validate_type_names = set()\n        for type_name in self.validate_types:\n            validate_type_names.update(get_schema_type_names(type_name))\n\n        invalid = []\n        for layer in layers:\n            def log_overs(path: Sdf.Path):\n                if not path.IsPrimPath():\n                    return\n                prim_spec = layer.GetPrimAtPath(path)\n\n                if not prim_spec.typeName:\n                    # Typeless may mean Houdini generated the material or\n                    # shader as override because upstream the nodes already\n                    # existed. So we check the stage instead to identify\n                    # the composed type of the prim\n                    prim = stage.GetPrimAtPath(path)\n                    if not prim:\n                        return\n\n                    if not prim.IsA(UsdShade.Material):\n                        return\n\n                    self.log.debug(\"Material Prim has no type defined: %s\",\n                                   path)\n\n                elif prim_spec.typeName not in validate_type_names:\n                    return\n\n                if prim_spec.specifier != Sdf.SpecifierDef:\n                    specifier = {\n                        Sdf.SpecifierDef: \"Def\",\n                        Sdf.SpecifierOver: \"Over\",\n                        Sdf.SpecifierClass: \"Class\"\n                    }[prim_spec.specifier]\n\n                    self.log.warning(\n                        \"Material is not defined but specified as \"\n                        \"'%s': %s\", specifier, path\n                    )\n                    invalid.append(path)\n\n            layer.Traverse(\"/\", log_overs)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Found Materials not specifying an authored definition.\",\n                title=\"Materials not defined\",\n                description=self.get_description()\n            )\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\n            \"\"\"### Materials are not defined types\n\n            There are materials in your current look that do not **define** the\n            material primitives, but rather **override** or specify a\n            **class**. This is most likely not what you want since you want\n            most looks to define new materials instead of overriding existing\n            materials.\n\n            Usually this happens if your current scene loads an input asset\n            that already has the materials you're creating in your current\n            scene as well. For example, if you are loading the Asset that\n            contains the previously publish of your look without muting the\n            look layer. As such, Houdini sees the materials already exist and\n            will not make new definitions, but only write \"override changes\".\n            However, once your look publish would replace the previous one then\n            suddenly the materials would be missing and only specified as\n            overrides.\n\n            So, in most cases this is solved by Layer Muting upstream the\n            look layers of the loaded asset.\n\n            If for a specific case the materials already existing in the input\n            is correct then you can either specify new material names for what\n            you're creating in the current scene or disable this validation\n            if you are sure you want to write overrides in your look publish\n            instead of definitions.\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_output_node.html","title":"validate_usd_output_node","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_output_node.html#client.ayon_houdini.plugins.publish.validate_usd_output_node.ValidateUSDOutputNode","title":"<code>ValidateUSDOutputNode</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate the instance USD LOPs Output Node.</p> This will ensure <ul> <li>The LOP Path is set.</li> <li>The LOP Path refers to an existing object.</li> <li>The LOP Path node is a LOP node.</li> </ul> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_output_node.py</code> <pre><code>class ValidateUSDOutputNode(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate the instance USD LOPs Output Node.\n\n    This will ensure:\n        - The LOP Path is set.\n        - The LOP Path refers to an existing object.\n        - The LOP Path node is a LOP node.\n\n    \"\"\"\n\n    # Validate early so that this error reports higher than others to the user\n    # so that if another invalidation is due to the output node being invalid\n    # the user will likely first focus on this first issue\n    order = pyblish.api.ValidatorOrder - 0.4\n    families = [\"usdrop\"]\n    label = \"Validate Output Node (USD)\"\n    actions = [SelectROPAction]\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            node_path = invalid[0].path()\n            raise PublishValidationError(\n                f\"Output node '{node_path}' has no valid LOP path set.\",\n                title=self.label,\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        import hou\n\n        output_node = instance.data.get(\"output_node\")\n\n        if output_node is None:\n            node = hou.node(instance.data.get(\"instance_node\"))\n            cls.log.error(\n                \"USD node '%s' configured LOP path does not exist. \"\n                \"Ensure a valid LOP path is set.\" % node.path()\n            )\n\n            return [node]\n\n        # Output node must be a Sop node.\n        if not isinstance(output_node, hou.LopNode):\n            cls.log.error(\n                \"Output node %s is not a LOP node. \"\n                \"LOP Path must point to a LOP node, \"\n                \"instead found category type: %s\"\n                % (output_node.path(), output_node.type().category().name())\n            )\n            return [output_node]\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"### USD ROP has invalid LOP path\n\n            The USD ROP node has no or an invalid LOP path set to be exported.\n            Make sure to correctly configure what you want to export for the\n            publish.\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_render_arnold.html","title":"validate_usd_render_arnold","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_render_arnold.html#client.ayon_houdini.plugins.publish.validate_usd_render_arnold.ValidateUSDRenderArnoldSettings","title":"<code>ValidateUSDRenderArnoldSettings</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate USD Render Product names are correctly set absolute paths.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_render_arnold.py</code> <pre><code>class ValidateUSDRenderArnoldSettings(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate USD Render Product names are correctly set absolute paths.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrender\"]\n    hosts = [\"houdini\"]\n    label = \"Validate USD Render Arnold Settings\"\n    actions = [SelectROPAction]\n\n    def process(self, instance):\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        node = instance.data.get(\"output_node\")\n        if not node:\n            # No valid output node was set. We ignore it since it will\n            # be validated by another plug-in.\n            return\n\n        # Check only for Arnold renderer\n        renderer = rop_node.evalParm(\"renderer\")\n        if renderer != \"HdArnoldRendererPlugin\":\n            self.log.debug(\"Skipping Arnold Settings validation because \"\n                           \"renderer is set to: %s\", renderer)\n            return\n\n        # Validate Arnold Product Type is enabled on the Arnold Render Settings\n        # This is confirmed by the `includeAovs` attribute on the RenderProduct\n        stage: pxr.Usd.Stage = instance.data[\"stage\"]\n        invalid = False\n        for prim_path in instance.data.get(\"usdRenderProducts\", []):\n            prim = stage.GetPrimAtPath(prim_path)\n            include_aovs = prim.GetAttribute(\"includeAovs\")\n            if not include_aovs.IsValid() or not include_aovs.Get(0):\n                self.log.error(\n                    \"All Render Products must be set to 'Arnold Product \"\n                    \"Type' on the Arnold Render Settings node to ensure \"\n                    \"correct output of metadata and AOVs.\"\n                )\n                invalid = True\n                break\n\n        # Ensure 'Delegate Products' is enabled for Husk\n        if not rop_node.evalParm(\"husk_delegateprod\"):\n            invalid = True\n            self.log.error(\"USD Render ROP has `Husk &gt; Rendering &gt; Delegate \"\n                           \"Products` disabled. Please enable to ensure \"\n                           \"correct output files\")\n\n        # TODO: Detect bug of invalid Cryptomatte state?\n        # Detect if any Render Products were set that do not actually exist\n        # (e.g. invalid rendervar targets for a renderproduct) because that\n        # is what originated the Cryptomatte enable-&gt;disable bug.\n\n        if invalid:\n            raise PublishValidationError(\n                \"Invalid Render Settings for Arnold render.\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_render_arnold.html#client.ayon_houdini.plugins.publish.validate_usd_render_arnold.ValidateUSDRenderCamera","title":"<code>ValidateUSDRenderCamera</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate USD Render Settings refer to a valid render camera.</p> The render camera is defined in priority by this order <ol> <li>ROP Node Override Camera Parm (if set)</li> <li>Render Product Camera (if set - this may differ PER render product!)</li> <li>Render Settings Camera (if set)</li> </ol> <p>If None of these are set or a currently set entry resolves to an invalid camera prim path then we'll report it as an error.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_render_arnold.py</code> <pre><code>class ValidateUSDRenderCamera(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate USD Render Settings refer to a valid render camera.\n\n    The render camera is defined in priority by this order:\n        1. ROP Node Override Camera Parm (if set)\n        2. Render Product Camera (if set - this may differ PER render product!)\n        3. Render Settings Camera (if set)\n\n    If None of these are set *or* a currently set entry resolves to an invalid\n    camera prim path then we'll report it as an error.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrender\"]\n    hosts = [\"houdini\"]\n    label = \"Validate USD Render Camera\"\n    actions = [SelectROPAction]\n\n    def process(self, instance):\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        lop_node = instance.data.get(\"output_node\")\n        if not lop_node:\n            # No valid output node was set. We ignore it since it will\n            # be validated by another plug-in.\n            return\n\n        stage = instance.data[\"stage\"]\n        render_settings = get_usd_render_rop_rendersettings(rop_node, stage,\n                                                            logger=self.log)\n        if not render_settings:\n            # Without render settings we basically have no defined\n            self.log.error(\"No render settings found for %s.\", rop_node.path())\n            return\n\n        render_settings_camera = self._get_camera(render_settings)\n        rop_camera = rop_node.evalParm(\"override_camera\")\n\n        invalid = False\n        camera_paths = set()\n        for render_product in self.iter_render_products(render_settings,\n                                                        stage):\n            render_product_camera = self._get_camera(render_product)\n\n            # Get first camera path as per order in in this plug-in docstring\n            camera_path = next(\n                (cam_path for cam_path in [rop_camera,\n                                           render_product_camera,\n                                           render_settings_camera]\n                 if cam_path),\n                None\n            )\n            if not camera_path:\n                self.log.error(\n                    \"No render camera defined for render product: '%s'\",\n                    render_product.GetPath()\n                )\n                invalid = True\n                continue\n\n            camera_paths.add(camera_path)\n\n        # For the camera paths used across the render products detect\n        # whether the path is a valid camera in the stage\n        for camera_path in sorted(camera_paths):\n            camera_prim = stage.GetPrimAtPath(camera_path)\n            if not camera_prim or not camera_prim.IsValid():\n                self.log.error(\n                    \"Render camera path '%s' does not exist in stage.\",\n                    camera_path\n                )\n                invalid = True\n                continue\n\n            if not camera_prim.IsA(pxr.UsdGeom.Camera):\n                self.log.error(\n                    \"Render camera path '%s' is not a camera.\",\n                    camera_path\n                )\n                invalid = True\n\n        if invalid:\n            raise PublishValidationError(\n                f\"No render camera found for {instance.name}.\",\n                title=\"Invalid Render Camera\",\n                description=self.get_description()\n            )\n\n    def iter_render_products(self, render_settings, stage):\n        for product_path in render_settings.GetProductsRel().GetTargets():\n            prim = stage.GetPrimAtPath(product_path)\n            if prim.IsA(UsdRender.Product):\n                yield UsdRender.Product(prim)\n\n    def _get_camera(self, settings: UsdRender.SettingsBase):\n        \"\"\"Return primary camera target from RenderSettings or RenderProduct\"\"\"\n        camera_targets = settings.GetCameraRel().GetForwardedTargets()\n        if camera_targets:\n            return camera_targets[0]\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"### Missing render camera\n\n            No valid render camera was set for the USD Render Settings.\n\n            The configured render camera path must be a valid camera in the\n            stage. Make sure it refers to an existing path and that it is\n            a camera.\n\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_render_arnold.html#client.ayon_houdini.plugins.publish.validate_usd_render_arnold.ValidateUSDRenderSingleFile","title":"<code>ValidateUSDRenderSingleFile</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate the writing of a single USD Render Output file.</p> <p>When writing to single file with USD Render ROP make sure to write the output USD file from a single process to avoid overwriting it with different processes.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_render_arnold.py</code> <pre><code>class ValidateUSDRenderSingleFile(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate the writing of a single USD Render Output file.\n\n     When writing to single file with USD Render ROP make sure to write the\n     output USD file from a single process to avoid overwriting it with\n     different processes.\n     \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrender\"]\n    hosts = [\"houdini\"]\n    label = \"Validate USD Render ROP Settings\"\n    actions = [SelectROPAction, RepairAction]\n\n    def process(self, instance):\n\n        if instance.data.get(\"creator_attributes\",\n                             {}).get(\"render_target\") != \"farm_split\":\n            # Validation is only relevant when submitting a farm job where the\n            # export and render are separate jobs.\n            return\n\n        # Get configured settings for this instance\n        submission_data = (\n            instance.data\n            .get(\"publish_attributes\", {})\n            .get(\"HoudiniSubmitDeadlineUsdRender\", {})\n        )\n        render_chunk_size = submission_data.get(\"chunk\", 1)\n        export_chunk_size = submission_data.get(\"export_chunk\", 1)\n        usd_file_per_frame = \"$F\" in instance.data[\"ifdFile\"]\n        frame_start_handle = instance.data[\"frameStartHandle\"]\n        frame_end_handle = instance.data[\"frameEndHandle\"]\n        num_frames = frame_end_handle - frame_start_handle + 1\n        rop_node = hou.node(instance.data[\"instance_node\"])\n\n        # Whether ROP node is set to render all Frames within a single process\n        # When this is disabled then Husk will restart completely per frame\n        # no matter the chunk size.\n        all_frames_at_once = rop_node.evalParm(\"allframesatonce\")\n\n        invalid = False\n        if usd_file_per_frame:\n            # USD file per frame\n            # If rendering multiple frames per task and USD file has $F then\n            # log a warning that the optimization will be less efficient\n            # since husk will still restart per frame.\n            if render_chunk_size &gt; 1:\n                self.log.debug(\n                    \"Render chunk size is bigger than one but export file is \"\n                    \"a USD file per frame. Husk does not allow rendering \"\n                    \"separate USD files in one process. As such, Husk will \"\n                    \"restart per frame even within the chunk to render the \"\n                    \"correct file per frame.\"\n                )\n        else:\n            # Single export USD file\n            # Export chunk size must be higher than the amount of frames to\n            # ensure the file is written in one go on one machine and thus\n            # ends up containing all frames correctly\n            if export_chunk_size &lt; num_frames:\n                self.log.error(\n                    \"The export chunk size %s is smaller than the amount of \"\n                    \"frames %s, so multiple tasks will try to export to \"\n                    \"the same file. Make sure to increase chunk \"\n                    \"size to higher than the amount of frames to render, \"\n                    \"more than &gt;%s\",\n                    export_chunk_size, num_frames, num_frames\n                )\n                invalid = True\n\n            if not all_frames_at_once:\n                self.log.error(\n                    \"Please enable 'Render All Frames With A Single Process' \"\n                    \"on the USD Render ROP node or add $F to the USD filename\",\n                )\n                invalid = True\n\n        if invalid:\n            raise PublishValidationError(\n                \"Render USD file being overwritten during export.\",\n                title=\"Render USD file overwritten\",\n                description=self.get_description())\n\n    @classmethod\n    def repair(cls, instance):\n        # Enable all frames at once and make the frames per task\n        # very large\n        rop_node = hou.node(instance.data[\"instance_node\"])\n        rop_node.parm(\"allframesatonce\").set(True)\n\n        # Override instance setting for export chunk size\n        create_context = instance.context.data[\"create_context\"]\n        created_instance = create_context.get_instance_by_id(\n            instance.data[\"instance_id\"]\n        )\n        created_instance.publish_attributes[\"HoudiniSubmitDeadlineUsdRender\"][\"export_chunk\"] = 1000  # noqa\n        create_context.save_changes()\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"### Render USD file configured incorrectly\n\n            The USD render ROP is currently configured to write a single\n            USD file to render instead of a file per frame.\n\n            When that is the case, a single machine must produce that file in\n            one process to avoid the file being overwritten by the other\n            processes.\n\n            We resolve that by enabling _Render All Frames With A Single\n            Process_ on the ROP node and ensure the export job task size\n            is larger than the amount of frames of the sequence, so the file\n            gets written in one go.\n\n            Run **Repair** to resolve this for you.\n\n            If instead you want to write separate render USD files, please\n            include $F in the USD output filename on the `ROP node &gt; Output &gt;\n            USD Export &gt; Output File`\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_render_product_names.html","title":"validate_usd_render_product_names","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_render_product_names.html#client.ayon_houdini.plugins.publish.validate_usd_render_product_names.ValidateUSDRenderProductNames","title":"<code>ValidateUSDRenderProductNames</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate USD Render Product names are correctly set absolute paths.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_render_product_names.py</code> <pre><code>class ValidateUSDRenderProductNames(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate USD Render Product names are correctly set absolute paths.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrender\"]\n    label = \"Validate USD Render Product Names\"\n    optional = True\n\n    def process(self, instance):\n\n        invalid = []\n        for filepath in instance.data.get(\"files\", []):\n\n            if not filepath:\n                invalid.append(\"Detected empty output filepath.\")\n\n            if not os.path.isabs(filepath):\n                invalid.append(\n                    \"Output file path is not absolute path: %s\" % filepath\n                )\n\n        if invalid:\n            for message in invalid:\n                self.log.error(message)\n            raise PublishValidationError(\n                \"USD Render Paths are invalid.\", title=self.label)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_render_product_paths.html","title":"validate_usd_render_product_paths","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_render_product_paths.html#client.ayon_houdini.plugins.publish.validate_usd_render_product_paths.ValidateUSDRenderProductPaths","title":"<code>ValidateUSDRenderProductPaths</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate USD Render Settings refer to a valid render camera.</p> <p>The publishing logic uses a metadata <code>.json</code> in the render output images' folder to identify how the files should be published. To ensure multiple subsequent submitted versions of a scene do not override the same metadata json file we want to ensure the user has the render paths set up to contain the $HIPNAME in a parent folder.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_render_product_paths.py</code> <pre><code>class ValidateUSDRenderProductPaths(plugin.HoudiniInstancePlugin,\n                                    OptionalPyblishPluginMixin):\n    \"\"\"Validate USD Render Settings refer to a valid render camera.\n\n    The publishing logic uses a metadata `.json` in the render output images'\n    folder to identify how the files should be published. To ensure multiple\n    subsequent submitted versions of a scene do not override the same metadata\n    json file we want to ensure the user has the render paths set up to\n    contain the $HIPNAME in a parent folder.\n\n    \"\"\"\n    # NOTE(colorbleed): This workflow might be relatively Colorbleed-specific\n    # TODO: Preferably we find ways to make what this tries to avoid no issue\n    #   itself by e.g. changing how AYON deals with these metadata json files.\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrender\"]\n    hosts = [\"houdini\"]\n    label = \"Validate USD Render Product Paths\"\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        current_file = instance.context.data[\"currentFile\"]\n\n        # mimic `$HIPNAME:r` because `hou.text.collapseCommonVars can not\n        # collapse it\n        hipname_r = os.path.splitext(os.path.basename(current_file))[0]\n\n        invalid = False\n        for filepath in instance.data.get(\"files\", []):\n            folder = os.path.dirname(filepath)\n\n            if hipname_r not in folder:\n                filepath_raw = hou.text.collapseCommonVars(filepath, vars=[\n                    \"$HIP\", \"$JOB\", \"$HIPNAME\"\n                ])\n                filepath_raw = filepath_raw.replace(hipname_r, \"$HIPNAME:r\")\n                self.log.error(\"Invalid render output path:\\n%s\", filepath_raw)\n                invalid = True\n\n        if invalid:\n            raise PublishValidationError(\n                \"Render path is invalid. Please make sure to include a \"\n                \"folder with '$HIPNAME:r'.\",\n                title=self.label,\n                description=self.get_description()\n            )\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"### Invalid render output path\n\n            The render output path must include the current scene name in\n            a parent folder to ensure uniqueness across multiple workfile\n            versions. Otherwise subsequent farm publishes could fail because\n            newer versions will overwrite the metadata files of older versions.\n\n            The easiest way to do so is to include **`$HIPNAME:r`** somewhere\n            in the render product names.\n\n            A recommended output path is for example:\n            ```\n            $HIP/renders/$HIPNAME:r/$OS/$HIPNAME:r.$OS.$F4.exr\n            ```\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_rop_default_prim.html","title":"validate_usd_rop_default_prim","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_usd_rop_default_prim.html#client.ayon_houdini.plugins.publish.validate_usd_rop_default_prim.ValidateUSDRopDefaultPrim","title":"<code>ValidateUSDRopDefaultPrim</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate the default prim exists if default prim value is set on ROP</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_usd_rop_default_prim.py</code> <pre><code>class ValidateUSDRopDefaultPrim(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate the default prim exists if default prim value is set on ROP\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrop\"]\n    hosts = [\"houdini\"]\n    label = \"Validate USD ROP Default Prim\"\n    actions = [SelectROPAction]\n\n    def process(self, instance):\n\n        rop_node = hou.node(instance.data[\"instance_node\"])\n\n        default_prim = rop_node.evalParm(\"defaultprim\")\n        if not default_prim:\n            self.log.debug(\n                \"No default prim specified on ROP node: %s\", rop_node.path()\n            )\n            return\n\n        # Get Sdf.Layers from \"Collect ROP Sdf Layers and USD Stage\" plug-in\n        layers = instance.data.get(\"layers\")\n        if not layers:\n            self.log.error(\"No USD layers found. This is likely a bug.\")\n            return\n        layers: List[Sdf.Layer]\n\n        # TODO: This only would detect any local opinions on that prim and thus\n        #   would fail to detect if a sublayer added on the stage root layer\n        #   being exported would actually be generating the prim path. We\n        #   should maybe consider that if this fails that we still check\n        #   whether a sublayer doesn't create the default prim path.\n        for layer in layers:\n            if layer.GetPrimAtPath(default_prim):\n                break\n        else:\n            # No prim found at the given path on any of the generated layers\n            raise PublishValidationError(\n                \"Default prim specified by USD ROP does not exist in \"\n                f\"stage: '{default_prim}'\",\n                title=\"Default Prim\",\n                description=self.get_description()\n            )\n\n        # Warn about any paths that are authored that are not a child\n        # of the default prim\n        outside_paths = set()\n        default_prim_path = f\"/{default_prim.strip('/')}\"\n        for layer in layers:\n\n            def collect_outside_paths(path: Sdf.Path):\n                \"\"\"Collect all paths that are no child of the default prim\"\"\"\n\n                if not path.IsPrimPath():\n                    # Collect only prim paths\n                    return\n\n                # Ignore the HoudiniLayerInfo prim\n                if path.pathString == \"/HoudiniLayerInfo\":\n                    return\n\n                if not path.pathString.startswith(default_prim_path):\n                    outside_paths.add(path)\n\n            layer.Traverse(\"/\", collect_outside_paths)\n\n        if outside_paths:\n            self.log.warning(\n                \"Found paths that are not within default primitive path '%s'. \"\n                \"When referencing the following paths by default will not be \"\n                \"loaded:\",\n                default_prim\n            )\n            for outside_path in sorted(outside_paths):\n                self.log.warning(\"Outside default prim: %s\", outside_path)\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"### Default Prim not found\n\n            The USD render ROP is currently configured to write the output\n            USD file with a default prim. However, the default prim is not\n            found in the USD stage.\n\n            Make sure to double check the Default Prim setting on the USD\n            Render ROP for typos or make sure the hierarchy and opinions you\n            are creating exist in the default prim path.\n\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_vdb_output_node.html","title":"validate_vdb_output_node","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_vdb_output_node.html#client.ayon_houdini.plugins.publish.validate_vdb_output_node.ValidateVDBOutputNode","title":"<code>ValidateVDBOutputNode</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate that the node connected to the output node is of type VDB.</p> <p>All primitives of the output geometry must be VDBs, no other primitive types are allowed. That means that regardless of the amount of VDBs in the geometry it will have an equal amount of VDBs, points, primitives and vertices since each VDB primitive is one point, one vertex and one VDB.</p> <p>This validation only checks the geometry on the first frame of the export frame range for optimization purposes.</p> <p>A VDB is an inherited type of Prim, holds the following data:     - Primitives: 1     - Points: 1     - Vertices: 1     - VDBs: 1</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_vdb_output_node.py</code> <pre><code>class ValidateVDBOutputNode(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate that the node connected to the output node is of type VDB.\n\n    All primitives of the output geometry must be VDBs, no other primitive\n    types are allowed. That means that regardless of the amount of VDBs in the\n    geometry it will have an equal amount of VDBs, points, primitives and\n    vertices since each VDB primitive is one point, one vertex and one VDB.\n\n    This validation only checks the geometry on the first frame of the export\n    frame range for optimization purposes.\n\n    A VDB is an inherited type of Prim, holds the following data:\n        - Primitives: 1\n        - Points: 1\n        - Vertices: 1\n        - VDBs: 1\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder + 0.1\n    families = [\"vdbcache\"]\n    label = \"Validate Output Node (VDB)\"\n    actions = [SelectInvalidAction]\n\n    def process(self, instance):\n        invalid_nodes, message = self.get_invalid_with_message(instance)\n        if invalid_nodes:\n\n            # instance_node is str, but output_node is hou.Node so we convert\n            output = instance.data.get(\"output_node\")\n            output_path = output.path() if output else None\n\n            raise PublishXmlValidationError(\n                self,\n                \"Invalid VDB content: {}\".format(message),\n                formatting_data={\n                    \"message\": message,\n                    \"rop_path\": instance.data.get(\"instance_node\"),\n                    \"sop_path\": output_path\n                }\n            )\n\n    @classmethod\n    def get_invalid_with_message(cls, instance):\n\n        node = instance.data.get(\"output_node\")\n        if node is None:\n            instance_node = instance.data.get(\"instance_node\")\n            error = (\n                \"SOP path is not correctly set on \"\n                \"ROP node `{}`.\".format(instance_node)\n            )\n            return [hou.node(instance_node), error]\n\n        frame = instance.data.get(\"frameStart\", 0)\n        geometry = get_geometry_at_frame(node, frame)\n        if geometry is None:\n            # No geometry data on this node, maybe the node hasn't cooked?\n            error = (\n                \"SOP node `{}` has no geometry data. \"\n                \"Was it unable to cook?\".format(node.path())\n            )\n            return [node, error]\n\n        num_prims = geometry.intrinsicValue(\"primitivecount\")\n        num_points = geometry.intrinsicValue(\"pointcount\")\n        if num_prims == 0 and num_points == 0:\n            # Since we are only checking the first frame it doesn't mean there\n            # won't be VDB prims in a few frames. As such we'll assume for now\n            # the user knows what he or she is doing\n            cls.log.warning(\n                \"SOP node `{}` has no primitives on start frame {}. \"\n                \"Validation is skipped and it is assumed elsewhere in the \"\n                \"frame range VDB prims and only VDB prims will exist.\"\n                \"\".format(node.path(), int(frame))\n            )\n            return [None, None]\n\n        num_vdb_prims = geometry.countPrimType(hou.primType.VDB)\n        cls.log.debug(\"Detected {} VDB primitives\".format(num_vdb_prims))\n        if num_prims != num_vdb_prims:\n            # There's at least one primitive that is not a VDB.\n            # Search them and report them to the artist.\n            prims = geometry.prims()\n            invalid_prims = [prim for prim in prims\n                             if not isinstance(prim, hou.VDB)]\n            if invalid_prims:\n                # Log prim numbers as consecutive ranges so logging isn't very\n                # slow for large number of primitives\n                error = (\n                    \"Found non-VDB primitives for `{}`. \"\n                    \"Primitive indices {} are not VDB primitives.\".format(\n                        node.path(),\n                        \", \".join(group_consecutive_numbers(\n                            prim.number() for prim in invalid_prims\n                        ))\n                    )\n                )\n                return [node, error]\n\n        if num_points != num_vdb_prims:\n            # We have points unrelated to the VDB primitives.\n            error = (\n                \"The number of primitives and points do not match in '{}'. \"\n                \"This likely means you have unconnected points, which we do \"\n                \"not allow in the VDB output.\".format(node.path()))\n            return [node, error]\n\n        return [None, None]\n\n    @classmethod\n    def get_invalid(cls, instance):\n        nodes, _ = cls.get_invalid_with_message(instance)\n        return nodes\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_vdb_output_node.html#client.ayon_houdini.plugins.publish.validate_vdb_output_node.get_geometry_at_frame","title":"<code>get_geometry_at_frame(sop_node, frame, force=True)</code>","text":"<p>Return geometry at frame but force a cooked value.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_vdb_output_node.py</code> <pre><code>def get_geometry_at_frame(sop_node, frame, force=True):\n    \"\"\"Return geometry at frame but force a cooked value.\"\"\"\n    if not hasattr(sop_node, \"geometry\"):\n        return\n    with update_mode_context(hou.updateMode.AutoUpdate):\n        sop_node.cook(force=force, frame_range=(frame, frame))\n        return sop_node.geometryAtFrame(frame)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_vdb_output_node.html#client.ayon_houdini.plugins.publish.validate_vdb_output_node.group_consecutive_numbers","title":"<code>group_consecutive_numbers(nums)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>nums</code> <code>list</code> <p>List of sorted integer numbers.</p> required <p>Yields:</p> Name Type Description <code>str</code> <p>Group ranges as {start}-{end} if more than one number in the range else it yields {end}</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_vdb_output_node.py</code> <pre><code>def group_consecutive_numbers(nums):\n    \"\"\"\n    Args:\n        nums (list): List of sorted integer numbers.\n\n    Yields:\n        str: Group ranges as {start}-{end} if more than one number in the range\n            else it yields {end}\n\n    \"\"\"\n    start = None\n    end = None\n\n    def _result(a, b):\n        if a == b:\n            return \"{}\".format(a)\n        else:\n            return \"{}-{}\".format(a, b)\n\n    for num in nums:\n        if start is None:\n            start = num\n            end = num\n        elif num == end + 1:\n            end = num\n        else:\n            yield _result(start, end)\n            start = num\n            end = num\n    if start is not None:\n        yield _result(start, end)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_wait_for_render.html","title":"validate_wait_for_render","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_wait_for_render.html#client.ayon_houdini.plugins.publish.validate_wait_for_render.ValidateWaitForRender","title":"<code>ValidateWaitForRender</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code></p> <p>Validate <code>WaitForRendertoComplete</code> is enabled.</p> <p>Disabling <code>WaitForRendertoComplete</code> cause the local render to fail as the publish execution continues while the render may not be finished yet.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_wait_for_render.py</code> <pre><code>class ValidateWaitForRender(plugin.HoudiniInstancePlugin):\n    \"\"\"Validate `WaitForRendertoComplete` is enabled.\n\n    Disabling `WaitForRendertoComplete` cause the local render to fail\n    as the publish execution continues while the render may not be\n    finished yet.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"usdrender\"]\n    label = \"Validate Wait For Render to Complete\"\n    actions = [RepairAction]\n\n    def process(self, instance):\n        if not instance.data.get(\"instance_node\"):\n            # Ignore instances without an instance node\n            # e.g. in memory bootstrap instances\n            self.log.debug(\n                f\"Skipping instance without instance node: {instance}\"\n            )\n            return\n\n        if instance.data[\"creator_attributes\"].get(\"render_target\") != \"local\":\n            # This validator should work only with local render target.\n            self.log.debug(\n                \"Skipping Validator, Render target\"\n                \" is not 'Local machine rendering'\"\n            )\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            rop = invalid[0]\n            raise PublishValidationError(\n                f\"ROP node '{rop.path()}' has 'Wait For Render\"\n                \" to Complete' parm disabled.Please, enable it.\",\n                title=self.label\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        rop = hou.node(instance.data[\"instance_node\"])\n        if not rop.evalParm(\"soho_foreground\"):\n            return [rop]\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Enable WaitForRendertoComplete. \"\"\"\n\n        rop = hou.node(instance.data[\"instance_node\"])\n        rop.parm(\"soho_foreground\").set(True)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_wait_for_render.html#client.ayon_houdini.plugins.publish.validate_wait_for_render.ValidateWaitForRender.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Enable WaitForRendertoComplete.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_wait_for_render.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Enable WaitForRendertoComplete. \"\"\"\n\n    rop = hou.node(instance.data[\"instance_node\"])\n    rop.parm(\"soho_foreground\").set(True)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_workfile_paths.html","title":"validate_workfile_paths","text":""},{"location":"autoapi/client/ayon_houdini/plugins/publish/validate_workfile_paths.html#client.ayon_houdini.plugins.publish.validate_workfile_paths.ValidateWorkfilePaths","title":"<code>ValidateWorkfilePaths</code>","text":"<p>               Bases: <code>HoudiniInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate workfile paths so they are absolute.</p> Source code in <code>client/ayon_houdini/plugins/publish/validate_workfile_paths.py</code> <pre><code>class ValidateWorkfilePaths(\n        plugin.HoudiniInstancePlugin, OptionalPyblishPluginMixin):\n    \"\"\"Validate workfile paths so they are absolute.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"workfile\"]\n    label = \"Validate Workfile Paths\"\n    actions = [RepairAction]\n    optional = True\n\n    node_types = [\"file\", \"alembic\"]\n    prohibited_vars = [\"$HIP\", \"$JOB\"]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid()\n        self.log.debug(\n            \"Checking node types: {}\".format(\", \".join(self.node_types)))\n        self.log.debug(\n            \"Searching prohibited vars: {}\".format(\n                \", \".join(self.prohibited_vars)\n            )\n        )\n\n        if invalid:\n            all_container_vars = set()\n            for param in invalid:\n                value = param.unexpandedString()\n                contained_vars = [\n                    var for var in self.prohibited_vars\n                    if var in value\n                ]\n                all_container_vars.update(contained_vars)\n\n                self.log.error(\n                    \"Parm {} contains prohibited vars {}: {}\".format(\n                        param.path(),\n                        \", \".join(contained_vars),\n                        value)\n                )\n\n            message = (\n                \"Prohibited vars {} found in parameter values\".format(\n                    \", \".join(all_container_vars)\n                )\n            )\n            raise PublishValidationError(message, title=self.label)\n\n    @classmethod\n    def get_invalid(cls):\n        invalid = []\n        for param, _ in hou.fileReferences():\n            # it might return None for some reason\n            if not param:\n                continue\n            # skip nodes we are not interested in\n            if param.node().type().name() not in cls.node_types:\n                continue\n\n            if param.keyframes():\n                # Calling `.unexpandedString()` below fails if param has\n                # keyframes - so for now we will skip those params. These are\n                # e.g. present in `filecache` nodes.\n                continue\n\n            if any(\n                    v for v in cls.prohibited_vars\n                    if v in param.unexpandedString()):\n                invalid.append(param)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        invalid = cls.get_invalid()\n        for param in invalid:\n            cls.log.info(\"Processing: {}\".format(param.path()))\n            cls.log.info(\"Replacing {} for {}\".format(\n                param.unexpandedString(),\n                hou.text.expandString(param.unexpandedString())))\n            param.set(hou.text.expandString(param.unexpandedString()))\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/workfile_build/index.html","title":"workfile_build","text":""},{"location":"autoapi/client/ayon_houdini/plugins/workfile_build/create_placeholder.html","title":"create_placeholder","text":""},{"location":"autoapi/client/ayon_houdini/plugins/workfile_build/create_placeholder.html#client.ayon_houdini.plugins.workfile_build.create_placeholder.HoudiniPlaceholderCreatePlugin","title":"<code>HoudiniPlaceholderCreatePlugin</code>","text":"<p>               Bases: <code>HoudiniPlaceholderPlugin</code>, <code>PlaceholderCreateMixin</code></p> <p>Workfile template plugin to create \"create placeholders\".</p> <p>\"create placeholders\" will be replaced by publish instances.</p> TODO <p>Support imprint &amp; read precreate data to instances.</p> Source code in <code>client/ayon_houdini/plugins/workfile_build/create_placeholder.py</code> <pre><code>class HoudiniPlaceholderCreatePlugin(\n    HoudiniPlaceholderPlugin, PlaceholderCreateMixin\n):\n    \"\"\"Workfile template plugin to create \"create placeholders\".\n\n    \"create placeholders\" will be replaced by publish instances.\n\n    TODO:\n        Support imprint &amp; read precreate data to instances.\n    \"\"\"\n\n    identifier = \"ayon.create.placeholder\"\n    label = \"Houdini Create\"\n\n    def populate_placeholder(self, placeholder):\n        self.populate_create_placeholder(placeholder)\n\n    def repopulate_placeholder(self, placeholder):\n        self.populate_create_placeholder(placeholder)\n\n    def get_placeholder_options(self, options=None):\n        return self.get_create_plugin_options(options)\n\n    def get_placeholder_node_name(self, placeholder_data):\n        create_context = CreateContext(registered_host())\n        creator = create_context.creators.get(placeholder_data[\"creator\"])\n        product_type = creator.product_type\n        node_name = \"{}_{}\".format(\n            self.identifier.replace(\".\", \"_\"),\n            product_type\n        )\n\n        return node_name\n\n    def collect_placeholders(self):\n        output = []\n        create_placeholders = self.collect_scene_placeholders()\n\n        for node in create_placeholders:\n            placeholder_data = read(node)\n            output.append(\n                CreatePlaceholderItem(node.path(), placeholder_data, self)\n            )\n\n        return output\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/plugins/workfile_build/load_placeholder.html","title":"load_placeholder","text":""},{"location":"autoapi/client/ayon_houdini/plugins/workfile_build/load_placeholder.html#client.ayon_houdini.plugins.workfile_build.load_placeholder.HoudiniPlaceholderLoadPlugin","title":"<code>HoudiniPlaceholderLoadPlugin</code>","text":"<p>               Bases: <code>HoudiniPlaceholderPlugin</code>, <code>PlaceholderLoadMixin</code></p> <p>Workfile template plugin to create \"load placeholders\".</p> <p>\"load placeholders\" will be replaced by AYON products.</p> Source code in <code>client/ayon_houdini/plugins/workfile_build/load_placeholder.py</code> <pre><code>class HoudiniPlaceholderLoadPlugin(\n    HoudiniPlaceholderPlugin, PlaceholderLoadMixin\n):\n    \"\"\"Workfile template plugin to create \"load placeholders\".\n\n    \"load placeholders\" will be replaced by AYON products.\n\n    \"\"\"\n\n    identifier = \"ayon.load.placeholder\"\n    label = \"Houdini Load\"\n\n    def populate_placeholder(self, placeholder):\n        self.populate_load_placeholder(placeholder)\n\n    def repopulate_placeholder(self, placeholder):\n        self.populate_load_placeholder(placeholder)\n\n    def get_placeholder_options(self, options=None):\n        return self.get_load_plugin_options(options)\n\n    def get_placeholder_node_name(self, placeholder_data):\n        node_name = \"{}_{}\".format(\n            self.identifier.replace(\".\", \"_\"),\n            placeholder_data[\"product_name\"]\n        )\n        return node_name\n\n    def collect_placeholders(self):\n        output = []\n        load_placeholders = self.collect_scene_placeholders()\n\n        for node in load_placeholders:\n            placeholder_data = read(node)\n            output.append(\n                LoadPlaceholderItem(node.path(), placeholder_data, self)\n            )\n\n        return output\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/startup/index.html","title":"startup","text":""},{"location":"autoapi/client/ayon_houdini/startup/husdplugins/index.html","title":"husdplugins","text":""},{"location":"autoapi/client/ayon_houdini/startup/husdplugins/outputprocessors/index.html","title":"outputprocessors","text":""},{"location":"autoapi/client/ayon_houdini/startup/husdplugins/outputprocessors/ayon_uri_processor.html","title":"ayon_uri_processor","text":""},{"location":"autoapi/client/ayon_houdini/startup/husdplugins/outputprocessors/ayon_uri_processor.html#client.ayon_houdini.startup.husdplugins.outputprocessors.ayon_uri_processor.AYONURIOutputProcessor","title":"<code>AYONURIOutputProcessor</code>","text":"<p>               Bases: <code>OutputProcessor</code></p> <p>Process AYON Entity URIs into their full path equivalents.</p> Source code in <code>client/ayon_houdini/startup/husdplugins/outputprocessors/ayon_uri_processor.py</code> <pre><code>class AYONURIOutputProcessor(OutputProcessor):\n    \"\"\"Process AYON Entity URIs into their full path equivalents.\"\"\"\n\n    def __init__(self):\n        \"\"\" There is only one object of each output processor class that is\n            ever created in a Houdini session. Therefore, be very careful\n            about what data gets put in this object.\n        \"\"\"\n        self._save_cache = dict()\n        self._ref_cache = dict()\n        self._publish_context = None\n        self.log = logging.getLogger(__name__)\n\n    @staticmethod\n    def name():\n        return \"ayon_uri_processor\"\n\n    @staticmethod\n    def displayName():\n        return \"AYON URI Output Processor\"\n\n    def processReferencePath(self,\n                             asset_path,\n                             referencing_layer_path,\n                             asset_is_layer):\n        \"\"\"\n        Args:\n            asset_path (str): The path to the asset, as specified in Houdini.\n               If this asset is being written to disk, this will be the final\n               output of the `processSavePath()` calls on all output\n               processors.\n            referencing_layer_path (str): The absolute file path of the file\n               containing the reference to the asset. You can use this to make\n               the path pointer relative.\n            asset_is_layer (bool): A boolean value indicating whether this\n                asset is a USD layer file. If this is `False`, the asset is\n                something else (for example, a texture or volume file).\n\n        Returns:\n            The refactored reference path.\n\n        \"\"\"\n\n        cache = self._ref_cache\n\n        # Retrieve from cache if this query occurred before (optimization)\n        if asset_path in cache:\n            return cache[asset_path]\n\n        uri_data = entity_uri.parse_ayon_entity_uri(asset_path)\n        if not uri_data:\n            cache[asset_path] = asset_path\n            return asset_path\n\n        # Try and find it as an existing publish\n        query = {\n            \"project_name\": uri_data[\"project\"],\n            \"folder_path\": uri_data[\"folder\"],\n            \"product_name\": uri_data[\"product\"],\n            \"version_name\": uri_data[\"version\"],\n            \"representation_name\": uri_data[\"representation\"],\n        }\n        path = get_representation_path_by_names(\n            **query\n        )\n        if path:\n            self.log.debug(\n                \"AYON URI Resolver - ref: %s -&gt; %s\", asset_path, path\n            )\n            cache[asset_path] = path\n            return path\n\n        elif self._publish_context:\n            # Query doesn't resolve to an existing version - likely\n            # points to a version defined in the current publish session\n            # as such we should resolve it using the current publish\n            # context if that was set prior to this publish\n            raise NotImplementedError(\"TODO\")\n\n        self.log.warning(f\"Unable to resolve AYON URI: {asset_path}\")\n        cache[asset_path] = asset_path\n        return asset_path\n\n    def processSavePath(self,\n                        asset_path,\n                        referencing_layer_path,\n                        asset_is_layer):\n        \"\"\"\n        Args:\n            asset_path (str): The path to the asset, as specified in Houdini.\n               If this asset is being written to disk, this will be the final\n               output of the `processSavePath()` calls on all output\n               processors.\n            referencing_layer_path (str): The absolute file path of the file\n               containing the reference to the asset. You can use this to make\n               the path pointer relative.\n            asset_is_layer (bool): A boolean value indicating whether this\n                asset is a USD layer file. If this is `False`, the asset is\n                something else (for example, a texture or volume file).\n\n        Returns:\n            The refactored save path.\n\n        \"\"\"\n        cache = self._save_cache\n\n        # Retrieve from cache if this query occurred before (optimization)\n        if asset_path in cache:\n            return cache[asset_path]\n\n        uri_data = entity_uri.parse_ayon_entity_uri(asset_path)\n        if not uri_data:\n            cache[asset_path] = asset_path\n            return asset_path\n\n        relative_template = \"{asset}_{product}_{version}_{representation}.usd\"\n        # Set save output path to a relative path so other\n        # processors can potentially manage it easily?\n        path = relative_template.format(**uri_data)\n\n        self.log.debug(\"AYON URI Resolver - save: %s -&gt; %s\", asset_path, path)\n        cache[asset_path] = path\n        return path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/startup/husdplugins/outputprocessors/ayon_uri_processor.html#client.ayon_houdini.startup.husdplugins.outputprocessors.ayon_uri_processor.AYONURIOutputProcessor.__init__","title":"<code>__init__()</code>","text":"<p>There is only one object of each output processor class that is ever created in a Houdini session. Therefore, be very careful about what data gets put in this object.</p> Source code in <code>client/ayon_houdini/startup/husdplugins/outputprocessors/ayon_uri_processor.py</code> <pre><code>def __init__(self):\n    \"\"\" There is only one object of each output processor class that is\n        ever created in a Houdini session. Therefore, be very careful\n        about what data gets put in this object.\n    \"\"\"\n    self._save_cache = dict()\n    self._ref_cache = dict()\n    self._publish_context = None\n    self.log = logging.getLogger(__name__)\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/startup/husdplugins/outputprocessors/ayon_uri_processor.html#client.ayon_houdini.startup.husdplugins.outputprocessors.ayon_uri_processor.AYONURIOutputProcessor.processReferencePath","title":"<code>processReferencePath(asset_path, referencing_layer_path, asset_is_layer)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_path</code> <code>str</code> <p>The path to the asset, as specified in Houdini. If this asset is being written to disk, this will be the final output of the <code>processSavePath()</code> calls on all output processors.</p> required <code>referencing_layer_path</code> <code>str</code> <p>The absolute file path of the file containing the reference to the asset. You can use this to make the path pointer relative.</p> required <code>asset_is_layer</code> <code>bool</code> <p>A boolean value indicating whether this asset is a USD layer file. If this is <code>False</code>, the asset is something else (for example, a texture or volume file).</p> required <p>Returns:</p> Type Description <p>The refactored reference path.</p> Source code in <code>client/ayon_houdini/startup/husdplugins/outputprocessors/ayon_uri_processor.py</code> <pre><code>def processReferencePath(self,\n                         asset_path,\n                         referencing_layer_path,\n                         asset_is_layer):\n    \"\"\"\n    Args:\n        asset_path (str): The path to the asset, as specified in Houdini.\n           If this asset is being written to disk, this will be the final\n           output of the `processSavePath()` calls on all output\n           processors.\n        referencing_layer_path (str): The absolute file path of the file\n           containing the reference to the asset. You can use this to make\n           the path pointer relative.\n        asset_is_layer (bool): A boolean value indicating whether this\n            asset is a USD layer file. If this is `False`, the asset is\n            something else (for example, a texture or volume file).\n\n    Returns:\n        The refactored reference path.\n\n    \"\"\"\n\n    cache = self._ref_cache\n\n    # Retrieve from cache if this query occurred before (optimization)\n    if asset_path in cache:\n        return cache[asset_path]\n\n    uri_data = entity_uri.parse_ayon_entity_uri(asset_path)\n    if not uri_data:\n        cache[asset_path] = asset_path\n        return asset_path\n\n    # Try and find it as an existing publish\n    query = {\n        \"project_name\": uri_data[\"project\"],\n        \"folder_path\": uri_data[\"folder\"],\n        \"product_name\": uri_data[\"product\"],\n        \"version_name\": uri_data[\"version\"],\n        \"representation_name\": uri_data[\"representation\"],\n    }\n    path = get_representation_path_by_names(\n        **query\n    )\n    if path:\n        self.log.debug(\n            \"AYON URI Resolver - ref: %s -&gt; %s\", asset_path, path\n        )\n        cache[asset_path] = path\n        return path\n\n    elif self._publish_context:\n        # Query doesn't resolve to an existing version - likely\n        # points to a version defined in the current publish session\n        # as such we should resolve it using the current publish\n        # context if that was set prior to this publish\n        raise NotImplementedError(\"TODO\")\n\n    self.log.warning(f\"Unable to resolve AYON URI: {asset_path}\")\n    cache[asset_path] = asset_path\n    return asset_path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/startup/husdplugins/outputprocessors/ayon_uri_processor.html#client.ayon_houdini.startup.husdplugins.outputprocessors.ayon_uri_processor.AYONURIOutputProcessor.processSavePath","title":"<code>processSavePath(asset_path, referencing_layer_path, asset_is_layer)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_path</code> <code>str</code> <p>The path to the asset, as specified in Houdini. If this asset is being written to disk, this will be the final output of the <code>processSavePath()</code> calls on all output processors.</p> required <code>referencing_layer_path</code> <code>str</code> <p>The absolute file path of the file containing the reference to the asset. You can use this to make the path pointer relative.</p> required <code>asset_is_layer</code> <code>bool</code> <p>A boolean value indicating whether this asset is a USD layer file. If this is <code>False</code>, the asset is something else (for example, a texture or volume file).</p> required <p>Returns:</p> Type Description <p>The refactored save path.</p> Source code in <code>client/ayon_houdini/startup/husdplugins/outputprocessors/ayon_uri_processor.py</code> <pre><code>def processSavePath(self,\n                    asset_path,\n                    referencing_layer_path,\n                    asset_is_layer):\n    \"\"\"\n    Args:\n        asset_path (str): The path to the asset, as specified in Houdini.\n           If this asset is being written to disk, this will be the final\n           output of the `processSavePath()` calls on all output\n           processors.\n        referencing_layer_path (str): The absolute file path of the file\n           containing the reference to the asset. You can use this to make\n           the path pointer relative.\n        asset_is_layer (bool): A boolean value indicating whether this\n            asset is a USD layer file. If this is `False`, the asset is\n            something else (for example, a texture or volume file).\n\n    Returns:\n        The refactored save path.\n\n    \"\"\"\n    cache = self._save_cache\n\n    # Retrieve from cache if this query occurred before (optimization)\n    if asset_path in cache:\n        return cache[asset_path]\n\n    uri_data = entity_uri.parse_ayon_entity_uri(asset_path)\n    if not uri_data:\n        cache[asset_path] = asset_path\n        return asset_path\n\n    relative_template = \"{asset}_{product}_{version}_{representation}.usd\"\n    # Set save output path to a relative path so other\n    # processors can potentially manage it easily?\n    path = relative_template.format(**uri_data)\n\n    self.log.debug(\"AYON URI Resolver - save: %s -&gt; %s\", asset_path, path)\n    cache[asset_path] = path\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_houdini/startup/husdplugins/outputprocessors/remap_to_publish.html","title":"remap_to_publish","text":""},{"location":"autoapi/client/ayon_houdini/startup/husdplugins/outputprocessors/remap_to_publish.html#client.ayon_houdini.startup.husdplugins.outputprocessors.remap_to_publish.AYONRemapPaths","title":"<code>AYONRemapPaths</code>","text":"<p>               Bases: <code>OutputProcessor</code></p> <p>Remap paths based on a mapping dict on rop node.</p> Source code in <code>client/ayon_houdini/startup/husdplugins/outputprocessors/remap_to_publish.py</code> <pre><code>class AYONRemapPaths(OutputProcessor):\n    \"\"\"Remap paths based on a mapping dict on rop node.\"\"\"\n\n    def __init__(self):\n        self._mapping = dict()\n\n    @staticmethod\n    def name():\n        return \"ayon_remap_paths\"\n\n    @staticmethod\n    def displayName():\n        return \"AYON Remap Paths\"\n\n    @staticmethod\n    def hidden():\n        return True\n\n    @staticmethod\n    def parameters():\n        group = hou.ParmTemplateGroup()\n\n        parm_template = hou.StringParmTemplate(\n            \"ayon_remap_paths_remap_json\",\n            \"Remapping dict (json)\",\n            default_value=\"{}\",\n            num_components=1,\n            string_type=hou.stringParmType.Regular,\n        )\n        group.append(parm_template)\n\n        return group.asDialogScript()\n\n    def beginSave(self,\n                  config_node,\n                  config_overrides,\n                  lop_node,\n                  t,\n                  # Added in Houdini 20.5.182\n                  stage_variables=_COMPATIBILITY_PLACEHOLDER):\n\n        args = [config_node, config_overrides, lop_node, t]\n        if stage_variables is not _COMPATIBILITY_PLACEHOLDER:\n            args.append(stage_variables)\n        super(AYONRemapPaths, self).beginSave(*args)\n\n        value = config_node.evalParm(\"ayon_remap_paths_remap_json\")\n        mapping = json.loads(value)\n        assert isinstance(self._mapping, dict)\n\n        # Ensure all keys are normalized paths so the lookup can be done\n        # correctly\n        mapping = {\n            os.path.normpath(key): value for key, value in mapping.items()\n        }\n        self._mapping = mapping\n\n    def processReferencePath(self,\n                             asset_path,\n                             referencing_layer_path,\n                             asset_is_layer):\n        return self._mapping.get(os.path.normpath(asset_path), asset_path)\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/create.html","title":"create","text":""},{"location":"autoapi/server/settings/general.html","title":"general","text":""},{"location":"autoapi/server/settings/general.html#server.settings.general.UpdateHoudiniVarcontextModel","title":"<code>UpdateHoudiniVarcontextModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Sync vars with context changes.</p> <p>If a value is treated as a directory on update it will be ensured the folder exists.</p> Source code in <code>server/settings/general.py</code> <pre><code>class UpdateHoudiniVarcontextModel(BaseSettingsModel):\n    \"\"\"Sync vars with context changes.\n\n    If a value is treated as a directory on update\n    it will be ensured the folder exists.\n    \"\"\"\n\n    enabled: bool = SettingsField(title=\"Enabled\")\n    # TODO this was dynamic dictionary '{var: path}'\n    houdini_vars: list[HoudiniVarModel] = SettingsField(\n        default_factory=list,\n        title=\"Houdini Vars\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/imageio.html#server.settings.imageio.WorkfileImageIOModel","title":"<code>WorkfileImageIOModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Workfile settings help.</p> <p>Empty values will be skipped, allowing any existing env vars to pass through as defined.</p> <p>Note: The render space in Houdini is always set to the 'scene_linear' role.</p> Source code in <code>server/settings/imageio.py</code> <pre><code>class WorkfileImageIOModel(BaseSettingsModel):\n    \"\"\"Workfile settings help.\n\n    Empty values will be skipped, allowing any existing env vars to\n    pass through as defined.\n\n    Note: The render space in Houdini is\n    always set to the 'scene_linear' role.\"\"\"\n\n    enabled: bool = SettingsField(False, title=\"Enabled\")\n    default_display: str = SettingsField(\n        title=\"Default active displays\",\n        description=\"It behaves like the 'OCIO_ACTIVE_DISPLAYS' env var,\"\n                    \" Colon-separated list of displays, e.g ACES:P3\"\n    )\n    default_view: str = SettingsField(\n        title=\"Default active views\",\n        description=\"It behaves like the 'OCIO_ACTIVE_VIEWS' env var,\"\n                    \" Colon-separated list of views, e.g sRGB:DCDM\"\n    )\n    review_color_space: str = SettingsField(\n        title=\"Review colorspace\",\n        description=\"It exposes OCIO Colorspace parameter in opengl nodes.\"\n                    \"if left empty, Ayon will figure out the default \"\n                    \"colorspace using your default display and default view.\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/load.html","title":"load","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/publish.html","title":"publish","text":""},{"location":"autoapi/server/settings/publish.html#server.settings.publish.AOVFilterSubmodel","title":"<code>AOVFilterSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>You should use the same host name you are using for Houdini.</p> Source code in <code>server/settings/publish.py</code> <pre><code>class AOVFilterSubmodel(BaseSettingsModel):\n    \"\"\"You should use the same host name you are using for Houdini.\"\"\"\n    host_name: str = SettingsField(\"\", title=\"Houdini Host name\")\n    value: list[str] = SettingsField(\n        default_factory=list,\n        title=\"AOV regex\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish.html#server.settings.publish.CollectAssetHandlesModel","title":"<code>CollectAssetHandlesModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Collect Frame Range Disable this if you want the publisher to ignore start and end handles specified in the asset data for publish instances</p> Source code in <code>server/settings/publish.py</code> <pre><code>class CollectAssetHandlesModel(BaseSettingsModel):\n    \"\"\"Collect Frame Range\n    Disable this if you want the publisher to\n    ignore start and end handles specified in the\n    asset data for publish instances\n    \"\"\"\n    use_asset_handles: bool = SettingsField(\n        title=\"Use asset handles\")\n</code></pre>"},{"location":"autoapi/server/settings/shelves.html","title":"shelves","text":""},{"location":"autoapi/server/settings/shelves.html#server.settings.shelves.ShelfToolsModel","title":"<code>ShelfToolsModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Name and Script Path are mandatory.</p> Source code in <code>server/settings/shelves.py</code> <pre><code>class ShelfToolsModel(BaseSettingsModel):\n    \"\"\"Name and Script Path are mandatory.\"\"\"\n    label: str = SettingsField(title=\"Name\")\n    script: str = SettingsField(title=\"Script Path\")\n    icon: str = SettingsField(\"\", title=\"Icon Path\")\n    help: str = SettingsField(\"\", title=\"Help text\")\n</code></pre>"},{"location":"autoapi/server/settings/templated_workfile_build.html","title":"templated_workfile_build","text":""},{"location":"autoapi/server/settings/templated_workfile_build.html#server.settings.templated_workfile_build.TemplatedWorkfileBuildModel","title":"<code>TemplatedWorkfileBuildModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Settings for templated workfile builder.</p> Source code in <code>server/settings/templated_workfile_build.py</code> <pre><code>class TemplatedWorkfileBuildModel(BaseSettingsModel):\n    \"\"\"Settings for templated workfile builder.\"\"\"\n    profiles: list[TemplatedWorkfileProfileModel] = SettingsField(\n        default_factory=list\n    )\n</code></pre>"}]}